---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - turbo.json
  - apps/slack-backend/package.json
  - apps/slack-backend/tsconfig.json
  - packages/database/package.json
  - packages/database/src/schema.ts
  - packages/database/src/client.ts
  - packages/database/drizzle.config.ts
  - packages/validation/package.json
  - packages/validation/src/index.ts
  - .env.example
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "npm install succeeds without errors"
    - "TypeScript compiles without errors"
    - "Database migrations run successfully"
    - "PostgreSQL RLS policies are enabled on multi-tenant tables"
  artifacts:
    - path: "package.json"
      provides: "Root monorepo configuration"
      contains: "workspaces"
    - path: "apps/slack-backend/src/index.ts"
      provides: "Backend entry point"
      min_lines: 5
    - path: "packages/database/src/schema.ts"
      provides: "Drizzle schema with workspaces, installations, users tables"
      contains: "pgTable"
    - path: "packages/database/src/client.ts"
      provides: "Database connection with pooling"
      contains: "drizzle"
  key_links:
    - from: "apps/slack-backend/package.json"
      to: "@slack-speak/database"
      via: "workspace dependency"
      pattern: '"@slack-speak/database"'
    - from: "packages/database/src/schema.ts"
      to: "PostgreSQL"
      via: "Drizzle schema definition"
      pattern: "pgTable"
---

<objective>
Scaffold the monorepo project structure with TypeScript, create the database schema with Drizzle ORM, and configure PostgreSQL Row-Level Security for multi-tenant isolation.

Purpose: Establishes the foundational project structure that all subsequent plans build upon. Without this foundation, no other code can be written.

Output: A working monorepo with TypeScript, Drizzle ORM configured, database schema with RLS policies, and ready for application code.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold monorepo with TypeScript</name>
  <files>
    package.json
    tsconfig.json
    turbo.json
    apps/slack-backend/package.json
    apps/slack-backend/tsconfig.json
    apps/slack-backend/src/index.ts
    packages/database/package.json
    packages/database/tsconfig.json
    packages/validation/package.json
    packages/validation/tsconfig.json
    packages/validation/src/index.ts
    .env.example
    .gitignore
  </files>
  <action>
    Create monorepo structure using npm workspaces (NOT pnpm or yarn - keep it simple):

    1. Root package.json with workspaces: ["apps/*", "packages/*"]
    2. Root tsconfig.json with strict mode, ES2022 target, NodeNext module resolution
    3. turbo.json for build orchestration (optional but recommended for monorepo builds)

    Create apps/slack-backend/:
    - package.json with name "@slack-speak/slack-backend"
    - Dependencies: @slack/bolt, ioredis, bullmq, drizzle-orm, postgres, zod, pino, date-fns, dotenv
    - Dev dependencies: typescript, @types/node, tsx (for development), drizzle-kit
    - Scripts: "dev": "tsx watch src/index.ts", "build": "tsc", "start": "node dist/index.js"
    - tsconfig.json extending root
    - src/index.ts with placeholder: console.log('Slack backend starting...')

    Create packages/database/:
    - package.json with name "@slack-speak/database"
    - Dependencies: drizzle-orm, postgres, zod
    - Dev dependencies: drizzle-kit, typescript
    - tsconfig.json extending root

    Create packages/validation/:
    - package.json with name "@slack-speak/validation"
    - Dependencies: zod
    - Dev dependencies: typescript
    - tsconfig.json extending root
    - src/index.ts with placeholder export

    Create .env.example with required variables:
    - DATABASE_URL
    - REDIS_HOST, REDIS_PORT
    - SLACK_CLIENT_ID, SLACK_CLIENT_SECRET, SLACK_SIGNING_SECRET, SLACK_STATE_SECRET
    - ENCRYPTION_KEY (note: 64 hex chars = 32 bytes)
    - NODE_ENV, PORT
    - ANTHROPIC_API_KEY

    Create .gitignore:
    - node_modules, dist, .env, *.log, .turbo, .DS_Store
  </action>
  <verify>
    Run: npm install
    Run: npm run build --workspaces --if-present
    Both should complete without errors.
  </verify>
  <done>
    Monorepo structure exists with all packages, npm install succeeds, TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database schema with Drizzle and RLS</name>
  <files>
    packages/database/src/schema.ts
    packages/database/src/client.ts
    packages/database/src/index.ts
    packages/database/drizzle.config.ts
    packages/database/src/migrations/0000_initial_schema.sql
  </files>
  <action>
    **IMPORTANT: Column naming convention**
    Drizzle ORM by default uses the TypeScript property name as the column name. We will use snake_case for database columns explicitly. Define columns with snake_case names in the pgTable definition to match PostgreSQL convention and RLS policy syntax.

    Create Drizzle schema in packages/database/src/schema.ts with tables:

    1. workspaces table:
       - id: uuid primary key (defaultRandom)
       - team_id: text, unique, not null (Slack team ID like T12345) - use { name: 'team_id' } or just 'team_id' as first arg
       - enterprise_id: text, nullable (for Enterprise Grid)
       - name: text, nullable (workspace name)
       - created_at: timestamp, defaultNow
       - updated_at: timestamp, defaultNow

    2. installations table:
       - id: uuid primary key (defaultRandom)
       - workspace_id: uuid, references workspaces.id, not null
       - bot_token: text, not null (encrypted)
       - bot_user_id: text
       - bot_scopes: text (comma-separated)
       - user_token: text, nullable (encrypted, only if user scopes requested)
       - user_id: text
       - user_scopes: text, nullable
       - installed_at: timestamp, defaultNow
       - Index on workspace_id

    3. users table (app users, not Slack users):
       - id: uuid primary key (defaultRandom)
       - workspace_id: uuid, references workspaces.id, not null
       - slack_user_id: text, not null
       - email: text, nullable
       - created_at: timestamp, defaultNow
       - Index on workspace_id
       - Index on slack_user_id

    Example schema definition with explicit snake_case:
    ```typescript
    export const workspaces = pgTable('workspaces', {
      id: uuid('id').primaryKey().defaultRandom(),
      teamId: text('team_id').notNull().unique(),
      enterpriseId: text('enterprise_id'),
      name: text('name'),
      createdAt: timestamp('created_at').defaultNow(),
      updatedAt: timestamp('updated_at').defaultNow(),
    });

    export const users = pgTable('users', {
      id: uuid('id').primaryKey().defaultRandom(),
      workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
      slackUserId: text('slack_user_id').notNull(),
      email: text('email'),
      createdAt: timestamp('created_at').defaultNow(),
    }, (table) => ({
      workspaceIdx: index('users_workspace_id_idx').on(table.workspaceId),
      slackUserIdx: index('users_slack_user_id_idx').on(table.slackUserId),
    }));
    ```

    Create packages/database/src/client.ts:
    - Use postgres library for connection
    - Create drizzle instance with schema
    - Export db and helper function withWorkspaceContext(workspaceId, fn) that:
      - Starts a transaction
      - Sets LOCAL app.current_workspace_id to workspaceId
      - Executes the provided function
      - Returns result

    Create packages/database/drizzle.config.ts:
    - Schema path: ./src/schema.ts
    - Out directory: ./src/migrations
    - Dialect: postgresql
    - dbCredentials from DATABASE_URL env var

    Create initial migration SQL (0000_initial_schema.sql):
    - CREATE TABLE statements for all tables (with snake_case column names)
    - Enable RLS on users table: ALTER TABLE users ENABLE ROW LEVEL SECURITY
    - Create RLS policy using snake_case column name:
      ```sql
      CREATE POLICY tenant_isolation ON users
      USING (workspace_id = current_setting('app.current_workspace_id', true)::uuid);
      ```
    - Note: The column is `workspace_id` (snake_case) in the database, matching the RLS policy
    - Note: installations table does NOT get RLS (accessed by system during OAuth, not per-tenant)

    Create packages/database/src/index.ts that re-exports:
    - All schema tables
    - db client
    - withWorkspaceContext helper
  </action>
  <verify>
    Run: cd packages/database && npx drizzle-kit generate
    Should create migration files without errors.

    If DATABASE_URL is set, run: npx drizzle-kit push
    Should apply schema to database.

    Verify column names in generated SQL use snake_case (workspace_id, team_id, etc.)
  </verify>
  <done>
    Schema file exports workspaces, installations, users tables with snake_case DB columns.
    Client exports db and withWorkspaceContext.
    Migration SQL includes RLS policy for users table using workspace_id (snake_case matches schema).
  </done>
</task>

</tasks>

<verification>
1. `npm install` at root completes successfully
2. `npm run build --workspaces --if-present` compiles without TypeScript errors
3. packages/database/src/schema.ts defines workspaces, installations, users tables
4. packages/database/src/client.ts exports withWorkspaceContext helper
5. Migration file includes ALTER TABLE ... ENABLE ROW LEVEL SECURITY
6. Migration file includes CREATE POLICY tenant_isolation with workspace_id (snake_case)
7. Schema uses explicit snake_case column names matching RLS policy
</verification>

<success_criteria>
- Monorepo structure with apps/slack-backend and packages/database, packages/validation
- All dependencies installed (npm install succeeds)
- TypeScript compiles without errors
- Database schema defines multi-tenant tables with RLS
- Column naming is consistent: snake_case in DB, matching RLS policy syntax
- .env.example documents all required environment variables
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
