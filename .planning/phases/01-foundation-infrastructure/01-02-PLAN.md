---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/database/src/encryption.ts
  - apps/slack-backend/src/oauth/installation-store.ts
  - apps/slack-backend/src/app.ts
  - apps/slack-backend/src/env.ts
autonomous: true
user_setup:
  - service: slack
    why: "Slack app credentials for OAuth flow"
    env_vars:
      - name: SLACK_CLIENT_ID
        source: "Slack API Dashboard -> Your App -> Basic Information -> App Credentials"
      - name: SLACK_CLIENT_SECRET
        source: "Slack API Dashboard -> Your App -> Basic Information -> App Credentials"
      - name: SLACK_SIGNING_SECRET
        source: "Slack API Dashboard -> Your App -> Basic Information -> App Credentials"
    dashboard_config:
      - task: "Create Slack App"
        location: "https://api.slack.com/apps -> Create New App -> From scratch"
      - task: "Enable OAuth & Permissions"
        location: "Your App -> OAuth & Permissions -> Add OAuth Scopes (channels:history, channels:read, chat:write, users:read, app_mentions:read)"
      - task: "Add OAuth Redirect URL"
        location: "Your App -> OAuth & Permissions -> Redirect URLs -> Add https://your-domain/slack/oauth_redirect"

must_haves:
  truths:
    - "OAuth tokens are encrypted before database storage"
    - "OAuth tokens are decrypted when retrieved from database"
    - "Slack app can be initialized with custom installation store"
    - "Environment variables are validated at startup with clear error messages"
  artifacts:
    - path: "packages/database/src/encryption.ts"
      provides: "AES-256-GCM encryption/decryption utilities"
      exports: ["encrypt", "decrypt"]
    - path: "apps/slack-backend/src/oauth/installation-store.ts"
      provides: "Bolt-compatible installation store backed by PostgreSQL"
      exports: ["installationStore"]
    - path: "apps/slack-backend/src/app.ts"
      provides: "Slack Bolt app with OAuth configuration"
      exports: ["app"]
    - path: "apps/slack-backend/src/env.ts"
      provides: "Validated environment configuration"
      exports: ["env"]
  key_links:
    - from: "apps/slack-backend/src/oauth/installation-store.ts"
      to: "packages/database/src/encryption.ts"
      via: "import encrypt/decrypt"
      pattern: "import.*encrypt.*from"
    - from: "apps/slack-backend/src/oauth/installation-store.ts"
      to: "packages/database"
      via: "database queries for installations"
      pattern: "db\\.insert|db\\.query"
    - from: "apps/slack-backend/src/app.ts"
      to: "apps/slack-backend/src/oauth/installation-store.ts"
      via: "installationStore option in App constructor"
      pattern: "installationStore"
---

<objective>
Implement secure OAuth token storage with AES-256-GCM encryption and create the Slack Bolt app with database-backed OAuth installation store.

Purpose: Enables users to install the Slack app to their workspace. Tokens are encrypted at rest to comply with security best practices (INFRA-01) and Slack's security recommendations.

Output: Working OAuth installation store that encrypts tokens, Bolt app initialized with OAuth, environment validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encryption utilities and environment validation</name>
  <files>
    packages/database/src/encryption.ts
    packages/database/src/index.ts
    apps/slack-backend/src/env.ts
  </files>
  <action>
    Create packages/database/src/encryption.ts:

    1. Import crypto from Node.js
    2. Define ALGORITHM = 'aes-256-gcm'
    3. Create encrypt(text: string, key: Buffer): string function:
       - Generate 16-byte random IV using crypto.randomBytes(16)
       - Create cipher with crypto.createCipheriv(ALGORITHM, key, iv)
       - Encrypt text to hex
       - Get auth tag with cipher.getAuthTag()
       - Return format: `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
    4. Create decrypt(text: string, key: Buffer): string function:
       - Split text by ':' to get [ivHex, authTagHex, encrypted]
       - Create decipher with crypto.createDecipheriv
       - Set auth tag with decipher.setAuthTag
       - Decrypt and return plaintext
    5. Export both functions

    Update packages/database/src/index.ts to export encryption utilities.

    Create apps/slack-backend/src/env.ts:

    1. Import { z } from 'zod'
    2. Create EnvSchema with:
       - SLACK_CLIENT_ID: z.string().min(1)
       - SLACK_CLIENT_SECRET: z.string().min(1)
       - SLACK_SIGNING_SECRET: z.string().min(1)
       - SLACK_STATE_SECRET: z.string().min(32, 'State secret must be at least 32 characters')
       - DATABASE_URL: z.string().url()
       - REDIS_HOST: z.string().default('localhost')
       - REDIS_PORT: z.coerce.number().default(6379)
       - ENCRYPTION_KEY: z.string().length(64, 'Encryption key must be 64 hex characters (32 bytes)')
       - ANTHROPIC_API_KEY: z.string().min(1)
       - NODE_ENV: z.enum(['development', 'staging', 'production']).default('development')
       - PORT: z.coerce.number().default(3000)
    3. Parse process.env with schema
    4. Create helper getEncryptionKey() that returns Buffer.from(env.ENCRYPTION_KEY, 'hex')
    5. Export env and getEncryptionKey

    Add error handling: if validation fails, log which variables are missing/invalid and exit with code 1.
  </action>
  <verify>
    Create a test script that:
    1. Encrypts a test string
    2. Decrypts it back
    3. Verifies original === decrypted
    Run the test with a mock 32-byte key.
  </verify>
  <done>
    encryption.ts exports encrypt/decrypt functions using AES-256-GCM.
    env.ts exports validated env object with all required Slack and infrastructure variables.
    Missing env vars produce clear error messages at startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth installation store and Bolt app</name>
  <files>
    apps/slack-backend/src/oauth/installation-store.ts
    apps/slack-backend/src/app.ts
    apps/slack-backend/src/index.ts
  </files>
  <action>
    Create apps/slack-backend/src/oauth/installation-store.ts:

    1. Import InstallationStore type from @slack/bolt
    2. Import db, installations table, workspaces table from @slack-speak/database
    3. Import encrypt, decrypt from @slack-speak/database
    4. Import getEncryptionKey from ../env
    5. Import eq from drizzle-orm

    Implement installationStore object with:

    storeInstallation: async (installation) => {
      - Get teamId from installation.team?.id
      - Get enterpriseId from installation.enterprise?.id
      - Validate at least one exists, throw if not
      - Get encryption key with getEncryptionKey()
      - Encrypt bot token: encrypt(installation.bot?.token || '', key)
      - Encrypt user token if exists: installation.user?.token ? encrypt(...) : null
      - Upsert workspace (insert on conflict update name)
      - Get workspace ID from upsert result
      - Insert or update installation record with encrypted tokens
    }

    fetchInstallation: async (installQuery) => {
      - Query installations table joined with workspaces
      - Match by teamId (and enterpriseId for Enterprise Grid)
      - Throw 'Installation not found' if no result
      - Decrypt tokens before returning
      - Return Bolt-compatible Installation object
    }

    deleteInstallation: async (installQuery) => {
      - Delete installation record (soft delete by marking inactive, or hard delete)
      - Log deletion for audit trail
    }

    Export installationStore.

    Create apps/slack-backend/src/app.ts:

    1. Import { App } from '@slack/bolt'
    2. Import env from './env'
    3. Import installationStore from './oauth/installation-store'
    4. Create and export app = new App({
         signingSecret: env.SLACK_SIGNING_SECRET,
         clientId: env.SLACK_CLIENT_ID,
         clientSecret: env.SLACK_CLIENT_SECRET,
         stateSecret: env.SLACK_STATE_SECRET,
         installationStore,
         scopes: [
           'channels:history',
           'channels:read',
           'chat:write',
           'users:read',
           'app_mentions:read',
         ],
         installerOptions: {
           directInstall: true,
         },
       })

    Update apps/slack-backend/src/index.ts:

    1. Import { app } from './app'
    2. Import { env } from './env'
    3. Import pino for logging
    4. Create logger
    5. Start app with await app.start(env.PORT)
    6. Log "Bolt app is running on port {PORT}"
  </action>
  <verify>
    Run: cd apps/slack-backend && npm run build
    Should compile without TypeScript errors.

    Run: npm run dev (with mock env vars)
    Should start without crashing (will fail on OAuth routes without real credentials, but app should initialize).
  </verify>
  <done>
    installation-store.ts implements Bolt InstallationStore interface with encrypted token storage.
    app.ts creates Bolt app with OAuth configuration and minimum required scopes.
    index.ts starts the app and logs startup message.
  </done>
</task>

</tasks>

<verification>
1. packages/database/src/encryption.ts exports encrypt and decrypt functions
2. Encryption round-trip test passes (encrypt then decrypt returns original)
3. apps/slack-backend/src/env.ts validates all required environment variables
4. Missing env var produces clear error message (not cryptic Zod error)
5. apps/slack-backend/src/oauth/installation-store.ts implements storeInstallation, fetchInstallation, deleteInstallation
6. Token encryption is applied before database insert
7. Token decryption is applied after database fetch
8. apps/slack-backend/src/app.ts creates Bolt app with installationStore
9. OAuth scopes are minimal: channels:history, channels:read, chat:write, users:read, app_mentions:read
10. App compiles and starts (may not complete OAuth without real credentials)
</verification>

<success_criteria>
- Encryption utilities work correctly (encrypt/decrypt round-trip)
- Environment validation catches missing variables with helpful messages
- Installation store encrypts tokens before storing, decrypts after fetching
- Bolt app initializes with OAuth configuration
- OAuth scopes follow least-privilege principle
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
