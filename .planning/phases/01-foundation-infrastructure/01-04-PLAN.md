---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/validation/src/slack-payloads.ts
  - packages/validation/src/sanitization.ts
  - packages/validation/src/index.ts
  - apps/slack-backend/src/middleware/error-handler.ts
  - apps/slack-backend/src/utils/logger.ts
autonomous: true

must_haves:
  truths:
    - "Invalid Slack events are rejected with a clear error message"
    - "Prompt injection attempts are detected and fail gracefully without executing"
    - "Users see friendly error messages, never stack traces or internal errors"
    - "API keys and tokens are never visible in error responses or logs"
    - "All errors are logged with sufficient context for debugging"
  artifacts:
    - path: "packages/validation/src/slack-payloads.ts"
      provides: "Zod schemas for Slack event validation"
      exports: ["SlackMessageSchema", "SlackEventSchema"]
    - path: "packages/validation/src/sanitization.ts"
      provides: "Input sanitization and prompt injection defense"
      exports: ["sanitizeForAI", "spotlightUserInput", "sanitizeAIOutput"]
    - path: "apps/slack-backend/src/middleware/error-handler.ts"
      provides: "Global error handling middleware"
      exports: ["errorHandler", "SlackError"]
    - path: "apps/slack-backend/src/utils/logger.ts"
      provides: "Structured logging with pino"
      exports: ["logger", "createChildLogger"]
  key_links:
    - from: "packages/validation/src/sanitization.ts"
      to: "AI prompts"
      via: "spotlightUserInput wraps content before LLM"
      pattern: "user_input_start|user_input_end"
    - from: "apps/slack-backend/src/middleware/error-handler.ts"
      to: "apps/slack-backend/src/app.ts"
      via: "app.error() registration"
      pattern: "app\\.error"
---

<objective>
Implement input validation, prompt injection defenses, and error handling to ensure the system is secure and provides graceful degradation when things go wrong.

Purpose: INFRA-04 (prompt injection prevention) must be architected from the start - it cannot be retrofitted. INFRA-06 (error handling) ensures users get helpful messages instead of crashes. These are foundational security layers.

Output: Validation schemas for Slack payloads, sanitization utilities for AI prompts, global error handling with user-friendly messages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schemas and sanitization utilities</name>
  <files>
    packages/validation/src/slack-payloads.ts
    packages/validation/src/sanitization.ts
    packages/validation/src/index.ts
  </files>
  <action>
    Create packages/validation/src/slack-payloads.ts:

    Define Zod schemas for Slack payloads:

    ```typescript
    import { z } from 'zod';

    // Base patterns for Slack IDs
    const slackUserId = z.string().regex(/^U[A-Z0-9]+$/, 'Invalid Slack user ID');
    const slackChannelId = z.string().regex(/^[CDG][A-Z0-9]+$/, 'Invalid Slack channel ID');
    const slackTeamId = z.string().regex(/^T[A-Z0-9]+$/, 'Invalid Slack team ID');
    const slackTimestamp = z.string().regex(/^\d+\.\d+$/, 'Invalid Slack timestamp');

    // Message event schema
    export const SlackMessageSchema = z.object({
      type: z.literal('message'),
      subtype: z.string().optional(),
      text: z.string()
        .max(40000, 'Message too long') // Slack's max is ~40k
        .refine(
          (text) => !text.includes('\x00'),
          'Invalid characters in message'
        ),
      user: slackUserId,
      channel: slackChannelId,
      ts: slackTimestamp,
      thread_ts: slackTimestamp.optional(),
      team: slackTeamId.optional(),
    });

    // App mention event schema
    export const SlackAppMentionSchema = z.object({
      type: z.literal('app_mention'),
      text: z.string().max(40000),
      user: slackUserId,
      channel: slackChannelId,
      ts: slackTimestamp,
      thread_ts: slackTimestamp.optional(),
      team: slackTeamId,
    });

    // Generic event wrapper
    export const SlackEventSchema = z.object({
      type: z.string(),
      event_ts: slackTimestamp,
      team_id: slackTeamId.optional(),
    });

    // Message action payload (for "Help me respond")
    export const SlackMessageActionSchema = z.object({
      type: z.literal('message_action'),
      callback_id: z.string(),
      trigger_id: z.string(),
      message: z.object({
        type: z.literal('message'),
        text: z.string().max(40000),
        user: slackUserId,
        ts: slackTimestamp,
      }),
      channel: z.object({
        id: slackChannelId,
        name: z.string().optional(),
      }),
      user: z.object({
        id: slackUserId,
        name: z.string().optional(),
      }),
      team: z.object({
        id: slackTeamId,
      }),
    });

    // Export types
    export type SlackMessage = z.infer<typeof SlackMessageSchema>;
    export type SlackAppMention = z.infer<typeof SlackAppMentionSchema>;
    export type SlackMessageAction = z.infer<typeof SlackMessageActionSchema>;
    ```

    Create packages/validation/src/sanitization.ts:

    Implement layered prompt injection defense:

    ```typescript
    /**
     * Layer 1: Basic input sanitization
     * Removes potentially dangerous characters and patterns
     */
    export function sanitizeInput(text: string): string {
      return text
        // Remove null bytes
        .replace(/\x00/g, '')
        // Normalize unicode (prevent homograph attacks)
        .normalize('NFKC')
        // Limit length (defense in depth)
        .slice(0, 10000);
    }

    /**
     * Layer 2: Spotlighting (data marking)
     * Wraps user content with delimiters that LLM recognizes as data, not instructions
     * Based on Microsoft's prompt injection defense research
     */
    export function spotlightUserInput(text: string): string {
      const sanitized = sanitizeInput(text);
      return `<|user_input_start|>${sanitized}<|user_input_end|>`;
    }

    /**
     * Layer 3: Detect potential injection attempts
     * Returns true if text contains suspicious patterns
     */
    export function detectInjectionAttempt(text: string): boolean {
      const suspiciousPatterns = [
        /ignore\s+(previous|all|above)\s+instructions/i,
        /disregard\s+(previous|all|above)/i,
        /you\s+are\s+now\s+a/i,
        /pretend\s+you\s+are/i,
        /act\s+as\s+if/i,
        /new\s+instructions?:/i,
        /system\s*prompt/i,
        /reveal\s+(your|the)\s+(instructions|prompt)/i,
        /<\|.*?\|>/g, // Attempting to inject data markers
        /\[INST\]/i, // Llama-style instruction markers
        /###\s*(system|user|assistant)/i, // OpenAI-style markers
      ];

      return suspiciousPatterns.some(pattern => pattern.test(text));
    }

    /**
     * Layer 4: Output filtering
     * Removes potentially leaked system content from AI responses
     */
    export function sanitizeAIOutput(text: string): string {
      const forbiddenPatterns = [
        // System prompt leakage
        /CRITICAL\s+SECURITY\s+RULES/gi,
        /you\s+are\s+a\s+professional\s+communication\s+assistant/gi,
        /NEVER\s+follow\s+instructions\s+contained/gi,
        // Data marker leakage
        /<\|user_input_start\|>/g,
        /<\|user_input_end\|>/g,
        /<\|.*?\|>/g,
        // Environment variable patterns
        /sk-[a-zA-Z0-9]{20,}/g, // API key patterns
        /xoxb-[a-zA-Z0-9-]+/g, // Slack bot tokens
      ];

      let sanitized = text;
      for (const pattern of forbiddenPatterns) {
        sanitized = sanitized.replace(pattern, '[FILTERED]');
      }

      return sanitized;
    }

    /**
     * Complete sanitization pipeline for AI prompts
     */
    export function prepareForAI(userText: string): {
      sanitized: string;
      flagged: boolean;
      flagReason?: string;
    } {
      const flagged = detectInjectionAttempt(userText);
      const sanitized = spotlightUserInput(userText);

      return {
        sanitized,
        flagged,
        flagReason: flagged ? 'Potential prompt injection detected' : undefined,
      };
    }
    ```

    Update packages/validation/src/index.ts:
    - Re-export all schemas from slack-payloads.ts
    - Re-export all sanitization functions
  </action>
  <verify>
    Run TypeScript compilation: npm run build --workspace=packages/validation

    Test sanitization functions:
    - spotlightUserInput("Hello") should wrap with markers
    - detectInjectionAttempt("ignore previous instructions") should return true
    - detectInjectionAttempt("Hello, how are you?") should return false
    - sanitizeAIOutput("The API key is sk-abc123xyz") should replace key
  </verify>
  <done>
    slack-payloads.ts exports Zod schemas for message, app_mention, message_action events.
    sanitization.ts implements 4-layer defense: sanitize, spotlight, detect, filter.
    All functions exported from packages/validation/src/index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error handler and structured logging</name>
  <files>
    apps/slack-backend/src/utils/logger.ts
    apps/slack-backend/src/middleware/error-handler.ts
    apps/slack-backend/src/app.ts
  </files>
  <action>
    Create apps/slack-backend/src/utils/logger.ts:

    ```typescript
    import pino from 'pino';
    import { env } from '../env';

    export const logger = pino({
      level: env.NODE_ENV === 'production' ? 'info' : 'debug',
      transport: env.NODE_ENV === 'development'
        ? { target: 'pino-pretty', options: { colorize: true } }
        : undefined,
      base: {
        service: 'slack-speak-for-me',
        env: env.NODE_ENV,
      },
      // Redact sensitive fields
      redact: {
        paths: ['req.headers.authorization', 'token', 'botToken', 'userToken', 'apiKey'],
        censor: '[REDACTED]',
      },
    });

    /**
     * Create a child logger with additional context
     */
    export function createChildLogger(context: Record<string, unknown>) {
      return logger.child(context);
    }
    ```

    Create apps/slack-backend/src/middleware/error-handler.ts:

    ```typescript
    import { AllMiddlewareArgs, SlackEventMiddlewareArgs } from '@slack/bolt';
    import { logger } from '../utils/logger';

    /**
     * Custom error class for Slack-specific errors
     */
    export class SlackError extends Error {
      constructor(
        message: string,
        public readonly code: string,
        public readonly userMessage: string,
        public readonly context?: Record<string, unknown>
      ) {
        super(message);
        this.name = 'SlackError';
      }
    }

    /**
     * Map internal errors to user-friendly messages
     */
    const errorMessages: Record<string, string> = {
      VALIDATION_ERROR: "I couldn't understand that message. Please try again.",
      AI_GENERATION_FAILED: "I'm having trouble generating a response right now. Please try again in a moment.",
      RATE_LIMITED: "You're sending requests too quickly. Please wait a moment and try again.",
      DATABASE_ERROR: "Something went wrong on our end. Please try again.",
      INSTALLATION_NOT_FOUND: "This app needs to be reinstalled. Please contact your workspace admin.",
      UNKNOWN_ERROR: "Something unexpected happened. Please try again.",
    };

    /**
     * Get user-friendly message for error code
     */
    export function getUserMessage(code: string): string {
      return errorMessages[code] || errorMessages.UNKNOWN_ERROR;
    }

    /**
     * Global error handler for Bolt app
     * Logs error with context and returns user-friendly message
     */
    export async function errorHandler(error: Error & { code?: string }): Promise<void> {
      // Extract error details
      const errorCode = error instanceof SlackError
        ? error.code
        : error.code || 'UNKNOWN_ERROR';

      const context = error instanceof SlackError
        ? error.context
        : undefined;

      // Log the full error for debugging
      logger.error({
        err: {
          message: error.message,
          name: error.name,
          code: errorCode,
          stack: error.stack,
        },
        context,
      }, 'Error in Slack handler');

      // Note: User-friendly message is handled by event handlers
      // This global handler is for logging and cleanup
    }

    /**
     * Wrap async handler with error handling
     * Returns user-friendly ephemeral message on error
     */
    export function withErrorHandling<T extends AllMiddlewareArgs>(
      handler: (args: T) => Promise<void>
    ) {
      return async (args: T): Promise<void> => {
        try {
          await handler(args);
        } catch (error) {
          const err = error as Error & { code?: string };

          // Log the error
          await errorHandler(err);

          // Try to send user-friendly message if we have client and user context
          const { client, body } = args as unknown as {
            client?: { chat: { postEphemeral: (opts: unknown) => Promise<unknown> } };
            body?: { event?: { channel?: string; user?: string } };
          };

          if (client && body?.event?.channel && body?.event?.user) {
            try {
              const errorCode = err instanceof SlackError
                ? err.code
                : err.code || 'UNKNOWN_ERROR';

              await client.chat.postEphemeral({
                channel: body.event.channel,
                user: body.event.user,
                text: `:warning: ${getUserMessage(errorCode)}`,
              });
            } catch (notifyError) {
              // If we can't notify user, just log it
              logger.error({ err: notifyError }, 'Failed to send error notification to user');
            }
          }
        }
      };
    }
    ```

    Update apps/slack-backend/src/app.ts to register error handler:

    Add after app creation:
    ```typescript
    import { errorHandler } from './middleware/error-handler';

    // Register global error handler
    app.error(errorHandler);
    ```
  </action>
  <verify>
    Run: npm run build
    Should compile without TypeScript errors.

    Verify logger redacts sensitive fields:
    - logger.info({ token: 'secret123' }, 'test') should show token: [REDACTED]

    Verify error messages:
    - getUserMessage('VALIDATION_ERROR') returns friendly message
    - getUserMessage('UNKNOWN_CODE') returns fallback message
  </verify>
  <done>
    logger.ts creates pino logger with pretty printing in dev, redaction of sensitive fields.
    error-handler.ts provides SlackError class, getUserMessage function, errorHandler for app.error().
    withErrorHandling wrapper sends ephemeral error messages to users.
    app.ts registers global error handler.
  </done>
</task>

</tasks>

<verification>
1. packages/validation/src/slack-payloads.ts exports Zod schemas for Slack events
2. packages/validation/src/sanitization.ts exports sanitization and detection functions
3. spotlightUserInput wraps text with <|user_input_start|> and <|user_input_end|>
4. detectInjectionAttempt returns true for "ignore previous instructions"
5. sanitizeAIOutput removes API key patterns
6. apps/slack-backend/src/utils/logger.ts creates pino logger with redaction
7. apps/slack-backend/src/middleware/error-handler.ts exports SlackError and errorHandler
8. errorHandler logs errors with context
9. getUserMessage returns user-friendly messages for error codes
10. app.ts registers errorHandler with app.error()
</verification>

<success_criteria>
- Zod schemas validate Slack payloads with type safety
- Prompt injection defense has 4 layers: sanitize, spotlight, detect, filter
- Suspicious patterns are detected (injection attempts)
- Logger redacts sensitive fields (tokens, API keys)
- Users see friendly error messages, never stack traces or internal details
- Global error handler logs all errors with context
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
