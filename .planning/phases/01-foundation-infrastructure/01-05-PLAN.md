---
phase: 01-foundation-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - apps/slack-backend/src/handlers/health.ts
  - apps/slack-backend/src/handlers/index.ts
  - apps/slack-backend/src/app.ts
  - apps/slack-backend/src/index.ts
autonomous: false

must_haves:
  truths:
    - "App starts without errors when all dependencies are available"
    - "Health endpoint returns status of all services"
    - "OAuth install flow redirects correctly"
    - "OAuth callback stores installation in database"
  artifacts:
    - path: "apps/slack-backend/src/handlers/health.ts"
      provides: "Health check endpoint"
      exports: ["registerHealthEndpoints"]
    - path: "apps/slack-backend/src/index.ts"
      provides: "Complete app startup with all components"
      min_lines: 30
  key_links:
    - from: "apps/slack-backend/src/index.ts"
      to: "all modules"
      via: "imports and initialization"
      pattern: "import.*from.*handlers|jobs|app"
---

<objective>
Wire all infrastructure components together, add health check endpoints, and verify the complete OAuth flow works end-to-end.

Purpose: This plan integrates all foundation components (database, OAuth, jobs, validation, error handling) into a running application and verifies the OAuth flow works with a real Slack workspace.

Output: Running application with health checks, ready for Phase 2 feature development.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health check endpoints and wire components</name>
  <files>
    apps/slack-backend/src/handlers/health.ts
    apps/slack-backend/src/handlers/index.ts
    apps/slack-backend/src/app.ts
    apps/slack-backend/src/index.ts
  </files>
  <action>
    Create apps/slack-backend/src/handlers/health.ts:

    ```typescript
    import { App } from '@slack/bolt';
    import { db } from '@slack-speak/database';
    import { redis } from '../jobs/connection';
    import { aiResponseQueue } from '../jobs/queues';
    import { logger } from '../utils/logger';
    import { sql } from 'drizzle-orm';

    interface HealthStatus {
      status: 'healthy' | 'degraded' | 'unhealthy';
      timestamp: string;
      services: {
        database: { status: 'up' | 'down'; latencyMs?: number };
        redis: { status: 'up' | 'down'; latencyMs?: number };
        queue: {
          status: 'up' | 'down';
          waiting?: number;
          active?: number;
          failed?: number;
        };
      };
      version: string;
    }

    async function checkDatabase(): Promise<{ status: 'up' | 'down'; latencyMs?: number }> {
      const start = Date.now();
      try {
        await db.execute(sql`SELECT 1`);
        return { status: 'up', latencyMs: Date.now() - start };
      } catch (error) {
        logger.error({ err: error }, 'Database health check failed');
        return { status: 'down' };
      }
    }

    async function checkRedis(): Promise<{ status: 'up' | 'down'; latencyMs?: number }> {
      const start = Date.now();
      try {
        await redis.ping();
        return { status: 'up', latencyMs: Date.now() - start };
      } catch (error) {
        logger.error({ err: error }, 'Redis health check failed');
        return { status: 'down' };
      }
    }

    async function checkQueue(): Promise<HealthStatus['services']['queue']> {
      try {
        const [waiting, active, failed] = await Promise.all([
          aiResponseQueue.getWaitingCount(),
          aiResponseQueue.getActiveCount(),
          aiResponseQueue.getFailedCount(),
        ]);
        return { status: 'up', waiting, active, failed };
      } catch (error) {
        logger.error({ err: error }, 'Queue health check failed');
        return { status: 'down' };
      }
    }

    export function registerHealthEndpoints(app: App) {
      // Receiver is the underlying HTTP server
      const receiver = app.receiver as { router?: { get: Function } };

      if (receiver.router) {
        // Liveness probe - basic check that app is running
        receiver.router.get('/health/live', (_req: unknown, res: { status: Function; json: Function }) => {
          res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
        });

        // Readiness probe - full check of all dependencies
        receiver.router.get('/health/ready', async (_req: unknown, res: { status: Function; json: Function }) => {
          const [database, redisStatus, queue] = await Promise.all([
            checkDatabase(),
            checkRedis(),
            checkQueue(),
          ]);

          const allUp = database.status === 'up' &&
                        redisStatus.status === 'up' &&
                        queue.status === 'up';

          const health: HealthStatus = {
            status: allUp ? 'healthy' : 'degraded',
            timestamp: new Date().toISOString(),
            services: { database, redis: redisStatus, queue },
            version: process.env.npm_package_version || '0.0.1',
          };

          res.status(allUp ? 200 : 503).json(health);
        });
      }
    }
    ```

    Create apps/slack-backend/src/handlers/index.ts:
    ```typescript
    export { registerHealthEndpoints } from './health';
    // Future handlers will be exported here
    ```

    Update apps/slack-backend/src/app.ts:
    - Import { registerHealthEndpoints } from './handlers'
    - Call registerHealthEndpoints(app) after app creation

    Update apps/slack-backend/src/index.ts to have complete startup:

    ```typescript
    import { app } from './app';
    import { env } from './env';
    import { startWorkers, stopWorkers } from './jobs';
    import { logger } from './utils/logger';

    async function main() {
      try {
        // Log startup configuration (without secrets)
        logger.info({
          port: env.PORT,
          nodeEnv: env.NODE_ENV,
          redisHost: env.REDIS_HOST,
        }, 'Starting Slack Speak for Me backend');

        // Start the Bolt app
        await app.start(env.PORT);
        logger.info({ port: env.PORT }, 'Bolt app started');

        // Start background workers
        await startWorkers();
        logger.info('Background workers started');

        // Log success
        logger.info({
          port: env.PORT,
          oauthUrl: `http://localhost:${env.PORT}/slack/install`,
        }, 'Slack Speak for Me is ready!');

      } catch (error) {
        logger.fatal({ err: error }, 'Failed to start application');
        process.exit(1);
      }
    }

    // Graceful shutdown
    async function shutdown(signal: string) {
      logger.info({ signal }, 'Received shutdown signal');

      try {
        await stopWorkers();
        logger.info('Workers stopped');

        await app.stop();
        logger.info('App stopped');

        process.exit(0);
      } catch (error) {
        logger.error({ err: error }, 'Error during shutdown');
        process.exit(1);
      }
    }

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));

    // Handle uncaught errors
    process.on('uncaughtException', (error) => {
      logger.fatal({ err: error }, 'Uncaught exception');
      process.exit(1);
    });

    process.on('unhandledRejection', (reason) => {
      logger.fatal({ err: reason }, 'Unhandled rejection');
      process.exit(1);
    });

    main();
    ```
  </action>
  <verify>
    Run: npm run build
    Should compile without errors.

    With DATABASE_URL and REDIS set up:
    Run: npm run dev --workspace=apps/slack-backend

    Test endpoints:
    - curl http://localhost:3000/health/live should return {"status":"ok"}
    - curl http://localhost:3000/health/ready should return full health status
  </verify>
  <done>
    health.ts provides /health/live and /health/ready endpoints.
    index.ts has complete startup with logging, workers, and graceful shutdown.
    Uncaught errors are logged and cause clean exit.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 infrastructure:
    - Monorepo with TypeScript and Drizzle ORM
    - PostgreSQL schema with RLS for multi-tenant isolation
    - OAuth installation store with AES-256-GCM encrypted tokens
    - BullMQ job queue with rate limiting
    - Input validation and prompt injection defense layers
    - Error handling with user-friendly messages
    - Health check endpoints
  </what-built>
  <how-to-verify>
    Prerequisites:
    1. PostgreSQL database running (local or cloud like Neon/Supabase)
    2. Redis running (local: `docker run -p 6379:6379 redis`)
    3. Slack app created at https://api.slack.com/apps

    Setup:
    1. Copy .env.example to .env
    2. Fill in DATABASE_URL (e.g., postgres://user:pass@localhost:5432/slack_speak)
    3. Fill in REDIS_HOST=localhost, REDIS_PORT=6379
    4. Fill in Slack credentials from your Slack app dashboard
    5. Generate ENCRYPTION_KEY: `openssl rand -hex 32`
    6. Generate SLACK_STATE_SECRET: `openssl rand -hex 32`
    7. Add ANTHROPIC_API_KEY (can use placeholder for now)

    Database setup:
    1. cd packages/database
    2. npx drizzle-kit push (applies schema to database)

    Start the app:
    1. npm run dev --workspace=apps/slack-backend

    Verify health endpoints:
    1. curl http://localhost:3000/health/live
       Expected: {"status":"ok","timestamp":"..."}

    2. curl http://localhost:3000/health/ready
       Expected: All services "up", status "healthy"

    Verify OAuth flow:
    1. In Slack app dashboard, set OAuth Redirect URL to:
       http://localhost:3000/slack/oauth_redirect (or use ngrok for external URL)

    2. Visit http://localhost:3000/slack/install
       Expected: Redirects to Slack OAuth consent page

    3. Approve the installation
       Expected: Redirects back to app, installation stored in database

    4. Check database:
       SELECT * FROM workspaces;
       SELECT * FROM installations;
       Expected: Records exist, bot_token is encrypted (long hex string with colons)

    5. Test token decryption works:
       The app should be able to use the stored token (will be verified in Phase 2)
  </how-to-verify>
  <resume-signal>
    Type "approved" if:
    - Health endpoints return expected responses
    - OAuth flow completes successfully
    - Installation is stored in database with encrypted token

    Or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
1. npm run build completes without errors
2. npm run dev starts the app (with valid .env)
3. /health/live returns {"status":"ok"}
4. /health/ready returns healthy status with all services up
5. Graceful shutdown works (Ctrl+C logs shutdown messages)
6. OAuth install URL redirects to Slack
7. OAuth callback stores encrypted installation in database
</verification>

<success_criteria>
Phase 1 Success Criteria (from ROADMAP.md):
1. [x] User can install app to Slack workspace via OAuth and tokens are securely stored
2. [x] System processes background jobs asynchronously without hitting Slack 3-second timeout
3. [x] Database enforces workspace-level isolation (multi-tenant data cannot leak between workspaces)
4. [x] System sanitizes inputs and prevents prompt injection attacks
5. [x] System handles errors gracefully with user-friendly messages instead of crashes

All infrastructure requirements complete:
- INFRA-01: Secure token storage (AES-256-GCM encryption)
- INFRA-02: Multi-tenant data isolation (PostgreSQL RLS)
- INFRA-03: Background job processing (BullMQ)
- INFRA-04: Input sanitization (Zod + spotlighting + detection)
- INFRA-05: Rate limiting per workspace (BullMQ limiter)
- INFRA-06: Error handling with graceful degradation
- SLACK-14: OAuth flow for Slack workspace installation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-05-SUMMARY.md`
</output>
