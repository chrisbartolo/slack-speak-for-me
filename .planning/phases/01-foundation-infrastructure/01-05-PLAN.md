---
phase: 01-foundation-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - apps/slack-backend/src/handlers/health.ts
  - apps/slack-backend/src/handlers/index.ts
  - apps/slack-backend/src/app.ts
  - apps/slack-backend/src/index.ts
autonomous: false

must_haves:
  truths:
    - "App starts without errors when all dependencies are available"
    - "Health endpoint returns status of all services"
    - "OAuth install flow redirects correctly"
    - "OAuth callback stores installation in database"
    - "OAuth uninstallation removes installation from database"
  artifacts:
    - path: "apps/slack-backend/src/handlers/health.ts"
      provides: "Health check endpoint"
      exports: ["registerHealthEndpoints"]
    - path: "apps/slack-backend/src/index.ts"
      provides: "Complete app startup with all components"
      min_lines: 30
  key_links:
    - from: "apps/slack-backend/src/app.ts"
      to: "apps/slack-backend/src/handlers/health.ts"
      via: "registerHealthEndpoints(app) call"
      pattern: "registerHealthEndpoints\\(app\\)"
    - from: "apps/slack-backend/src/index.ts"
      to: "apps/slack-backend/src/app.ts"
      via: "import { app } triggers side effects including health endpoint registration"
      pattern: "import.*app.*from"
---

<objective>
Wire all infrastructure components together, add health check endpoints, and verify the complete OAuth flow works end-to-end.

Purpose: This plan integrates all foundation components (database, OAuth, jobs, validation, error handling) into a running application and verifies the OAuth flow works with a real Slack workspace.

Output: Running application with health checks, ready for Phase 2 feature development.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health check endpoints and wire components</name>
  <files>
    apps/slack-backend/src/handlers/health.ts
    apps/slack-backend/src/handlers/index.ts
    apps/slack-backend/src/app.ts
    apps/slack-backend/src/index.ts
  </files>
  <action>
    Create apps/slack-backend/src/handlers/health.ts:

    ```typescript
    import { App } from '@slack/bolt';
    import { db } from '@slack-speak/database';
    import { redis } from '../jobs/connection';
    import { aiResponseQueue } from '../jobs/queues';
    import { logger } from '../utils/logger';
    import { sql } from 'drizzle-orm';

    interface HealthStatus {
      status: 'healthy' | 'degraded' | 'unhealthy';
      timestamp: string;
      services: {
        database: { status: 'up' | 'down'; latencyMs?: number };
        redis: { status: 'up' | 'down'; latencyMs?: number };
        queue: {
          status: 'up' | 'down';
          waiting?: number;
          active?: number;
          failed?: number;
        };
      };
      version: string;
    }

    async function checkDatabase(): Promise<{ status: 'up' | 'down'; latencyMs?: number }> {
      const start = Date.now();
      try {
        await db.execute(sql`SELECT 1`);
        return { status: 'up', latencyMs: Date.now() - start };
      } catch (error) {
        logger.error({ err: error }, 'Database health check failed');
        return { status: 'down' };
      }
    }

    async function checkRedis(): Promise<{ status: 'up' | 'down'; latencyMs?: number }> {
      const start = Date.now();
      try {
        await redis.ping();
        return { status: 'up', latencyMs: Date.now() - start };
      } catch (error) {
        logger.error({ err: error }, 'Redis health check failed');
        return { status: 'down' };
      }
    }

    async function checkQueue(): Promise<HealthStatus['services']['queue']> {
      try {
        const [waiting, active, failed] = await Promise.all([
          aiResponseQueue.getWaitingCount(),
          aiResponseQueue.getActiveCount(),
          aiResponseQueue.getFailedCount(),
        ]);
        return { status: 'up', waiting, active, failed };
      } catch (error) {
        logger.error({ err: error }, 'Queue health check failed');
        return { status: 'down' };
      }
    }

    export function registerHealthEndpoints(app: App) {
      // Receiver is the underlying HTTP server
      const receiver = app.receiver as { router?: { get: Function } };

      if (receiver.router) {
        // Liveness probe - basic check that app is running
        receiver.router.get('/health/live', (_req: unknown, res: { status: Function; json: Function }) => {
          res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
        });

        // Readiness probe - full check of all dependencies
        receiver.router.get('/health/ready', async (_req: unknown, res: { status: Function; json: Function }) => {
          const [database, redisStatus, queue] = await Promise.all([
            checkDatabase(),
            checkRedis(),
            checkQueue(),
          ]);

          const allUp = database.status === 'up' &&
                        redisStatus.status === 'up' &&
                        queue.status === 'up';

          const health: HealthStatus = {
            status: allUp ? 'healthy' : 'degraded',
            timestamp: new Date().toISOString(),
            services: { database, redis: redisStatus, queue },
            version: process.env.npm_package_version || '0.0.1',
          };

          res.status(allUp ? 200 : 503).json(health);
        });
      }
    }
    ```

    Create apps/slack-backend/src/handlers/index.ts:
    ```typescript
    export { registerHealthEndpoints } from './health';
    // Future handlers will be exported here
    ```

    **IMPORTANT: Update apps/slack-backend/src/app.ts to wire health endpoints:**

    This is the critical wiring step. After app creation, call registerHealthEndpoints:

    ```typescript
    import { App } from '@slack/bolt';
    import { env } from './env';
    import { installationStore } from './oauth/installation-store';
    import { errorHandler } from './middleware/error-handler';
    import { registerHealthEndpoints } from './handlers';

    export const app = new App({
      signingSecret: env.SLACK_SIGNING_SECRET,
      clientId: env.SLACK_CLIENT_ID,
      clientSecret: env.SLACK_CLIENT_SECRET,
      stateSecret: env.SLACK_STATE_SECRET,
      installationStore,
      scopes: [
        'channels:history',
        'channels:read',
        'chat:write',
        'users:read',
        'app_mentions:read',
      ],
      installerOptions: {
        directInstall: true,
      },
    });

    // Register global error handler
    app.error(errorHandler);

    // Register health endpoints - this wires /health/live and /health/ready
    registerHealthEndpoints(app);
    ```

    Update apps/slack-backend/src/index.ts to have complete startup:

    ```typescript
    import { app } from './app';  // Importing app triggers side effects: error handler + health endpoints
    import { env } from './env';
    import { startWorkers, stopWorkers } from './jobs';
    import { logger } from './utils/logger';

    async function main() {
      try {
        // Log startup configuration (without secrets)
        logger.info({
          port: env.PORT,
          nodeEnv: env.NODE_ENV,
          redisHost: env.REDIS_HOST,
        }, 'Starting Slack Speak for Me backend');

        // Start the Bolt app
        await app.start(env.PORT);
        logger.info({ port: env.PORT }, 'Bolt app started');

        // Start background workers
        await startWorkers();
        logger.info('Background workers started');

        // Log success
        logger.info({
          port: env.PORT,
          oauthUrl: `http://localhost:${env.PORT}/slack/install`,
        }, 'Slack Speak for Me is ready!');

      } catch (error) {
        logger.fatal({ err: error }, 'Failed to start application');
        process.exit(1);
      }
    }

    // Graceful shutdown
    async function shutdown(signal: string) {
      logger.info({ signal }, 'Received shutdown signal');

      try {
        await stopWorkers();
        logger.info('Workers stopped');

        await app.stop();
        logger.info('App stopped');

        process.exit(0);
      } catch (error) {
        logger.error({ err: error }, 'Error during shutdown');
        process.exit(1);
      }
    }

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));

    // Handle uncaught errors
    process.on('uncaughtException', (error) => {
      logger.fatal({ err: error }, 'Uncaught exception');
      process.exit(1);
    });

    process.on('unhandledRejection', (reason) => {
      logger.fatal({ err: reason }, 'Unhandled rejection');
      process.exit(1);
    });

    main();
    ```

    **Wiring verification:**
    - app.ts imports registerHealthEndpoints from './handlers'
    - app.ts calls registerHealthEndpoints(app) after app creation
    - index.ts imports app, which triggers the side effects in app.ts
    - Health endpoints are registered before app.start() is called
  </action>
  <verify>
    Run: npm run build
    Should compile without errors.

    With DATABASE_URL and REDIS set up:
    Run: npm run dev --workspace=apps/slack-backend

    Test endpoints:
    - curl http://localhost:3000/health/live should return {"status":"ok"}
    - curl http://localhost:3000/health/ready should return full health status

    Verify wiring:
    - grep for "registerHealthEndpoints(app)" in apps/slack-backend/src/app.ts
    - grep for "import.*registerHealthEndpoints.*from.*handlers" in apps/slack-backend/src/app.ts
  </verify>
  <done>
    health.ts provides /health/live and /health/ready endpoints.
    app.ts imports and calls registerHealthEndpoints(app) to wire health routes.
    index.ts has complete startup with logging, workers, and graceful shutdown.
    Uncaught errors are logged and cause clean exit.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 infrastructure:
    - Monorepo with TypeScript and Drizzle ORM
    - PostgreSQL schema with RLS for multi-tenant isolation
    - OAuth installation store with AES-256-GCM encrypted tokens
    - BullMQ job queue with rate limiting
    - Input validation and prompt injection defense layers
    - Error handling with user-friendly messages
    - Health check endpoints
  </what-built>
  <how-to-verify>
    Prerequisites:
    1. PostgreSQL database running (local or cloud like Neon/Supabase)
    2. Redis running (local: `docker run -p 6379:6379 redis`)
    3. Slack app created at https://api.slack.com/apps

    Setup:
    1. Copy .env.example to .env
    2. Fill in DATABASE_URL (e.g., postgres://user:pass@localhost:5432/slack_speak)
    3. Fill in REDIS_HOST=localhost, REDIS_PORT=6379
    4. Fill in Slack credentials from your Slack app dashboard
    5. Generate ENCRYPTION_KEY: `openssl rand -hex 32`
    6. Generate SLACK_STATE_SECRET: `openssl rand -hex 32`
    7. Add ANTHROPIC_API_KEY (can use placeholder for now)

    Database setup:
    1. cd packages/database
    2. npx drizzle-kit push (applies schema to database)

    Start the app:
    1. npm run dev --workspace=apps/slack-backend

    Verify health endpoints:
    1. curl http://localhost:3000/health/live
       Expected: {"status":"ok","timestamp":"..."}

    2. curl http://localhost:3000/health/ready
       Expected: All services "up", status "healthy"

    Verify OAuth install flow:
    1. In Slack app dashboard, set OAuth Redirect URL to:
       http://localhost:3000/slack/oauth_redirect (or use ngrok for external URL)

    2. Visit http://localhost:3000/slack/install
       Expected: Redirects to Slack OAuth consent page

    3. Approve the installation
       Expected: Redirects back to app, installation stored in database

    4. Check database:
       SELECT * FROM workspaces;
       SELECT * FROM installations;
       Expected: Records exist, bot_token is encrypted (long hex string with colons)

    5. Test token decryption works:
       The app should be able to use the stored token (will be verified in Phase 2)

    **Verify OAuth uninstallation (SLACK-14 complete coverage):**
    6. Test the deleteInstallation function works:
       - In Slack app dashboard, go to "Event Subscriptions"
       - Enable app_uninstalled event if not already enabled
       - OR manually test by calling the deleteInstallation function:
         ```typescript
         // From a test script or REPL:
         import { installationStore } from './oauth/installation-store';
         await installationStore.deleteInstallation({ teamId: 'YOUR_TEAM_ID' });
         ```
       - Check database: SELECT * FROM installations WHERE workspace_id = '...';
       - Expected: Record is deleted or marked inactive
       - App logs should show deletion audit trail
  </how-to-verify>
  <resume-signal>
    Type "approved" if:
    - Health endpoints return expected responses
    - OAuth flow completes successfully (install + uninstall)
    - Installation is stored in database with encrypted token
    - Uninstallation removes/deactivates installation record

    Or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
1. npm run build completes without errors
2. npm run dev starts the app (with valid .env)
3. /health/live returns {"status":"ok"}
4. /health/ready returns healthy status with all services up
5. Graceful shutdown works (Ctrl+C logs shutdown messages)
6. OAuth install URL redirects to Slack
7. OAuth callback stores encrypted installation in database
8. OAuth uninstallation removes installation from database (deleteInstallation works)
9. app.ts contains registerHealthEndpoints(app) call
</verification>

<success_criteria>
Phase 1 Success Criteria (from ROADMAP.md):
1. [x] User can install app to Slack workspace via OAuth and tokens are securely stored
2. [x] User can uninstall app and installation is properly removed (SLACK-14 complete)
3. [x] System processes background jobs asynchronously without hitting Slack 3-second timeout
4. [x] Database enforces workspace-level isolation (multi-tenant data cannot leak between workspaces)
5. [x] System sanitizes inputs and prevents prompt injection attacks
6. [x] System handles errors gracefully with user-friendly messages instead of crashes

All infrastructure requirements complete:
- INFRA-01: Secure token storage (AES-256-GCM encryption)
- INFRA-02: Multi-tenant data isolation (PostgreSQL RLS)
- INFRA-03: Background job processing (BullMQ)
- INFRA-04: Input sanitization (Zod + spotlighting + detection)
- INFRA-05: Rate limiting per workspace (BullMQ limiter)
- INFRA-06: Error handling with graceful degradation
- SLACK-14: OAuth flow for Slack workspace installation AND uninstallation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-05-SUMMARY.md`
</output>
