---
phase: 11.1-usage-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/schema.ts
  - apps/slack-backend/src/services/usage-enforcement.ts
  - apps/web-portal/lib/billing/plans.config.ts
  - apps/web-portal/lib/billing/usage-queries.ts
  - apps/web-portal/lib/db/index.ts
autonomous: true

must_haves:
  truths:
    - "Plans config is importable from both web-portal and slack-backend contexts"
    - "usageRecords table has stripeMeterId column for Stripe Billing Meters integration"
    - "usageEvents table has stripeReportedAt column to track what has been reported to Stripe"
    - "Usage queries can fetch current billing period usage by email"
  artifacts:
    - path: "apps/web-portal/lib/billing/plans.config.ts"
      provides: "Pricing plan definitions with usage limits and overage rates"
      contains: "USAGE_THRESHOLDS"
    - path: "apps/web-portal/lib/billing/usage-queries.ts"
      provides: "Server-side usage data fetching for dashboard and API"
      exports: ["getCurrentUsage", "getUsageHistory", "getOrgUsageSummary"]
    - path: "packages/database/src/schema.ts"
      provides: "Updated usage tables with Stripe meter tracking columns"
      contains: "stripeReportedAt"
  key_links:
    - from: "apps/web-portal/lib/billing/usage-queries.ts"
      to: "packages/database/src/schema.ts"
      via: "drizzle-orm queries on usageRecords and usageEvents"
      pattern: "usageRecords|usageEvents"
---

<objective>
Extend the existing pricing configuration and database schema to support full usage tracking with Stripe Billing Meters integration.

Purpose: The pricing config already exists in plans.config.ts with plan limits and overage rates. The schema has usageRecords and usageEvents tables. This plan adds: (1) a stripeReportedAt column to usageEvents so the batch reporter knows which events have been sent to Stripe, (2) a stripeMeterId column to usageRecords for linking to Stripe meters, (3) server-side usage query functions for the dashboard and admin pages, and (4) ensures the PLAN_LIMITS in usage-enforcement.ts stay consistent with plans.config.ts.

Output: Updated schema, usage query library, and consistent plan config across both apps.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.1-usage-tracking/11.1-RESEARCH.md
@packages/database/src/schema.ts
@apps/web-portal/lib/billing/plans.config.ts
@apps/slack-backend/src/services/usage-enforcement.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Stripe tracking columns to usage schema and create usage queries</name>
  <files>
    packages/database/src/schema.ts
    apps/web-portal/lib/billing/usage-queries.ts
  </files>
  <action>
    1. In `packages/database/src/schema.ts`, add to `usageEvents` table:
       - `stripeReportedAt: timestamp('stripe_reported_at')` - null means not yet reported to Stripe
       Add an index: `stripeReportedIdx: index('usage_events_stripe_reported_idx').on(table.stripeReportedAt)`

    2. In `packages/database/src/schema.ts`, add to `usageRecords` table:
       - `stripeMeterId: text('stripe_meter_id')` - the Stripe billing meter ID for this period
       - `planId: text('plan_id')` - the plan the user was on during this billing period (for historical reference)

    3. Create `apps/web-portal/lib/billing/usage-queries.ts` with 'server-only' import:
       - `getCurrentUsage(email: string)`: Returns current billing period usage record (suggestionsUsed, suggestionsIncluded, billingPeriodStart, billingPeriodEnd). Uses the existing unique index on (email, billingPeriodStart). Returns null if no record exists.
       - `getUsageHistory(email: string, months: number = 6)`: Returns array of past billing period records for charting. Query usageRecords where email matches, ordered by billingPeriodStart DESC, limited to `months` records.
       - `getOrgUsageSummary(organizationId: string)`: Returns aggregate usage across all org members for current billing period. Join usageRecords with users table via email, then join users with workspaces, filter by workspace.organizationId. Return totalUsers, totalSuggestions, averagePerUser, and top 10 users by suggestionsUsed.

    4. Export usageRecords and usageEvents from `apps/web-portal/lib/db/index.ts` if not already exported.
       - FIRST: Grep for 'usageRecords' and 'usageEvents' in `apps/web-portal/lib/db/index.ts` to check if exports already exist.
       - If exports are already present (both in import AND re-export sections), skip this step.
       - If missing, add them to both the import from '@slack-speak/database' and the export object.

    Use `import 'server-only'` at top of usage-queries.ts. Import db and schema from `@/lib/db`. Use drizzle-orm query builder (not raw SQL). For getCurrentUsage, compute billing period start as `new Date(now.getFullYear(), now.getMonth(), 1)`.
  </action>
  <verify>
    - Run `npx tsc --noEmit` in packages/database to confirm schema types compile
    - Run `npx tsc --noEmit` in apps/web-portal to confirm usage-queries types compile
    - Grep for `stripeReportedAt` in schema.ts to confirm column exists
    - Grep for `getCurrentUsage` in usage-queries.ts to confirm export exists
    - Grep for `usageRecords` in apps/web-portal/lib/db/index.ts to confirm exports exist (should appear in both import and export sections)
    - Grep for `usageEvents` in apps/web-portal/lib/db/index.ts to confirm exports exist (should appear in both import and export sections)
  </verify>
  <done>
    Schema has stripeReportedAt on usageEvents and stripeMeterId/planId on usageRecords. Usage query functions exist and compile. Queries use proper indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Align usage-enforcement.ts PLAN_LIMITS with plans.config.ts</name>
  <files>
    apps/slack-backend/src/services/usage-enforcement.ts
    apps/web-portal/lib/billing/plans.config.ts
  </files>
  <action>
    0. **Add FREE_PLAN to plans.config.ts** so that the 'free' plan ID exists in the canonical config (usage-enforcement.ts already references 'free' as default). In `apps/web-portal/lib/billing/plans.config.ts`:
       - Add a FREE_PLAN constant before INDIVIDUAL_PLANS:
         ```typescript
         export const FREE_PLAN: PlanConfig = {
           id: 'free',
           name: 'Free',
           description: 'Limited free tier for evaluation',
           type: 'individual',
           basePrice: 0,
           includedSuggestions: 5,
           overageRate: 0, // Hard cap, no overage allowed
           stripePriceId: '',
           stripeOveragePriceId: '',
           features: [
             'Up to 5 suggestions per month',
             'AI learns YOUR writing style',
             'Understands conversation context',
           ],
           cta: 'Get Started Free',
         };
         ```
       - Update ALL_PLANS to include FREE_PLAN: `export const ALL_PLANS = [FREE_PLAN, ...INDIVIDUAL_PLANS, ...TEAM_PLANS];`
       - This ensures getPlanById('free') works and the plan system has a complete source of truth.

    1. The PLAN_LIMITS in usage-enforcement.ts is manually duplicated from plans.config.ts. Update it to match the current plan IDs in plans.config.ts exactly:
       - `free`: 5 suggestions, 0 overage (hard cap)
       - `starter`: 25 suggestions, 35 overage
       - `pro`: 75 suggestions, 30 overage
       - `team`: 50 suggestions, 25 overage
       - `business`: 100 suggestions, 20 overage
       Remove `individual_starter`, `individual_pro`, `team_starter`, `team_pro` entries since the plan IDs in plans.config.ts are `free`, `starter`, `pro`, `team`, `business`.

    2. Fix the race condition in `recordUsageEvent()`. Currently it reads `record.suggestionsUsed` then writes `record.suggestionsUsed + 1` which is a read-modify-write race. Change to use atomic SQL increment:
       ```typescript
       await db
         .update(usageRecords)
         .set({
           suggestionsUsed: sql`${usageRecords.suggestionsUsed} + 1`,
           updatedAt: new Date(),
         })
         .where(eq(usageRecords.id, record.id));
       ```
       Import `sql` from 'drizzle-orm' (already imported).

    3. Add `USAGE_THRESHOLDS` constant matching the one in plans.config.ts:
       ```typescript
       const USAGE_THRESHOLDS = {
         WARNING: 0.8,
         CRITICAL: 0.95,
         HARD_CAP: 1.0,
       };
       ```

    4. Add a `warningLevel` field to the `UsageCheckResult` interface:
       ```typescript
       warningLevel?: 'safe' | 'warning' | 'critical' | 'exceeded';
       ```
       Compute it in `checkUsageAllowed()` based on percentUsed vs USAGE_THRESHOLDS. This will be used by downstream plans to show warnings in Slack ephemeral messages.

    5. Update `getUsageStatus()` return type to include `warningLevel` and `overageRate`:
       ```typescript
       warningLevel: 'safe' | 'warning' | 'critical' | 'exceeded';
       overageRate: number;
       ```
       Compute warningLevel from percentUsed. Get overageRate from PLAN_LIMITS.
  </action>
  <verify>
    - Run `npx tsc --noEmit` in apps/slack-backend to confirm types compile
    - Grep for `sql\`.*suggestionsUsed.*\+ 1\`` in usage-enforcement.ts to confirm atomic increment
    - Grep for `warningLevel` in usage-enforcement.ts to confirm new field exists
    - Verify PLAN_LIMITS keys match plans.config.ts plan IDs (free, starter, pro, team, business)
    - Grep for `FREE_PLAN` in plans.config.ts to confirm free plan definition exists
    - Grep for `getPlanById.*free` or `id: 'free'` in plans.config.ts to confirm 'free' is in ALL_PLANS
  </verify>
  <done>
    FREE_PLAN added to plans.config.ts with id='free', includedSuggestions=5, overageRate=0. PLAN_LIMITS aligned with plans.config.ts. Race condition fixed with atomic SQL increment. Warning levels computed from thresholds. getUsageStatus returns warningLevel and overageRate.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in packages/database, apps/slack-backend, and apps/web-portal
2. Schema has stripeReportedAt, stripeMeterId, and planId columns on usage tables
3. Usage queries file exports getCurrentUsage, getUsageHistory, getOrgUsageSummary
4. usage-enforcement.ts uses atomic SQL increment (no read-modify-write)
5. PLAN_LIMITS in usage-enforcement.ts matches plans.config.ts plan IDs
</verification>

<success_criteria>
- Database schema extended with Stripe tracking columns
- Usage query functions available for dashboard and admin pages
- Race condition in usage recording fixed
- Warning levels computed from configurable thresholds
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11.1-usage-tracking/11.1-01-SUMMARY.md`
</output>
