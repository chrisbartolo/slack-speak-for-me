---
phase: 11.1-usage-tracking
plan: 02
type: execute
wave: 2
depends_on: ["11.1-01"]
files_modified:
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/services/usage-enforcement.ts
  - apps/slack-backend/src/services/suggestion-delivery.ts
autonomous: true

must_haves:
  truths:
    - "Usage is checked before AI generation and blocks free-tier users at 100%"
    - "Usage event is recorded after successful AI generation with atomic increment"
    - "Slack ephemeral messages include usage count after suggestion delivery"
    - "Users at 80%+ usage see warning text in ephemeral suggestion messages"
    - "Paid-tier users can exceed limits (overage billing) but free-tier is hard capped"
  artifacts:
    - path: "apps/slack-backend/src/jobs/workers.ts"
      provides: "AI response worker with usage check gate and post-generation recording"
      contains: "checkUsageAllowed"
    - path: "apps/slack-backend/src/services/suggestion-delivery.ts"
      provides: "Ephemeral message delivery with usage status footer"
      contains: "warningLevel"
  key_links:
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/usage-enforcement.ts"
      via: "checkUsageAllowed() before generateSuggestion()"
      pattern: "checkUsageAllowed"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/usage-enforcement.ts"
      via: "recordUsageEvent() after successful generation"
      pattern: "recordUsageEvent"
---

<objective>
Wire usage checking and recording into the AI suggestion generation pipeline, and add usage status to Slack ephemeral messages.

Purpose: Usage enforcement logic exists in usage-enforcement.ts but is not yet called from the AI response worker. This plan: (1) adds a pre-generation usage check that blocks free-tier users at 100%, (2) records usage events after successful generation, (3) adds usage count and warning text to the ephemeral suggestion messages users see in Slack.

Output: Complete usage enforcement pipeline from check -> generate -> record -> display.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/11.1-usage-tracking/11.1-RESEARCH.md
@.planning/phases/11.1-usage-tracking/11.1-01-SUMMARY.md
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/services/usage-enforcement.ts
@apps/slack-backend/src/services/suggestion-delivery.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire usage check and recording into AI response worker</name>
  <files>
    apps/slack-backend/src/jobs/workers.ts
  </files>
  <action>
    In the `ai-responses` worker processor function in workers.ts:

    1. Import `checkUsageAllowed`, `recordUsageEvent`, `getUsageStatus` from `../services/index.js` (add to existing import if these are not yet exported from index.ts; if not, add the exports to `apps/slack-backend/src/services/index.ts`).

    2. BEFORE the `generateSuggestion()` call, add a usage check:
       ```typescript
       // Check usage limits before generating
       const usageCheck = await checkUsageAllowed({ workspaceId, userId });
       if (!usageCheck.allowed) {
         logger.info({
           jobId: job.id, workspaceId, userId,
           reason: usageCheck.reason,
           currentUsage: usageCheck.currentUsage,
           limit: usageCheck.limit,
         }, 'AI generation blocked by usage limit');

         // Send ephemeral message to user about limit
         // Fetch installation and send a "limit reached" message
         const [inst] = await db
           .select({ installation: installations, workspace: workspaces })
           .from(installations)
           .innerJoin(workspaces, eq(installations.workspaceId, workspaces.id))
           .where(eq(workspaces.id, workspaceId))
           .limit(1);

         if (inst) {
           const encKey = getEncryptionKey();
           const token = decrypt(inst.installation.botToken, encKey);
           const limitClient = new WebClient(token);
           await limitClient.chat.postEphemeral({
             channel: channelId,
             user: userId,
             text: `You've used all ${usageCheck.limit} AI suggestions for this month. Upgrade your plan for more. Your usage resets at the start of next month.`,
           });
         }

         return {
           suggestionId: `blocked_${Date.now()}`,
           suggestion: '',
           processingTimeMs: 0,
         };
       }
       ```

    3. AFTER the `generateSuggestion()` call succeeds (right after the `const result = await generateSuggestion(...)` line), add usage recording:
       ```typescript
       // Record usage event
       await recordUsageEvent({
         workspaceId,
         userId,
         eventType: 'suggestion',
         channelId,
       });
       ```

    4. After recording usage, get the updated usage status for display:
       ```typescript
       const usageStatus = await getUsageStatus({ workspaceId, userId });
       ```
       Pass this `usageStatus` to `sendSuggestionEphemeral` (will be consumed in Task 2).

    5. Update the `sendSuggestionEphemeral` call to include usage info:
       ```typescript
       await sendSuggestionEphemeral({
         client,
         channelId,
         userId,
         suggestionId,
         suggestion: result.suggestion,
         triggerContext: triggeredBy,
         usageInfo: {
           used: usageStatus.used,
           limit: usageStatus.limit,
           warningLevel: usageStatus.warningLevel,
           planId: usageStatus.planId,
         },
       });
       ```

    Ensure all usage operations are wrapped in try/catch and are non-fatal (logging errors but not throwing). The AI generation and delivery should not fail if usage tracking has issues (fail open for UX).
  </action>
  <verify>
    - Run `npx tsc --noEmit` in apps/slack-backend to confirm compilation
    - Grep for `checkUsageAllowed` in workers.ts to confirm it's called before generation
    - Grep for `recordUsageEvent` in workers.ts to confirm it's called after generation
    - Grep for `usageInfo` in workers.ts to confirm it's passed to delivery
  </verify>
  <done>
    Worker checks usage before generation, records after, and passes usage info to delivery. Free-tier users at 100% get blocked with an informative ephemeral message. Paid-tier users can exceed limits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add usage status footer to suggestion ephemeral messages</name>
  <files>
    apps/slack-backend/src/services/suggestion-delivery.ts
  </files>
  <action>
    1. Update the `sendSuggestionEphemeral` function signature to accept an optional `usageInfo` parameter:
       ```typescript
       interface UsageInfo {
         used: number;
         limit: number;
         warningLevel: 'safe' | 'warning' | 'critical' | 'exceeded';
         planId: string;
       }
       ```
       Add `usageInfo?: UsageInfo` to the function's options parameter.

    2. In the Block Kit message blocks array, add a `context` block at the end showing usage:
       - If `usageInfo` is provided, add:
         ```typescript
         // Usage context block
         if (usageInfo) {
           let usageText = `${usageInfo.used}/${usageInfo.limit} suggestions used this month`;

           if (usageInfo.warningLevel === 'warning') {
             usageText = `${usageInfo.used}/${usageInfo.limit} suggestions used this month (${Math.round((usageInfo.used / usageInfo.limit) * 100)}% used)`;
           } else if (usageInfo.warningLevel === 'critical') {
             const remaining = Math.max(0, usageInfo.limit - usageInfo.used);
             usageText = `Only ${remaining} suggestion${remaining !== 1 ? 's' : ''} remaining this month!`;
           } else if (usageInfo.warningLevel === 'exceeded') {
             usageText = `Over limit: ${usageInfo.used}/${usageInfo.limit} used (overage charges apply)`;
           }

           blocks.push({
             type: 'context',
             elements: [{
               type: 'mrkdwn',
               text: usageText,
             }],
           });
         }
         ```

    3. Keep the function backward-compatible: if `usageInfo` is not provided, no usage block is added. This ensures existing callers (tests, other contexts) continue to work.
  </action>
  <verify>
    - Run `npx tsc --noEmit` in apps/slack-backend to confirm compilation
    - Grep for `usageInfo` in suggestion-delivery.ts to confirm the parameter exists
    - Grep for `warningLevel` in suggestion-delivery.ts to confirm warning logic
    - Verify the function still works without usageInfo (optional parameter)
  </verify>
  <done>
    Ephemeral suggestion messages now include a usage footer showing "X/Y suggestions used this month". Warning/critical/exceeded states show progressively urgent messaging. Backward compatible with no usageInfo.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in apps/slack-backend
2. Usage is checked before AI generation in workers.ts
3. Usage event recorded after generation in workers.ts
4. Free-tier users at 100% receive "limit reached" ephemeral instead of suggestion
5. Suggestion ephemeral messages include usage count context block
6. Warning levels (80%, 95%, 100%) trigger appropriate messaging
</verification>

<success_criteria>
- AI generation pipeline enforces usage limits (free=hard cap, paid=allow overage)
- Every successful generation records a usage event
- Users see their usage count in every suggestion message
- Users at 80%+ see warning text, at 95% critical, over 100% overage notice
- All usage tracking is non-fatal (errors logged, not thrown)
</success_criteria>

<output>
After completion, create `.planning/phases/11.1-usage-tracking/11.1-02-SUMMARY.md`
</output>
