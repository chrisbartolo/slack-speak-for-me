---
phase: 11.1-usage-tracking
plan: 04
type: execute
wave: 2
depends_on: ["11.1-01"]
files_modified:
  - apps/slack-backend/src/services/stripe-meter-reporter.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/schedulers.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Billing Meter must be created in Stripe Dashboard for metered billing"
    env_vars:
      - name: STRIPE_METER_EVENT_NAME
        source: "After creating meter in Stripe Dashboard -> Billing -> Meters; default: 'ai_suggestion'"
    dashboard_config:
      - task: "Create a Billing Meter named 'AI Suggestions' with event name 'ai_suggestion', aggregation formula 'sum', payload key 'value'"
        location: "Stripe Dashboard -> More -> Billing -> Meters -> Create meter"
      - task: "Create metered prices linked to the meter for each plan's overage line item"
        location: "Stripe Dashboard -> Products -> Edit plan product -> Add metered price"

must_haves:
  truths:
    - "Usage events are reported to Stripe Billing Meters API with idempotency keys"
    - "Daily batch job finds unreported events and sends them to Stripe"
    - "Reported events are marked with stripeReportedAt timestamp to prevent re-reporting"
    - "Network failures during Stripe reporting are handled gracefully (retry next day)"
    - "Stripe meter event name is configurable via environment variable"
  artifacts:
    - path: "apps/slack-backend/src/services/stripe-meter-reporter.ts"
      provides: "Functions to report individual and batch usage events to Stripe Billing Meters"
      exports: ["reportUsageToStripe", "reportUnreportedUsageBatch"]
    - path: "apps/slack-backend/src/jobs/workers.ts"
      provides: "Daily usage reporter worker"
      contains: "usage-reporter"
    - path: "apps/slack-backend/src/jobs/schedulers.ts"
      provides: "Cron schedule for daily usage reporting"
      contains: "usage-reporter"
  key_links:
    - from: "apps/slack-backend/src/services/stripe-meter-reporter.ts"
      to: "Stripe API"
      via: "stripe.billing.meterEvents.create()"
      pattern: "meterEvents.create"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/stripe-meter-reporter.ts"
      via: "reportUnreportedUsageBatch() in daily worker"
      pattern: "reportUnreportedUsageBatch"
---

<objective>
Integrate with Stripe's Billing Meters API to report AI suggestion usage for automated overage billing.

Purpose: The app tracks usage locally but doesn't yet report to Stripe for metered billing. This plan creates a Stripe meter event reporter service and a daily BullMQ background job that finds unreported usage events and sends them to Stripe. This enables automatic overage billing on paid plans. Uses idempotency keys to prevent duplicate charges on retries.

Output: Stripe meter reporter service and daily batch reporting job.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/11.1-usage-tracking/11.1-RESEARCH.md
@.planning/phases/11.1-usage-tracking/11.1-01-SUMMARY.md
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/types.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/schedulers.ts
@apps/slack-backend/src/services/usage-enforcement.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe meter reporter service</name>
  <files>
    apps/slack-backend/src/services/stripe-meter-reporter.ts
    apps/slack-backend/src/services/index.ts
  </files>
  <action>
    1. Create `apps/slack-backend/src/services/stripe-meter-reporter.ts`:

       - Import Stripe from 'stripe'. Create a lazy-initialized Stripe client using `process.env.STRIPE_SECRET_KEY`. If not set, log warning and skip reporting (non-fatal).

       - Define `METER_EVENT_NAME` from `process.env.STRIPE_METER_EVENT_NAME || 'ai_suggestion'`.

       - Function `reportUsageToStripe(params)`:
         ```typescript
         interface StripeUsageReport {
           stripeCustomerId: string;
           eventId: string; // usageEvents.id for idempotency
           workspaceId: string;
           userId: string;
           value?: number; // defaults to 1
         }
         ```
         - Creates idempotency identifier: `${workspaceId}-${userId}-${eventId}`
         - Calls `stripe.billing.meterEvents.create({ event_name: METER_EVENT_NAME, payload: { stripe_customer_id, value }, identifier })`
         - Returns true on success, false on failure
         - Catches errors and logs them (non-fatal)
         - Handle Stripe error code `resource_already_exists` gracefully (idempotent = success)

       - Function `reportUnreportedUsageBatch()`:
         - Queries usageEvents where `stripeReportedAt IS NULL` and `createdAt > (now - 35 days)` (Stripe's max lookback)
         - Groups by email to look up Stripe customer IDs
         - For each unreported event:
           a. Look up the user's Stripe customer ID from userSubscriptions table (by email) or organizations table (by organizationId)
           b. If no Stripe customer found, skip (user may be on free tier)
           c. Call `reportUsageToStripe()` with the customer ID and event details
           d. On success: update usageEvents set `stripeReportedAt = new Date()` where id = event.id
         - Limit to 500 events per batch to avoid long-running transactions
         - Log summary: `{ total, reported, skipped, failed }`
         - Return the summary object

       - Import db, usageEvents, userSubscriptions, organizations from '@slack-speak/database'
       - Import { eq, and, isNull, sql, gt } from 'drizzle-orm'

    2. Export `reportUsageToStripe` and `reportUnreportedUsageBatch` from `apps/slack-backend/src/services/index.ts`.
  </action>
  <verify>
    - Run `npx tsc --noEmit` in apps/slack-backend to confirm compilation
    - Grep for `meterEvents.create` in stripe-meter-reporter.ts to confirm Stripe API call
    - Grep for `stripeReportedAt` in stripe-meter-reporter.ts to confirm marking as reported
    - Grep for `identifier` in stripe-meter-reporter.ts to confirm idempotency keys
  </verify>
  <done>
    Stripe meter reporter service exists with reportUsageToStripe() for individual events and reportUnreportedUsageBatch() for daily batch. Uses idempotency keys to prevent duplicate billing. Gracefully handles missing Stripe config and network errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create daily usage reporting BullMQ job</name>
  <files>
    apps/slack-backend/src/jobs/types.ts
    apps/slack-backend/src/jobs/queues.ts
    apps/slack-backend/src/jobs/workers.ts
    apps/slack-backend/src/jobs/schedulers.ts
  </files>
  <action>
    1. In `apps/slack-backend/src/jobs/types.ts`:
       - Add job data type:
         ```typescript
         export interface UsageReporterJobData {
           triggeredBy: 'schedule' | 'manual';
         }
         export interface UsageReporterJobResult {
           total: number;
           reported: number;
           skipped: number;
           failed: number;
         }
         ```

    2. In `apps/slack-backend/src/jobs/queues.ts`:
       - Add usage reporter queue:
         ```typescript
         export const usageReporterQueue = new Queue<UsageReporterJobData>('usage-reporter', {
           connection: redis,
           defaultJobOptions: {
             attempts: 3,
             backoff: { type: 'exponential', delay: 60000 }, // 1 min, 2 min, 4 min
             removeOnComplete: { count: 100 },
             removeOnFail: { count: 50 },
           },
         });
         ```
       - Import UsageReporterJobData from './types.js'

    3. In `apps/slack-backend/src/jobs/workers.ts`:
       - Add a new usage reporter worker after the existing report worker:
         ```typescript
         let usageReporterWorker: Worker<UsageReporterJobData, UsageReporterJobResult> | null = null;
         ```
       - In `startWorkers()`, create the worker:
         ```typescript
         usageReporterWorker = new Worker<UsageReporterJobData, UsageReporterJobResult>(
           'usage-reporter',
           async (job) => {
             logger.info({ jobId: job.id, triggeredBy: job.data.triggeredBy }, 'Processing usage reporter job');
             const result = await reportUnreportedUsageBatch();
             logger.info({ jobId: job.id, ...result }, 'Usage reporting completed');
             return result;
           },
           {
             connection: redis,
             concurrency: 1, // Only one batch at a time
           }
         );
         usageReporterWorker.on('error', (err) => logger.error({ err }, 'Usage reporter worker error'));
         usageReporterWorker.on('failed', (job, err) => logger.error({ jobId: job?.id, err: err.message }, 'Usage reporter job failed'));
         usageReporterWorker.on('completed', (job, result) => logger.info({ jobId: job.id, ...result }, 'Usage reporter job completed'));
         logger.info('Usage reporter worker started');
         ```
       - In `stopWorkers()`, add cleanup for usageReporterWorker.
       - Import `reportUnreportedUsageBatch` from `../services/index.js`
       - Import `UsageReporterJobData`, `UsageReporterJobResult` from `./types.js`

    4. In `apps/slack-backend/src/jobs/schedulers.ts`:
       - Follow the existing pattern (look at how report schedulers work)
       - Add a cron-based job scheduler for daily usage reporting at 2:00 AM UTC:
         ```typescript
         // Usage reporter scheduler - daily at 2 AM UTC
         const usageReporterScheduler = new Queue('usage-reporter', { connection: redis });
         await usageReporterScheduler.upsertJobScheduler(
           'daily-usage-report',
           { pattern: '0 2 * * *' }, // 2:00 AM UTC daily
           {
             name: 'daily-usage-report',
             data: { triggeredBy: 'schedule' },
           }
         );
         logger.info('Usage reporter scheduler configured (daily 2 AM UTC)');
         ```
       - Integrate into the existing scheduler setup function (follow the pattern in the file).
  </action>
  <verify>
    - Run `npx tsc --noEmit` in apps/slack-backend to confirm compilation
    - Grep for `usage-reporter` in workers.ts to confirm worker exists
    - Grep for `usage-reporter` in schedulers.ts to confirm scheduler exists
    - Grep for `UsageReporterJobData` in types.ts to confirm type defined
    - Grep for `usageReporterQueue` in queues.ts to confirm queue exists
  </verify>
  <done>
    Daily BullMQ job reports unreported usage events to Stripe at 2 AM UTC. Worker processes batch with exponential backoff retries. Job scheduler configured with cron pattern. Worker cleanup in stopWorkers().
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in apps/slack-backend
2. Stripe meter reporter service creates meter events with idempotency keys
3. Daily batch job finds and reports unreported events
4. Reported events marked with stripeReportedAt timestamp
5. Job scheduler configured for 2 AM UTC daily
6. Worker starts and stops cleanly with existing infrastructure
</verification>

<success_criteria>
- Stripe Billing Meters API called with correct event format and idempotency
- Daily background job reports all unreported events from past 35 days
- Successfully reported events never re-reported (stripeReportedAt tracking)
- Graceful handling of missing Stripe config (logs warning, doesn't crash)
- Network failures logged and retried next day via exponential backoff
</success_criteria>

<output>
After completion, create `.planning/phases/11.1-usage-tracking/11.1-04-SUMMARY.md`
</output>
