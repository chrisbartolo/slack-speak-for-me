# Phase 11.1: Usage Tracking & Enforcement - Research

**Researched:** 2026-02-03
**Domain:** Usage-Based Pricing, Stripe Metered Billing, Usage Enforcement, Dashboard UX
**Confidence:** HIGH

## Summary

This phase implements configurable usage-based pricing with per-user tracking, enforcement, and metered overage billing. The architecture already has foundational pieces in place: usage tracking tables (`usageRecords`, `usageEvents`), basic enforcement logic in `usage-enforcement.ts`, and a pricing config file. The key work involves:

1. **Migrating to Stripe Billing Meters** (2026 requirement) - Stripe deprecated legacy usage records API in v2025-03-31.basil; must use new `/v1/billing/meter_events` API
2. **Building user-facing usage dashboard** with real-time consumption visibility and alerts
3. **Implementing soft/hard limits** with configurable thresholds (80% warning, 100% hard cap for free tier)
4. **Automating overage reporting** to Stripe for metered billing on paid plans
5. **Admin analytics** for organization-wide usage insights

The pricing model is already defined in `plans.config.ts` with included suggestions (25-100 per plan) and overage rates ($0.20-$0.35 per extra suggestion). Database schema exists with `usageRecords` for billing period aggregates and `usageEvents` for granular tracking. Current implementation enforces limits in `checkUsageAllowed()` but lacks user visibility, warning notifications, and automated Stripe reporting.

**Primary recommendation:** Build on existing infrastructure with new Stripe Billing Meters API, add React usage dashboard using shadcn/ui components, implement tiered warning system (80%/100%), and create background job for daily overage reporting to Stripe.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| stripe | 20.3.0 | Metered billing via Billing Meters API | Already integrated for subscriptions; new meter events endpoint |
| drizzle-orm | 0.38+ | Usage tracking queries and aggregation | Already used; efficient PostgreSQL queries for billing periods |
| @radix-ui/react-progress | Latest | Usage meter visualization | Already installed via shadcn/ui; accessible progress bars |
| recharts | 2.15+ | Usage trend charts (optional) | Popular React charting library; good for usage over time |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| ioredis | 5.4+ | Distributed usage counter caching | Already installed via BullMQ; optional performance optimization |
| zod | 3.22+ | Validate usage reporting payloads | Already used; runtime safety for Stripe events |
| sonner | Latest | Toast notifications for usage warnings | Already installed; lightweight in-app alerts |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Stripe Billing Meters | Legacy usage records API | Deprecated in 2026; must migrate to meters |
| PostgreSQL aggregation | Redis counters only | PostgreSQL provides durable billing records; Redis is optional cache |
| Server-side dashboard | Real-time WebSocket updates | Polling sufficient; simpler architecture for monthly limits |
| Daily Stripe reporting | Real-time per-event reporting | Daily batch reduces API calls; usage reported within 24hrs is acceptable |

**Installation:**
```bash
# No new dependencies required - using existing stack
# Optional: Add recharts for advanced analytics
npm install recharts --workspace=@slack-speak-for-me/web-portal
```

## Architecture Patterns

### Recommended Project Structure
```
packages/database/src/
â”œâ”€â”€ schema.ts                    # Already has usageRecords + usageEvents tables
â””â”€â”€ queries/
    â””â”€â”€ usage.ts                 # New: Optimized usage aggregation queries

apps/slack-backend/src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ usage-enforcement.ts     # Already exists; extend with warning thresholds
â”‚   â””â”€â”€ stripe-meter-reporter.ts # New: Report usage to Stripe Billing Meters
â””â”€â”€ jobs/
    â””â”€â”€ usage-reporter.ts        # New: Daily job to report overages to Stripe

apps/web-portal/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â””â”€â”€ usage/page.tsx       # New: User usage dashboard
â”‚   â””â”€â”€ admin/
â”‚       â””â”€â”€ usage/page.tsx       # New: Admin analytics dashboard
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ usage/
â”‚   â”‚   â”œâ”€â”€ usage-meter.tsx      # New: Progress bar with % used
â”‚   â”‚   â”œâ”€â”€ usage-alert.tsx      # New: Warning at 80%, critical at 100%
â”‚   â”‚   â””â”€â”€ usage-history.tsx    # New: Chart of usage over time
â”‚   â””â”€â”€ admin/
â”‚       â””â”€â”€ usage-analytics.tsx  # New: Org-wide usage table
â””â”€â”€ lib/
    â”œâ”€â”€ billing/
    â”‚   â””â”€â”€ usage-queries.ts     # New: Fetch usage data for display
    â””â”€â”€ api/
        â””â”€â”€ usage/route.ts       # New: API endpoint for usage data
```

### Pattern 1: Stripe Billing Meters Integration
**What:** Report usage events to Stripe's new Billing Meters API for automated invoicing
**When to use:** After each AI suggestion generation (refinements count as separate events)
**Example:**
```typescript
// Source: https://docs.stripe.com/billing/subscriptions/usage-based/implementation-guide
import Stripe from 'stripe';

interface MeterEventPayload {
  event_name: string; // Meter identifier (e.g., 'ai_suggestion')
  stripe_customer_id: string;
  value: number; // Always whole number
  timestamp?: number; // Optional; defaults to current time
  identifier?: string; // Idempotency key
}

async function reportUsageToStripe(event: MeterEventPayload): Promise<void> {
  // POST /v1/billing/meter_events
  await stripe.billing.meterEvents.create({
    event_name: 'ai_suggestion', // Configured meter name
    payload: {
      stripe_customer_id: event.stripe_customer_id,
      value: event.value, // 1 per suggestion
    },
    timestamp: event.timestamp, // Must be within last 35 days
    identifier: event.identifier, // Prevents duplicate billing
  });
}

// Rate limit: 1,000 calls/second (sufficient for batch reporting)
// For >10k/sec, use /v2/billing/meter_event_stream
```

### Pattern 2: Tiered Usage Warnings
**What:** Progressive user notifications as usage approaches limits
**When to use:** Check after each AI generation; display in dashboard
**Example:**
```typescript
// Source: https://userpilot.com/blog/notification-types/
interface UsageStatus {
  used: number;
  limit: number;
  percentUsed: number;
  warningLevel: 'safe' | 'warning' | 'critical' | 'exceeded';
}

function getUsageStatus(used: number, limit: number): UsageStatus {
  const percentUsed = (used / limit) * 100;

  let warningLevel: UsageStatus['warningLevel'];
  if (percentUsed < 80) {
    warningLevel = 'safe'; // Green
  } else if (percentUsed < 95) {
    warningLevel = 'warning'; // Yellow - "You've used 85% of your monthly suggestions"
  } else if (percentUsed < 100) {
    warningLevel = 'critical'; // Orange - "Only 3 suggestions remaining this month"
  } else {
    warningLevel = 'exceeded'; // Red - "Limit reached. Upgrade or wait until next cycle."
  }

  return { used, limit, percentUsed, warningLevel };
}

// Display in ephemeral Slack message after suggestion generation:
// âœ… Suggestion generated (47/75 used this month)
// âš ï¸ Suggestion generated (62/75 used - 83% used)
// ðŸš¨ Suggestion generated (74/75 used - only 1 remaining!)
```

### Pattern 3: Billing Period Aggregation
**What:** Efficient PostgreSQL query for current billing period usage
**When to use:** Dashboard display, access checks, admin reports
**Example:**
```typescript
// Source: Existing usage-enforcement.ts + PostgreSQL best practices
import { db, usageRecords } from '@slack-speak/database';
import { eq, and } from 'drizzle-orm';

interface BillingPeriod {
  start: Date;
  end: Date;
}

function getCurrentBillingPeriod(): BillingPeriod {
  const now = new Date();
  // Calendar month boundaries
  const start = new Date(now.getFullYear(), now.getMonth(), 1);
  const end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
  return { start, end };
}

async function getCurrentUsage(email: string): Promise<UsageRecord | null> {
  const { start } = getCurrentBillingPeriod();

  // Single index-backed query (email + billingPeriodStart are indexed)
  const [record] = await db
    .select()
    .from(usageRecords)
    .where(
      and(
        eq(usageRecords.email, email),
        eq(usageRecords.billingPeriodStart, start)
      )
    )
    .limit(1);

  return record || null;
}

// Optimized: Uses unique index on (email, billing_period_start)
// No full table scans; sub-millisecond lookups
```

### Pattern 4: Usage Dashboard Component
**What:** React component with progress bar, stats, and upgrade CTA
**When to use:** Main dashboard, settings page
**Example:**
```typescript
// Source: https://mui.com/store/collections/free-react-dashboard/
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { Zap, TrendingUp } from 'lucide-react';

interface UsageMeterProps {
  used: number;
  limit: number;
  planId: string;
  overageRate: number; // Cents per suggestion
  billingPeriodEnd: Date;
}

export function UsageMeter({ used, limit, planId, overageRate, billingPeriodEnd }: UsageMeterProps) {
  const percentUsed = Math.min((used / limit) * 100, 100);
  const isOverage = used > limit;
  const overageCount = Math.max(0, used - limit);
  const overageCost = overageCount * overageRate / 100; // Dollars

  const daysRemaining = Math.ceil((billingPeriodEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Zap className="w-5 h-5 text-indigo-500" />
          <span className="font-semibold">AI Suggestions</span>
        </div>
        <span className="text-sm text-gray-500">
          {used} / {limit} used
        </span>
      </div>

      <Progress
        value={percentUsed}
        className={percentUsed >= 95 ? 'bg-red-200' : percentUsed >= 80 ? 'bg-yellow-200' : ''}
      />

      {isOverage && (
        <Alert variant="warning">
          <AlertDescription>
            You've used {overageCount} suggestions over your limit.
            Overage: ${overageCost.toFixed(2)} (billed at ${(overageRate/100).toFixed(2)}/suggestion)
          </AlertDescription>
        </Alert>
      )}

      {percentUsed >= 80 && !isOverage && (
        <Alert>
          <AlertDescription>
            You've used {percentUsed.toFixed(0)}% of your monthly suggestions.
            Resets in {daysRemaining} days.
          </AlertDescription>
        </Alert>
      )}

      {planId === 'free' && percentUsed >= 95 && (
        <Button className="w-full" variant="default">
          <TrendingUp className="w-4 h-4 mr-2" />
          Upgrade for More Suggestions
        </Button>
      )}
    </div>
  );
}
```

### Anti-Patterns to Avoid
- **Real-time Stripe reporting per event:** Batching reduces API calls and avoids rate limits
- **Client-side usage calculation:** Must be server-authoritative to prevent manipulation
- **Blocking AI generation for overage on paid plans:** Allow overage (metered billing will charge); only block free tier
- **Caching usage counts in memory:** Multi-instance app needs shared state (PostgreSQL or Redis)
- **Checking usage after generation:** Must check before to prevent exceeding limits

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Usage metering | Custom token tracking | Stripe Billing Meters | Handles billing cycles, prorations, invoicing automatically |
| Rate limiting distributed counters | In-memory counters | Redis sorted sets or PostgreSQL with proper indexes | Multi-instance consistency; atomic operations |
| Progress bar components | Custom CSS animations | Radix UI Progress (shadcn/ui) | Accessible, tested, customizable |
| Chart rendering | Canvas manipulation | Recharts or similar React library | Responsive, interactive, maintained |
| Idempotency keys | UUID generation | Stripe's automatic identifiers | Built-in deduplication for retry safety |

**Key insight:** Stripe's Billing Meters API handles the complex billing logic (prorations, billing cycles, invoice generation, payment processing). Your app only needs to report "1 suggestion used by customer X" and Stripe does the rest. Don't reimplement billing logic.

## Common Pitfalls

### Pitfall 1: Using Deprecated Stripe APIs
**What goes wrong:** App breaks when Stripe removes legacy usage records API (v2025-03-31.basil)
**Why it happens:** Existing tutorials show old `subscription_items.usage_records` pattern
**How to avoid:** Use `/v1/billing/meter_events` endpoint, not subscription items
**Warning signs:**
- Code references `stripe.subscriptionItems.createUsageRecord()`
- No meter created in Stripe Dashboard
- API version < 2025-03-31.basil

**Correct approach:**
```typescript
// âŒ Old (deprecated 2026)
await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
  quantity: 1,
  timestamp: Date.now() / 1000,
});

// âœ… New (2026+)
await stripe.billing.meterEvents.create({
  event_name: 'ai_suggestion',
  payload: { stripe_customer_id: customerId, value: 1 },
});
```

### Pitfall 2: Timestamp Validation Errors
**What goes wrong:** Stripe rejects usage events with "timestamp too far in past/future" errors
**Why it happens:** Server clock drift, incorrect timezone handling, old events in backfill
**How to avoid:**
- Use current timestamp (Stripe defaults to `now()` if omitted)
- For historical events: must be within 35 calendar days
- Never send timestamps >5 minutes in future
**Warning signs:**
- `meter_event_timestamp_in_future` errors
- `timestamp_too_far_in_past` errors

**Correct approach:**
```typescript
// âœ… Let Stripe use current time (recommended)
await stripe.billing.meterEvents.create({
  event_name: 'ai_suggestion',
  payload: { stripe_customer_id: customerId, value: 1 },
  // No timestamp = now()
});

// âœ… Only specify timestamp for backfill scenarios
const eventTime = Math.floor(Date.now() / 1000);
const maxAge = 35 * 24 * 60 * 60; // 35 days
if (Date.now() / 1000 - eventTime < maxAge) {
  await stripe.billing.meterEvents.create({
    event_name: 'ai_suggestion',
    payload: { stripe_customer_id: customerId, value: 1 },
    timestamp: eventTime,
  });
}
```

### Pitfall 3: Race Conditions in Usage Counting
**What goes wrong:** Two concurrent requests increment counter, one overwrites the other
**Why it happens:** Read-modify-write pattern without atomic operations
**How to avoid:** Use PostgreSQL `UPDATE ... SET count = count + 1` or Redis `INCR`
**Warning signs:**
- Usage count lower than actual events in `usageEvents` table
- Duplicate events not prevented
- No database transaction wrapping read+write

**Correct approach:**
```typescript
// âŒ Race condition
const record = await db.select().from(usageRecords).where(...);
const newCount = record.suggestionsUsed + 1;
await db.update(usageRecords).set({ suggestionsUsed: newCount });

// âœ… Atomic increment
await db
  .update(usageRecords)
  .set({
    suggestionsUsed: sql`${usageRecords.suggestionsUsed} + 1`,
    updatedAt: new Date()
  })
  .where(eq(usageRecords.id, recordId));
```

### Pitfall 4: Missing Idempotency Keys
**What goes wrong:** Network retry causes duplicate billing (user charged twice)
**Why it happens:** HTTP request times out, client retries, both succeed
**How to avoid:** Always pass `identifier` field to Stripe meter events
**Warning signs:**
- Same usage event appears twice in Stripe Dashboard
- Customer complaints about overcharges
- No deduplication logic

**Correct approach:**
```typescript
// âœ… Use deterministic identifier for idempotency
const identifier = `${workspaceId}-${userId}-${suggestionId}-${timestamp}`;

await stripe.billing.meterEvents.create({
  event_name: 'ai_suggestion',
  payload: { stripe_customer_id: customerId, value: 1 },
  identifier, // Stripe deduplicates based on this
});

// Stripe guarantees: same identifier = no duplicate charge
```

### Pitfall 5: Displaying Stale Usage Data
**What goes wrong:** Dashboard shows "45/75 used" but user just generated #46
**Why it happens:** Async processing, caching, eventual consistency
**How to avoid:**
- Stripe processes meter events asynchronously; delays expected
- Show "Usage updates within 1 hour" disclaimer
- Optimistically increment UI counter locally
**Warning signs:**
- User generates suggestion, dashboard unchanged
- "Invoice preview" shows different usage than dashboard
- No loading/refresh mechanism

**Correct approach:**
```typescript
// âœ… Optimistic UI update + background refresh
async function generateSuggestion() {
  const result = await generateAISuggestion();

  // Optimistically update local state
  setUsage(prev => ({ ...prev, used: prev.used + 1 }));

  // Background: refresh from authoritative source
  refreshUsageData().catch(console.error);

  return result;
}

// Display: "Usage data updates hourly. Last updated: 2:15 PM"
```

## Code Examples

Verified patterns from official sources:

### Creating a Stripe Billing Meter (One-time Setup)
```typescript
// Source: https://docs.stripe.com/billing/subscriptions/usage-based/implementation-guide
// Run once via Stripe Dashboard or API

const meter = await stripe.billing.meters.create({
  display_name: 'AI Suggestions',
  event_name: 'ai_suggestion',
  default_aggregation: {
    formula: 'sum', // Sum all values
  },
  value_settings: {
    event_payload_key: 'value',
  },
});

// Result: meter.id (e.g., "mtr_...")
// Use this meter when creating prices:

const price = await stripe.prices.create({
  currency: 'eur',
  unit_amount: 30, // â‚¬0.30 per suggestion
  recurring: { interval: 'month' },
  billing_scheme: 'tiered',
  tiers: [
    { up_to: 75, flat_amount: 0 }, // Included in base
    { up_to: 'inf', unit_amount: 30 }, // Overage rate
  ],
  meter: meter.id, // Link to meter
});
```

### Recording Usage Event After AI Generation
```typescript
// Source: https://docs.stripe.com/billing/subscriptions/usage-based/recording-usage-api
import { stripe } from '@/lib/stripe';
import { logger } from '../utils/logger';

interface UsageReport {
  customerId: string;
  suggestionId: string;
  workspaceId: string;
  userId: string;
}

export async function reportAISuggestionToStripe(report: UsageReport): Promise<void> {
  try {
    // Idempotent identifier prevents duplicate billing
    const identifier = `${report.workspaceId}-${report.userId}-${report.suggestionId}`;

    await stripe.billing.meterEvents.create({
      event_name: 'ai_suggestion',
      payload: {
        stripe_customer_id: report.customerId,
        value: 1, // Always 1 per suggestion
      },
      identifier, // Prevents duplicates on retry
    });

    logger.info({
      customerId: report.customerId,
      identifier
    }, 'Usage reported to Stripe');
  } catch (error) {
    // Non-fatal: local tracking still works, retry via background job
    logger.error({ error, report }, 'Failed to report usage to Stripe');
  }
}

// Rate limit: 1,000/sec (sufficient for real-time reporting)
// For batch: POST /v2/billing/meter_event_stream (10,000/sec)
```

### Daily Background Job for Batch Reporting
```typescript
// Source: Pattern from https://www.peakscale.com/redis-rate-limiting/
import { db, usageEvents } from '@slack-speak/database';
import { sql } from 'drizzle-orm';

interface UnreportedEvent {
  id: string;
  customerId: string;
  workspaceId: string;
  userId: string;
  eventType: string;
  createdAt: Date;
}

export async function reportUnreportedUsageToStripe(): Promise<void> {
  // Find events from last 24 hours not yet reported to Stripe
  const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const unreported = await db
    .select()
    .from(usageEvents)
    .where(sql`${usageEvents.createdAt} > ${cutoff}`)
    .limit(1000); // Batch size

  for (const event of unreported) {
    try {
      const identifier = `${event.workspaceId}-${event.userId}-${event.id}`;

      await stripe.billing.meterEvents.create({
        event_name: 'ai_suggestion',
        payload: {
          stripe_customer_id: event.customerId,
          value: 1,
        },
        identifier,
      });

      // Mark as reported (add column or separate table)
      // await markEventReported(event.id);
    } catch (error) {
      logger.warn({ error, eventId: event.id }, 'Failed to report event to Stripe');
      // Retry next day
    }
  }

  logger.info({ count: unreported.length }, 'Batch usage reporting completed');
}

// Schedule: Daily at 2 AM UTC
// BullMQ job: add to existing job infrastructure
```

### Usage Dashboard API Route
```typescript
// Source: Next.js API route pattern + existing access-check.ts
import { NextResponse } from 'next/server';
import { getUser } from '@/lib/auth/dal';
import { getCurrentUsage } from '@/lib/billing/usage-queries';
import { getPlanById } from '@/lib/billing/plans.config';

export async function GET(request: Request) {
  const user = await getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const usage = await getCurrentUsage(user.email);

  if (!usage) {
    return NextResponse.json({
      used: 0,
      limit: 5, // Free tier default
      percentUsed: 0,
      planId: 'free',
    });
  }

  const plan = getPlanById(usage.planId || 'free');
  const percentUsed = Math.min((usage.suggestionsUsed / usage.suggestionsIncluded) * 100, 100);

  return NextResponse.json({
    used: usage.suggestionsUsed,
    limit: usage.suggestionsIncluded,
    percentUsed,
    isOverage: usage.suggestionsUsed > usage.suggestionsIncluded,
    overageCount: Math.max(0, usage.suggestionsUsed - usage.suggestionsIncluded),
    planId: usage.planId,
    overageRate: plan?.overageRate || 0,
    billingPeriodEnd: usage.billingPeriodEnd,
  });
}
```

### Admin Organization Usage Analytics
```typescript
// Source: PostgreSQL aggregation best practices
import { db, usageRecords, usageEvents, users } from '@slack-speak/database';
import { eq, and, sql } from 'drizzle-orm';

interface OrgUsageSummary {
  totalUsers: number;
  totalSuggestions: number;
  averagePerUser: number;
  topUsers: Array<{
    email: string;
    suggestionsUsed: number;
  }>;
}

export async function getOrgUsageSummary(
  organizationId: string,
  billingPeriodStart: Date
): Promise<OrgUsageSummary> {
  // Get all users in org
  const orgUsers = await db
    .select({ email: users.email })
    .from(users)
    .innerJoin(workspaces, eq(users.workspaceId, workspaces.id))
    .where(eq(workspaces.organizationId, organizationId));

  const emails = orgUsers.map(u => u.email).filter(Boolean);

  // Aggregate usage across all org users
  const usageStats = await db
    .select({
      email: usageRecords.email,
      suggestionsUsed: usageRecords.suggestionsUsed,
    })
    .from(usageRecords)
    .where(
      and(
        sql`${usageRecords.email} = ANY(${emails})`,
        eq(usageRecords.billingPeriodStart, billingPeriodStart)
      )
    )
    .orderBy(sql`${usageRecords.suggestionsUsed} DESC`)
    .limit(10); // Top 10 users

  const totalSuggestions = usageStats.reduce((sum, u) => sum + u.suggestionsUsed, 0);

  return {
    totalUsers: emails.length,
    totalSuggestions,
    averagePerUser: Math.round(totalSuggestions / emails.length),
    topUsers: usageStats.map(u => ({
      email: u.email,
      suggestionsUsed: u.suggestionsUsed,
    })),
  };
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Subscription Items Usage Records | Billing Meters + Meter Events | Q1 2025 (Stripe v2025-03-31.basil) | Must migrate by 2026; new API more flexible |
| Fixed-price only | Hybrid base + metered overage | 2024-2025 | Fair usage model; prevents bill shock |
| Hard caps for all tiers | Soft limits with overage billing | 2024-2025 | Better UX; users can exceed limits if willing to pay |
| Manual CSV uploads | Real-time API reporting | 2023+ | Accurate billing; less manual work |
| Proprietary metering | Stripe-native metering | 2024+ | Offloads billing complexity to Stripe |

**Deprecated/outdated:**
- `stripe.subscriptionItems.createUsageRecord()` - Removed in API v2025-03-31.basil
- Fixed window rate limiting - Sliding window more accurate
- Blocking all users at 100% - Allow overage on paid plans
- Client-side usage calculation - Must be server-authoritative

## Open Questions

Things that couldn't be fully resolved:

1. **Redis caching for high-scale scenarios**
   - What we know: Current PostgreSQL approach sufficient for <1000 req/sec
   - What's unclear: At what scale Redis becomes necessary vs premature optimization
   - Recommendation: Start with PostgreSQL; monitor query latency; add Redis if P95 >50ms

2. **Admin usage alerts and anomaly detection**
   - What we know: Phase 11.1 focuses on user-facing dashboards
   - What's unclear: Scope for admin alerts (Slack notifications when org hits 90% usage?)
   - Recommendation: Defer to future phase; focus on core usage tracking first

3. **Historical usage charts (6-month trends)**
   - What we know: `usageRecords` stores monthly snapshots; can query past periods
   - What's unclear: Whether to archive old records or keep indefinitely
   - Recommendation: Keep 12 months rolling; archive to S3 if needed

4. **Stripe webhook for invoice.finalized vs invoice.paid**
   - What we know: Overage charges appear on monthly invoice
   - What's unclear: Best webhook to trigger "Your bill includes $X overage" email
   - Recommendation: Use `invoice.finalized` (before payment) to show preview

## Sources

### Primary (HIGH confidence)
- [Stripe Usage-Based Billing Implementation Guide](https://docs.stripe.com/billing/subscriptions/usage-based/implementation-guide) - Official documentation for Billing Meters
- [Stripe Recording Usage API](https://docs.stripe.com/billing/subscriptions/usage-based/recording-usage-api) - Meter events endpoint details
- [Stripe Billing Meters Migration Guide](https://docs.stripe.com/billing/subscriptions/usage-based-legacy/migration-guide) - Legacy API deprecation timeline
- Existing codebase: `usage-enforcement.ts`, `schema.ts` (usageRecords/usageEvents tables), `plans.config.ts`

### Secondary (MEDIUM confidence)
- [Redis Sliding Window Rate Limiting](https://redis.io/tutorials/develop/dotnet/aspnetcore/rate-limiting/sliding-window/) - Optional performance optimization pattern
- [SaaS Notification Best Practices](https://userpilot.com/blog/notification-types/) - Warning levels, user control, severity classification
- [Usage Limit UX Guidelines](https://www.stigg.io/blog-posts/beyond-metering-the-only-guide-youll-ever-need-to-implement-usage-based-pricing) - Budget caps, proactive notifications, overage handling
- [React Dashboard Components (MUI)](https://mui.com/store/collections/free-react-dashboard/) - Component patterns for usage visualization

### Tertiary (LOW confidence - for reference)
- Web search results for dashboard design patterns - General UI/UX guidance
- PostgreSQL monitoring tools - Performance tuning if needed at scale

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed and used in codebase
- Architecture: HIGH - Database schema exists, enforcement logic in place, clear extension path
- Pitfalls: HIGH - Official Stripe docs clarify deprecation; existing code shows patterns to follow

**Research date:** 2026-02-03
**Valid until:** ~30 days (stable domain; Stripe API changes are announced well in advance)

**Key decisions locked in by existing code:**
- PostgreSQL for durable usage records (not pure Redis)
- Monthly billing periods (calendar month boundaries)
- Email-based user identity (for cross-workspace subscriptions)
- Atomic SQL increments (no race conditions)
- Async Stripe reporting (non-blocking AI generation)

**Phase 11.1 specific considerations:**
- Focus on configurable pricing (already done in plans.config.ts)
- Dashboard visibility is NEW requirement (no existing UI)
- Stripe metered billing is NEW (not yet integrated, only local tracking)
- Admin analytics is NEW (no org-level usage views yet)
