---
phase: 02.1-testing-infrastructure
plan: 05
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - apps/slack-backend/src/handlers/events/app-mention.test.ts
  - apps/slack-backend/src/handlers/events/message-reply.test.ts
  - apps/slack-backend/src/handlers/commands/watch.test.ts
autonomous: true

must_haves:
  truths:
    - "Event handler tests verify job queueing occurs"
    - "Command handler tests verify ack() called immediately"
    - "Watch/unwatch state correctly toggled"
  artifacts:
    - path: "apps/slack-backend/src/handlers/events/app-mention.test.ts"
      provides: "Unit tests for app_mention handler"
      min_lines: 50
    - path: "apps/slack-backend/src/handlers/events/message-reply.test.ts"
      provides: "Unit tests for message reply detection"
      min_lines: 70
    - path: "apps/slack-backend/src/handlers/commands/watch.test.ts"
      provides: "Unit tests for /watch and /unwatch commands"
      min_lines: 60
  key_links:
    - from: "apps/slack-backend/src/handlers/events/app-mention.test.ts"
      to: "jobs/queues.ts"
      via: "queueAIResponse mock"
      pattern: "queueAIResponse"
---

<objective>
Create unit tests for event handlers (app_mention, message_reply) and slash commands (/watch, /unwatch).

Purpose: Verify Slack event processing and command handling works correctly
Output: Unit tests achieving 90%+ coverage for event and command handlers
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/slack-backend/src/handlers/events/app-mention.ts
@apps/slack-backend/src/handlers/events/message-reply.ts
@apps/slack-backend/src/handlers/commands/watch.ts
@apps/slack-backend/test/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for event handlers</name>
  <files>
    - apps/slack-backend/src/handlers/events/app-mention.test.ts
    - apps/slack-backend/src/handlers/events/message-reply.test.ts
  </files>
  <action>
Create unit tests for event handlers. The handlers register callbacks with Bolt app, so we need to:
1. Extract the handler logic for testing
2. Or mock the Bolt app and verify callbacks are registered correctly

**Recommended approach:** Test the handler functions directly by extracting them or testing the side effects (job queueing, logging).

**app-mention.test.ts:**

Mock dependencies:
- `queueAIResponse` from jobs/queues
- `getContextForMessage` from services/context
- Slack client methods

Test cases:
1. `should queue AI response job when mentioned`
   - Create mock event with user, channel, ts, text
   - Call handler logic
   - Verify queueAIResponse called with correct params

2. `should fetch context before queueing job`
   - Verify getContextForMessage called with channel, ts, thread_ts

3. `should use thread context when thread_ts provided`
   - Event with thread_ts
   - Verify thread_ts passed to context function

4. `should not throw on handler error (catches internally)`
   - Mock queueAIResponse to throw
   - Verify no unhandled error

5. `should get workspaceId from auth.test`
   - Verify client.auth.test called
   - Verify workspaceId from response used in job data

6. `should skip if user is missing from event`
   - Event without user field
   - Verify job not queued

**message-reply.test.ts:**

More complex - tests reply detection logic:

1. `should skip bot messages`
   - Event with bot_id
   - Verify early return (no job queued)

2. `should skip messages with subtype`
   - Event with subtype field
   - Verify skipped

3. `should record thread participation for thread messages`
   - Thread message (has thread_ts)
   - Verify recordThreadParticipation called

4. `should check watching status for thread participants`
   - Mock getThreadContext to return messages with different users
   - Verify isWatching called for each participant

5. `should queue job only for watching + participating users`
   - User1 watching, participating -> queue job
   - User2 watching, not participating -> no job
   - User3 not watching -> no job

6. `should not queue job for message author`
   - Author is watching and participating
   - Verify no job queued (don't suggest response to own message)

7. `should skip non-thread messages (no thread_ts)`
   - Message without thread_ts
   - Verify no job queued (current implementation)

Structure:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { App } from '@slack/bolt';

// Mock dependencies before importing handler
vi.mock('../../jobs/queues.js', () => ({
  queueAIResponse: vi.fn().mockResolvedValue({ id: 'job_123' }),
}));

vi.mock('../../services/context.js', () => ({
  getContextForMessage: vi.fn().mockResolvedValue([
    { userId: 'U123', text: 'Context message', ts: '1234567890.000001' },
  ]),
  getThreadContext: vi.fn().mockResolvedValue([
    { userId: 'U123', text: 'Thread message', ts: '1234567890.000001' },
  ]),
}));

import { registerAppMentionHandler } from './app-mention';
import { queueAIResponse } from '../../jobs/queues';
import { getContextForMessage } from '../../services/context';

describe('App Mention Handler', () => {
  let mockApp: Partial<App>;
  let eventHandler: Function;

  beforeEach(() => {
    vi.clearAllMocks();

    // Capture the handler when registered
    mockApp = {
      event: vi.fn((eventType, handler) => {
        if (eventType === 'app_mention') {
          eventHandler = handler;
        }
      }),
    };

    registerAppMentionHandler(mockApp as App);
  });

  it('should register handler for app_mention event', () => {
    expect(mockApp.event).toHaveBeenCalledWith('app_mention', expect.any(Function));
  });

  it('should queue AI response job when mentioned', async () => {
    const mockEvent = {
      user: 'U123',
      channel: 'C456',
      ts: '1234567890.123456',
      text: '<@BOT> help me',
    };

    const mockClient = {
      auth: {
        test: vi.fn().mockResolvedValue({ ok: true, team_id: 'T789' }),
      },
    };

    await eventHandler({ event: mockEvent, client: mockClient });

    expect(queueAIResponse).toHaveBeenCalledWith(
      expect.objectContaining({
        workspaceId: 'T789',
        userId: 'U123',
        channelId: 'C456',
        triggeredBy: 'mention',
      })
    );
  });
  // ... more tests
});
```
  </action>
  <verify>
`npm run test -- src/handlers/events/*.test.ts --run` passes
`npm run test:coverage -- src/handlers/events/*.test.ts --run` shows >90% coverage
  </verify>
  <done>
Event handlers have comprehensive tests for job queueing and edge cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for slash commands</name>
  <files>apps/slack-backend/src/handlers/commands/watch.test.ts</files>
  <action>
Create unit tests for /watch and /unwatch commands.

Mock dependencies:
- `watchConversation`, `unwatchConversation`, `isWatching` from services/watch

Test /watch command:
1. `should call ack() immediately`
   - Verify ack called (no await delay)

2. `should add watch when not already watching`
   - isWatching returns false
   - Verify watchConversation called
   - Verify respond called with success message

3. `should not add watch if already watching`
   - isWatching returns true
   - Verify watchConversation NOT called
   - Verify respond with "already watching" message

4. `should use team_id, user_id, channel_id from command`
   - Verify correct IDs passed to service functions

5. `should respond with error message on failure`
   - watchConversation throws
   - Verify respond called with error message

Test /unwatch command:
1. `should call ack() immediately`

2. `should remove watch when currently watching`
   - isWatching returns true
   - Verify unwatchConversation called
   - Verify respond with success message

3. `should not remove watch if not watching`
   - isWatching returns false
   - Verify unwatchConversation NOT called
   - Verify respond with "not watching" message

4. `should respond with error message on failure`
   - unwatchConversation throws
   - Verify error response sent

Structure:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { App } from '@slack/bolt';

vi.mock('../../services/watch.js', () => ({
  watchConversation: vi.fn().mockResolvedValue(undefined),
  unwatchConversation: vi.fn().mockResolvedValue(undefined),
  isWatching: vi.fn().mockResolvedValue(false),
}));

import { registerWatchCommands } from './watch';
import { watchConversation, unwatchConversation, isWatching } from '../../services/watch';

describe('Watch Commands', () => {
  let mockApp: Partial<App>;
  let watchHandler: Function;
  let unwatchHandler: Function;

  beforeEach(() => {
    vi.clearAllMocks();

    mockApp = {
      command: vi.fn((commandName, handler) => {
        if (commandName === '/watch') watchHandler = handler;
        if (commandName === '/unwatch') unwatchHandler = handler;
      }),
    };

    registerWatchCommands(mockApp as App);
  });

  describe('/watch', () => {
    it('should ack immediately and add watch', async () => {
      const ack = vi.fn().mockResolvedValue(undefined);
      const respond = vi.fn().mockResolvedValue(undefined);
      const command = {
        team_id: 'T123',
        user_id: 'U456',
        channel_id: 'C789',
      };

      await watchHandler({ command, ack, respond });

      expect(ack).toHaveBeenCalled();
      expect(isWatching).toHaveBeenCalledWith('T123', 'U456', 'C789');
      expect(watchConversation).toHaveBeenCalledWith('T123', 'U456', 'C789');
      expect(respond).toHaveBeenCalledWith(
        expect.objectContaining({ response_type: 'ephemeral' })
      );
    });
    // ... more tests
  });

  describe('/unwatch', () => {
    // ... tests
  });
});
```
  </action>
  <verify>
`npm run test -- src/handlers/commands/*.test.ts --run` passes
`npm run test:coverage -- src/handlers/commands/*.test.ts --run` shows >90% coverage
  </verify>
  <done>
Slash commands have comprehensive tests for watch/unwatch operations
  </done>
</task>

</tasks>

<verification>
Run all handler tests:
1. `npm run test -- src/handlers/**/*.test.ts --run`
2. `npm run test:coverage -- src/handlers/**/*.test.ts --run`

Verify handlers are correctly mocked and tested.
</verification>

<success_criteria>
- app-mention.test.ts has 6+ test cases
- message-reply.test.ts has 7+ test cases covering thread detection logic
- watch.test.ts has 8+ test cases for both /watch and /unwatch
- ack() verified as called immediately (3-second requirement)
- Job queueing verified for correct scenarios
- Coverage exceeds 90% for all handler files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-testing-infrastructure/02.1-05-SUMMARY.md`
</output>
