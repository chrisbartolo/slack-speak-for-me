---
phase: 02.1-testing-infrastructure
plan: 06
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - apps/slack-backend/src/handlers/actions/copy-suggestion.test.ts
  - apps/slack-backend/src/handlers/actions/dismiss-suggestion.test.ts
  - apps/slack-backend/src/handlers/actions/refine-suggestion.test.ts
  - apps/slack-backend/src/handlers/views/refinement-modal.test.ts
  - apps/slack-backend/src/handlers/shortcuts/help-me-respond.test.ts
autonomous: true

must_haves:
  truths:
    - "Action handlers tested for correct Block Kit responses"
    - "Refinement modal tests verify multi-turn history tracking"
    - "Message shortcut tests verify job queueing"
  artifacts:
    - path: "apps/slack-backend/src/handlers/actions/copy-suggestion.test.ts"
      provides: "Unit tests for copy button action"
      min_lines: 30
    - path: "apps/slack-backend/src/handlers/actions/refine-suggestion.test.ts"
      provides: "Unit tests for refine button action"
      min_lines: 40
    - path: "apps/slack-backend/src/handlers/views/refinement-modal.test.ts"
      provides: "Unit tests for modal submission"
      min_lines: 60
    - path: "apps/slack-backend/src/handlers/shortcuts/help-me-respond.test.ts"
      provides: "Unit tests for message shortcut"
      min_lines: 40
  key_links:
    - from: "apps/slack-backend/src/handlers/views/refinement-modal.test.ts"
      to: "services/ai.ts"
      via: "refineSuggestion mock"
      pattern: "refineSuggestion"
---

<objective>
Create unit tests for action handlers (copy, dismiss, refine), view handlers (refinement modal), and message shortcuts (help me respond).

Purpose: Verify user interaction handlers work correctly
Output: Unit tests achieving 90%+ coverage for all action, view, and shortcut handlers
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/slack-backend/src/handlers/actions/copy-suggestion.ts
@apps/slack-backend/src/handlers/actions/dismiss-suggestion.ts
@apps/slack-backend/src/handlers/actions/refine-suggestion.ts
@apps/slack-backend/src/handlers/views/refinement-modal.ts
@apps/slack-backend/src/handlers/shortcuts/help-me-respond.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for action handlers</name>
  <files>
    - apps/slack-backend/src/handlers/actions/copy-suggestion.test.ts
    - apps/slack-backend/src/handlers/actions/dismiss-suggestion.test.ts
    - apps/slack-backend/src/handlers/actions/refine-suggestion.test.ts
  </files>
  <action>
Read the action handler files first to understand their implementation, then create tests.

**copy-suggestion.test.ts:**
Based on Phase 2 decisions, copy button shows code block with triple-click instructions (Slack doesn't support clipboard access).

Test cases:
1. `should call ack() to acknowledge action`
2. `should respond with suggestion in code block format`
3. `should include triple-click copy instructions`
4. `should include original suggestion text`

**dismiss-suggestion.test.ts:**
Based on Phase 2 decisions, dismiss uses delete_original: true.

Test cases:
1. `should call ack() to acknowledge action`
2. `should respond with delete_original: true`
3. `should handle ack error gracefully`

**refine-suggestion.test.ts:**
Opens refinement modal with current suggestion.

Test cases:
1. `should call ack() to acknowledge action`
2. `should open views.open modal`
3. `should include current suggestion in modal private_metadata`
4. `should set callback_id to refinement_modal`
5. `should include refinement input block`

Structure for each:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { App } from '@slack/bolt';

// Read and understand the handler first, then mock appropriately
import { registerCopySuggestionHandler } from './copy-suggestion';

describe('Copy Suggestion Action', () => {
  let mockApp: Partial<App>;
  let actionHandler: Function;

  beforeEach(() => {
    vi.clearAllMocks();

    mockApp = {
      action: vi.fn((actionId, handler) => {
        if (actionId === 'copy_suggestion') {
          actionHandler = handler;
        }
      }),
    };

    registerCopySuggestionHandler(mockApp as App);
  });

  it('should acknowledge action and show copy instructions', async () => {
    const ack = vi.fn().mockResolvedValue(undefined);
    const respond = vi.fn().mockResolvedValue(undefined);
    const body = {
      actions: [{ value: 'sug_123' }],
      message: {
        blocks: [
          { type: 'header' },
          { type: 'context' },
          { type: 'divider' },
          { type: 'section', text: { text: 'Original suggestion text' } },
        ],
      },
    };

    await actionHandler({ ack, respond, body });

    expect(ack).toHaveBeenCalled();
    expect(respond).toHaveBeenCalled();
  });
});
```
  </action>
  <verify>
`npm run test -- src/handlers/actions/*.test.ts --run` passes
`npm run test:coverage -- src/handlers/actions/*.test.ts --run` shows >90% coverage
  </verify>
  <done>
Action handlers have comprehensive tests for all button interactions
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for view handler and message shortcut</name>
  <files>
    - apps/slack-backend/src/handlers/views/refinement-modal.test.ts
    - apps/slack-backend/src/handlers/shortcuts/help-me-respond.test.ts
  </files>
  <action>
**refinement-modal.test.ts:**
Complex handler - processes modal submission, calls AI, updates modal.

Mock:
- `refineSuggestion` from services
- `client.views.update` from context

Test cases:
1. `should parse private_metadata from view`
   - Verify metadata parsed correctly

2. `should get refinement text from input state`
   - Verify state.values.refinement_input.refinement_text.value extracted

3. `should return error if refinement text empty`
   - Submit with empty input
   - Verify ack with response_action: 'errors'

4. `should ack with loading state immediately`
   - Verify ack called with response_action: 'update'
   - Verify shows "Refining..." text

5. `should call refineSuggestion with correct params`
   - Verify originalSuggestion, refinementRequest, history passed

6. `should update modal with refined suggestion`
   - Verify views.update called after refinement
   - Verify new suggestion shown

7. `should track history across refinement rounds`
   - Submit refinement
   - Verify history array updated with previous round

8. `should truncate history if approaching metadata limit`
   - Start with near-limit history
   - Verify oldest entry removed

9. `should show error modal on refinement failure`
   - Mock refineSuggestion to throw
   - Verify error modal displayed

10. `should include Copy Final button in refined view`
    - Verify action block has copy_final_suggestion button

**help-me-respond.test.ts:**
Message shortcut triggers AI job for any message.

Mock:
- `queueAIResponse` from jobs/queues
- `getContextForMessage` from services/context

Test cases:
1. `should call ack() immediately`

2. `should queue AI response job`
   - Verify queueAIResponse called with triggeredBy: 'message_action'

3. `should get context for the selected message`
   - Verify getContextForMessage called with message channel/ts

4. `should use message text as trigger`
   - Verify triggerMessageText from shortcut.message.text

5. `should get workspaceId from auth.test`

6. `should respond with confirmation message`
   - Verify user gets "Working on it..." response

7. `should handle errors gracefully`
   - Mock queueAIResponse to throw
   - Verify error response sent

Structure:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';

vi.mock('../../services/index.js', () => ({
  refineSuggestion: vi.fn().mockResolvedValue({
    suggestion: 'Refined suggestion text',
    processingTimeMs: 500,
  }),
}));

import { registerRefinementModalHandler } from './refinement-modal';
import { refineSuggestion } from '../../services/index';

describe('Refinement Modal Handler', () => {
  let mockApp: any;
  let viewHandler: Function;

  beforeEach(() => {
    vi.clearAllMocks();

    mockApp = {
      view: vi.fn((callbackId, handler) => {
        if (callbackId === 'refinement_modal') {
          viewHandler = handler;
        }
      }),
    };

    registerRefinementModalHandler(mockApp);
  });

  it('should call refineSuggestion with metadata', async () => {
    const metadata = {
      suggestionId: 'sug_123',
      currentSuggestion: 'Original suggestion',
      history: [],
    };

    const ack = vi.fn().mockResolvedValue(undefined);
    const body = { view: { id: 'V123' } };
    const view = {
      private_metadata: JSON.stringify(metadata),
      state: {
        values: {
          refinement_input: {
            refinement_text: { value: 'Make it shorter' },
          },
        },
      },
    };
    const context = {
      client: {
        views: {
          update: vi.fn().mockResolvedValue({ ok: true }),
        },
      },
    };

    await viewHandler({ ack, body, view, context });

    expect(refineSuggestion).toHaveBeenCalledWith(
      expect.objectContaining({
        originalSuggestion: 'Original suggestion',
        refinementRequest: 'Make it shorter',
      })
    );
  });
  // ... more tests
});
```
  </action>
  <verify>
`npm run test -- src/handlers/views/*.test.ts src/handlers/shortcuts/*.test.ts --run` passes
`npm run test:coverage -- src/handlers/views/*.test.ts src/handlers/shortcuts/*.test.ts --run` shows >90% coverage
  </verify>
  <done>
View handlers and shortcuts have comprehensive tests for user interaction flows
  </done>
</task>

</tasks>

<verification>
Run all UI handler tests:
1. `npm run test -- "src/handlers/**/*.test.ts" --run`
2. `npm run test:coverage -- "src/handlers/**/*.test.ts" --run`

All handler tests should pass with high coverage.
</verification>

<success_criteria>
- copy-suggestion.test.ts has 4+ tests
- dismiss-suggestion.test.ts has 3+ tests
- refine-suggestion.test.ts has 5+ tests
- refinement-modal.test.ts has 10+ tests covering multi-turn flow
- help-me-respond.test.ts has 7+ tests
- Modal metadata parsing and history tracking verified
- Coverage exceeds 90% for all handler files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-testing-infrastructure/02.1-06-SUMMARY.md`
</output>
