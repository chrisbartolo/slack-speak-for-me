---
phase: 02.1-testing-infrastructure
plan: 08
type: execute
wave: 3
depends_on: ["02.1-05", "02.1-06", "02.1-07"]
files_modified:
  - apps/slack-backend/test/e2e/app-mention.e2e.test.ts
  - apps/slack-backend/test/e2e/suggestion-flow.e2e.test.ts
autonomous: true

must_haves:
  truths:
    - "E2E tests validate complete flow from event to suggestion delivery"
    - "E2E tests use real database and mocked external APIs"
    - "All success criteria from Phase 2 covered by E2E tests"
  artifacts:
    - path: "apps/slack-backend/test/e2e/app-mention.e2e.test.ts"
      provides: "E2E test for app mention flow"
      min_lines: 80
    - path: "apps/slack-backend/test/e2e/suggestion-flow.e2e.test.ts"
      provides: "E2E test for complete suggestion workflow"
      min_lines: 100
  key_links:
    - from: "apps/slack-backend/test/e2e/*.test.ts"
      to: "src/app.ts"
      via: "Express app import"
      pattern: "import.*app"
---

<objective>
Create end-to-end tests validating complete user flows from Slack event to suggestion delivery.

Purpose: Verify the entire system works together correctly
Output: E2E tests covering all Phase 2 success criteria
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/slack-backend/src/app.ts
@apps/slack-backend/src/index.ts
@apps/slack-backend/test/setup.ts
@apps/slack-backend/test/helpers/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E test for app mention flow</name>
  <files>apps/slack-backend/test/e2e/app-mention.e2e.test.ts</files>
  <action>
Create E2E test that validates the complete app mention flow:
1. User mentions bot in channel
2. Event received and processed
3. Context fetched from Slack
4. AI generates suggestion
5. Ephemeral message delivered to user

**Setup:**
- Use supertest to send HTTP requests to the app
- Use PGlite for database
- Use MSW for external API mocking (Slack, Anthropic)
- May need to disable Slack signature verification for tests

**Test: Complete app_mention flow**

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import { setupTestDb, cleanupTestDb, getTestDb } from '../helpers/db';
import { server } from '../setup';
import { http, HttpResponse } from 'msw';

// Import or create app instance for testing
// May need to export app separately from index.ts

describe('App Mention E2E', () => {
  beforeAll(async () => {
    await setupTestDb();
    // Seed test installation
    const db = getTestDb();
    // Insert workspace and installation for T123
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  it('should process app_mention and deliver suggestion', async () => {
    // Track if ephemeral message was sent
    let ephemeralCalled = false;
    server.use(
      http.post('https://slack.com/api/chat.postEphemeral', () => {
        ephemeralCalled = true;
        return HttpResponse.json({ ok: true });
      })
    );

    const event = {
      type: 'event_callback',
      team_id: 'T123',
      event: {
        type: 'app_mention',
        user: 'U456',
        channel: 'C789',
        ts: '1234567890.123456',
        text: '<@BOT123> help me respond to this difficult email',
      },
    };

    // Note: May need to handle Slack signature verification
    // Either disable in test env or generate valid signature

    const response = await request(app)
      .post('/slack/events')
      .send(event);

    // Event should be accepted
    expect(response.status).toBe(200);

    // Wait for async job processing
    // This is tricky - may need to either:
    // 1. Mock the queue and process synchronously
    // 2. Actually wait for job completion
    // 3. Use a callback/event to know when done

    await new Promise(resolve => setTimeout(resolve, 1000));

    // Verify ephemeral message was sent
    expect(ephemeralCalled).toBe(true);
  });

  it('should include context in AI request', async () => {
    let aiRequestBody: any = null;
    server.use(
      http.post('https://api.anthropic.com/v1/messages', async ({ request }) => {
        aiRequestBody = await request.json();
        return HttpResponse.json({
          id: 'msg_test',
          type: 'message',
          role: 'assistant',
          content: [{ type: 'text', text: 'E2E test suggestion' }],
          usage: { input_tokens: 100, output_tokens: 50 },
        });
      })
    );

    // Send event and process
    // ...

    // Verify AI received context
    expect(aiRequestBody.messages[0].content).toContain('conversation context');
  });
});
```

**Challenges to address:**
1. Bolt signature verification - set `SLACK_SKIP_SIGNATURE_VERIFICATION=true`
2. Async job processing - may need to process queue synchronously in tests
3. Database seeding - need valid installation for workspaceId lookup
  </action>
  <verify>
`npm run test -- test/e2e/app-mention.e2e.test.ts --run` passes
Complete flow verified from event to delivery
  </verify>
  <done>
E2E test validates app mention triggers suggestion delivery
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E test for complete suggestion workflow</name>
  <files>apps/slack-backend/test/e2e/suggestion-flow.e2e.test.ts</files>
  <action>
Create comprehensive E2E tests covering all Phase 2 success criteria:

**Phase 2 Success Criteria to test:**
1. User receives ephemeral suggestion when mentioned
2. User receives ephemeral suggestion when replied to in watched conversation
3. User receives ephemeral suggestion in active thread
4. User can trigger via message shortcut
5. User can refine suggestion
6. User can copy suggestion
7. User can toggle watch/unwatch

**Test cases:**

1. `should deliver suggestion when user mentioned (SC1)`
   - Seed installation
   - Send app_mention event
   - Verify ephemeral sent to correct user

2. `should deliver suggestion when replied to in watched channel (SC2)`
   - Seed installation + watch record
   - Send message event with thread_ts
   - Verify ephemeral sent to watching user

3. `should deliver suggestion in active thread (SC3)`
   - Seed installation + watch + thread participation
   - Send thread reply
   - Verify ephemeral sent to participating user

4. `should trigger via message shortcut (SC4)`
   - Send shortcut payload
   - Verify job queued and suggestion delivered

5. `should open refinement modal on refine click (SC5 - partial)`
   - Send refine_suggestion action
   - Verify views.open called with modal

6. `should process refinement and update modal (SC5 - complete)`
   - Send view submission
   - Verify refineSuggestion called
   - Verify views.update called with new suggestion

7. `should show copy instructions on copy click (SC6)`
   - Send copy_suggestion action
   - Verify response contains suggestion text

8. `should add watch via /watch command (SC7)`
   - Send command payload
   - Verify watch record created
   - Verify ephemeral confirmation sent

9. `should remove watch via /unwatch command (SC7)`
   - Seed watch record
   - Send /unwatch command
   - Verify watch record deleted
   - Verify ephemeral confirmation sent

10. `should include context from recent messages (SC8)`
    - Seed conversation history via MSW mock
    - Trigger suggestion
    - Verify AI request includes context

Structure:
```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import { setupTestDb, cleanupTestDb, getTestDb } from '../helpers/db';
import { server, handlers } from '../setup';
import { http, HttpResponse } from 'msw';
import * as schema from '@slack-speak/database';

describe('Suggestion Flow E2E', () => {
  let db: any;

  beforeAll(async () => {
    db = await setupTestDb();
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  beforeEach(async () => {
    // Reset handlers and clear test data
    server.resetHandlers();
    // Clear tables between tests
    await db.delete(schema.watchedConversations);
    await db.delete(schema.threadParticipants);
  });

  describe('SC1: Mention triggers suggestion', () => {
    // ... tests
  });

  describe('SC2: Reply triggers suggestion', () => {
    // ... tests
  });

  describe('SC5: Refinement flow', () => {
    // ... tests
  });

  describe('SC7: Watch/Unwatch', () => {
    it('should add watch via /watch command', async () => {
      // Seed workspace
      await db.insert(schema.workspaces).values({ teamId: 'T123', name: 'Test' });

      // Send /watch command
      // Note: Need to understand how Bolt processes commands
      // May need different approach than direct HTTP

      // Verify watch record exists
      const watches = await db.select()
        .from(schema.watchedConversations)
        .where(eq(schema.watchedConversations.userId, 'U456'));

      expect(watches).toHaveLength(1);
    });
  });
});
```
  </action>
  <verify>
`npm run test -- test/e2e/suggestion-flow.e2e.test.ts --run` passes
All Phase 2 success criteria covered by E2E tests
  </verify>
  <done>
E2E tests validate all Phase 2 success criteria are working
  </done>
</task>

</tasks>

<verification>
Run all E2E tests:
1. `npm run test -- test/e2e/*.test.ts --run`
2. Verify all Phase 2 success criteria have corresponding tests
3. Tests should use real database (PGlite) and mocked external APIs (MSW)
</verification>

<success_criteria>
- app-mention.e2e.test.ts validates complete mention flow
- suggestion-flow.e2e.test.ts covers all 8 Phase 2 success criteria
- Tests use supertest for HTTP requests
- Tests use PGlite for database
- Tests use MSW for Slack/Anthropic API mocking
- All tests pass and demonstrate features working together
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-testing-infrastructure/02.1-08-SUMMARY.md`
</output>
