---
phase: 02.1-testing-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["02.1-02", "02.1-03", "02.1-04"]
files_modified:
  - apps/slack-backend/test/integration/database.test.ts
  - apps/slack-backend/test/integration/job-queue.test.ts
autonomous: true

must_haves:
  truths:
    - "Database integration tests use real PostgreSQL via PGlite"
    - "Job queue tests verify worker processes jobs correctly"
    - "Integration tests run independently without mocking business logic"
  artifacts:
    - path: "apps/slack-backend/test/integration/database.test.ts"
      provides: "Integration tests for database operations"
      min_lines: 80
    - path: "apps/slack-backend/test/integration/job-queue.test.ts"
      provides: "Integration tests for BullMQ workers"
      min_lines: 100
  key_links:
    - from: "apps/slack-backend/test/integration/job-queue.test.ts"
      to: "jobs/workers.ts"
      via: "Worker import"
      pattern: "Worker|startWorkers"
---

<objective>
Create integration tests for database operations and job queue processing.

Purpose: Verify components work together correctly with real database and message queue
Output: Integration tests that exercise real database and job processing
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-testing-infrastructure/02.1-RESEARCH.md
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/test/helpers/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database integration tests</name>
  <files>apps/slack-backend/test/integration/database.test.ts</files>
  <action>
Create integration tests that verify database operations work correctly together.

These tests use PGlite (real PostgreSQL) instead of mocks.

**Test workspace and installation lifecycle:**
1. `should create workspace and installation together`
   - Insert workspace
   - Insert installation referencing workspace
   - Verify both records exist

2. `should enforce workspace.team_id uniqueness`
   - Insert workspace with team_id
   - Attempt duplicate
   - Verify constraint error

3. `should cascade correctly (foreign key behavior)`
   - Verify installation.workspace_id references valid workspace

**Test watched conversations:**
1. `should insert watched conversation`
   - Insert workspace first
   - Insert watched conversation
   - Query and verify

2. `should enforce unique constraint on (workspace_id, user_id, channel_id)`
   - Insert watch
   - Attempt duplicate
   - Verify conflict handling

3. `should allow multiple watches per user (different channels)`
   - Same user watches C123 and C456
   - Both records exist

4. `should allow multiple users to watch same channel`
   - User1 and User2 both watch C123
   - Both records exist

5. `should delete watch correctly`
   - Create and delete
   - Verify record gone

**Test thread participants:**
1. `should insert thread participation`

2. `should update lastMessageAt on conflict`
   - Insert participation
   - Insert again (upsert)
   - Verify timestamp updated

3. `should query by thread correctly`
   - Multiple participants in same thread
   - Query returns all

4. `should filter by time window (7 days)`
   - Insert old participation (manually set timestamp)
   - Query with date filter
   - Verify old records excluded

**Test complex queries:**
1. `should join installations with workspaces`
   - Create workspace and installation
   - Query with join
   - Verify both tables data returned

Structure:
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { eq, and } from 'drizzle-orm';
import { setupTestDb, cleanupTestDb } from '../helpers/db';
import * as schema from '@slack-speak/database';

describe('Database Integration', () => {
  let db: Awaited<ReturnType<typeof setupTestDb>>;

  beforeEach(async () => {
    db = await setupTestDb();
  });

  afterEach(async () => {
    await cleanupTestDb();
  });

  describe('Workspaces', () => {
    it('should insert and query workspace', async () => {
      await db.insert(schema.workspaces).values({
        teamId: 'T123',
        name: 'Test Workspace',
      });

      const results = await db.select()
        .from(schema.workspaces)
        .where(eq(schema.workspaces.teamId, 'T123'));

      expect(results).toHaveLength(1);
      expect(results[0].name).toBe('Test Workspace');
    });
    // ... more tests
  });

  describe('Watched Conversations', () => {
    // ... tests
  });

  describe('Thread Participants', () => {
    // ... tests
  });
});
```
  </action>
  <verify>
`npm run test -- test/integration/database.test.ts --run` passes
All database operations work correctly with PGlite
  </verify>
  <done>
Database integration tests verify CRUD operations and constraints with real PostgreSQL
  </done>
</task>

<task type="auto">
  <name>Task 2: Job queue integration tests</name>
  <files>apps/slack-backend/test/integration/job-queue.test.ts</files>
  <action>
Create integration tests for BullMQ job processing.

**Option 1 (Simpler): Test with mocked Redis via IORedis mock**
**Option 2 (More realistic): Use Testcontainers Redis**

Research recommended Testcontainers for realistic testing. Install if not present.

If Testcontainers too complex for CI, use manual job processing pattern:
```typescript
// Process job directly without worker
const job = await queue.add('ai-response', jobData);
const result = await processJob(job); // Call worker logic directly
```

**Test cases:**

1. `should add job to queue`
   - Call queueAIResponse
   - Verify job exists in queue

2. `should process job and generate suggestion`
   - Add job
   - Process via worker (or direct call)
   - Verify result contains suggestion

3. `should handle job failure with retry`
   - Add job that will fail
   - Verify attempts incremented
   - Verify eventual failure logged

4. `should respect rate limiting (10 jobs/second)`
   - Add many jobs
   - Verify processing respects limiter

5. `should deliver suggestion after generation`
   - Add job
   - Process
   - Verify chat.postEphemeral called (via MSW)

6. `should handle missing installation gracefully`
   - Add job for unknown workspace
   - Verify generation succeeds but delivery logs error

7. `should emit completed event with result`
   - Listen for 'completed' event
   - Verify result contains suggestionId and processingTimeMs

8. `should handle stalled jobs`
   - Simulate stalled job
   - Verify warning logged

**Using Testcontainers:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { Queue, Worker, QueueEvents } from 'bullmq';
import { GenericContainer, StartedTestContainer } from 'testcontainers';

describe('Job Queue Integration', () => {
  let redisContainer: StartedTestContainer;
  let queue: Queue;
  let queueEvents: QueueEvents;
  let connection: { host: string; port: number };

  beforeAll(async () => {
    // Start Redis container (may take a few seconds)
    redisContainer = await new GenericContainer('redis:7-alpine')
      .withExposedPorts(6379)
      .start();

    connection = {
      host: redisContainer.getHost(),
      port: redisContainer.getMappedPort(6379),
    };

    queue = new Queue('ai-responses', { connection });
    queueEvents = new QueueEvents('ai-responses', { connection });
  }, 60000); // 60s timeout for container start

  afterAll(async () => {
    await queue.close();
    await queueEvents.close();
    await redisContainer.stop();
  });

  it('should add and process job', async () => {
    const worker = new Worker(
      'ai-responses',
      async (job) => {
        return { suggestion: 'Test', processingTimeMs: 100, suggestionId: 'sug_test' };
      },
      { connection }
    );

    const job = await queue.add('generate', {
      workspaceId: 'W123',
      userId: 'U123',
      channelId: 'C123',
      messageTs: '1234567890.000001',
      triggerMessageText: 'Test',
      contextMessages: [],
      triggeredBy: 'mention',
    });

    const result = await job.waitUntilFinished(queueEvents, 10000);

    expect(result.suggestion).toBe('Test');
    await worker.close();
  });
  // ... more tests
});
```

**Note:** Testcontainers requires Docker. If CI doesn't have Docker, these tests may need to be skipped in CI or use alternative approach.
  </action>
  <verify>
`npm run test -- test/integration/job-queue.test.ts --run` passes
Job processing verified end-to-end
  </verify>
  <done>
Job queue integration tests verify BullMQ worker processes jobs correctly
  </done>
</task>

</tasks>

<verification>
Run integration tests:
1. `npm run test -- test/integration/*.test.ts --run`
2. Verify database tests use PGlite successfully
3. Verify job tests (may require Docker for Testcontainers)
</verification>

<success_criteria>
- database.test.ts has 12+ tests covering all tables
- job-queue.test.ts has 8+ tests covering job lifecycle
- Tests use real PostgreSQL (PGlite) not mocks
- Tests use real Redis (Testcontainers) or document skip conditions
- All CRUD operations verified
- Foreign key constraints verified
- Job processing verified end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-testing-infrastructure/02.1-07-SUMMARY.md`
</output>
