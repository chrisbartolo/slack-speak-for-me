---
phase: 12-client-context-support
plan: 05
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - apps/slack-backend/src/services/knowledge-base.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/jobs/knowledge-base-indexer.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/web-portal/app/admin/knowledge-base/page.tsx
  - apps/web-portal/app/api/admin/knowledge-base/route.ts
  - apps/web-portal/app/api/admin/knowledge-base/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin can upload knowledge base documents with title, content, category, and tags"
    - "Documents are embedded using the existing embedding approach (pgvector)"
    - "Semantic search retrieves relevant documents based on query similarity"
    - "Search has 500ms timeout to avoid blocking suggestion generation"
  artifacts:
    - path: "apps/slack-backend/src/services/knowledge-base.ts"
      provides: "Document indexing and semantic search via pgvector"
      exports: ["indexDocument", "searchKnowledgeBase", "deleteDocument", "getDocuments"]
    - path: "apps/slack-backend/src/jobs/knowledge-base-indexer.ts"
      provides: "Background job for document embedding"
    - path: "apps/web-portal/app/admin/knowledge-base/page.tsx"
      provides: "Admin UI for uploading and managing knowledge base documents"
  key_links:
    - from: "apps/slack-backend/src/services/knowledge-base.ts"
      to: "packages/database/src/schema.ts"
      via: "pgvector similarity search"
      pattern: "knowledgeBaseDocuments"
    - from: "apps/slack-backend/src/jobs/knowledge-base-indexer.ts"
      to: "apps/slack-backend/src/services/knowledge-base.ts"
      via: "indexDocument call"
      pattern: "indexDocument"
---

<objective>
Build knowledge base service with RAG (pgvector semantic search) and admin management page.

Purpose: AI needs to reference product/service documentation when generating client-facing suggestions. This service embeds documents and retrieves relevant context via semantic similarity search.
Output: Knowledge base service with document indexing + semantic search + admin page for document management + background indexing job.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-client-context-support/12-01-SUMMARY.md
@packages/database/src/schema.ts
@apps/slack-backend/src/services/personalization/historyAnalyzer.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/types.ts
@.planning/phases/12-client-context-support/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge base service with embedding and search</name>
  <files>apps/slack-backend/src/services/knowledge-base.ts, apps/slack-backend/src/services/index.ts</files>
  <action>
Create `apps/slack-backend/src/services/knowledge-base.ts`:

**Embedding approach (CONCRETE):** The codebase uses a hash-based pseudo-embedding in `apps/slack-backend/src/services/personalization/historyAnalyzer.ts` (function `generateEmbedding`). It produces 1536-dimension vectors using character frequency, word length distribution, common word presence, and punctuation patterns, then normalizes. There is NO external embedding API (no OpenAI SDK). Copy this same `generateEmbedding` function into knowledge-base.ts (or extract it into a shared `utils/embeddings.ts` and import from both places). Use dimension 1536 to match the existing schema. Store embeddings as JSON strings and cast to `::vector` in raw SQL, exactly as historyAnalyzer.ts does.

**Functions to create:**

1. `embedText(text: string): Promise<number[]>` - Generate embedding vector for text. Copy the hash-based pseudo-embedding function from `historyAnalyzer.ts` (lines 32-81). Same 1536-dimension vectors, same normalization. This is a placeholder approach that works for similarity ranking; a real embedding API can replace it later.

2. `indexDocument(params: { organizationId: string; title: string; content: string; category?: string; tags?: string[]; sourceUrl?: string }): Promise<string>` - Embed document content (chunk if >500 words: split into 500-word chunks with 50-word overlap, embed each chunk as separate row with same title prefix). Insert into knowledgeBaseDocuments. Return document ID.

3. `searchKnowledgeBase(params: { organizationId: string; query: string; limit?: number; timeout?: number }): Promise<Array<{ id: string; title: string; content: string; similarity: number }>>` - Embed query text, then run pgvector cosine similarity search:
   ```sql
   SELECT id, title, content,
     1 - (embedding <=> $queryEmbedding::vector) AS similarity
   FROM knowledge_base_documents
   WHERE organization_id = $orgId AND is_active = true
   ORDER BY embedding <=> $queryEmbedding::vector
   LIMIT $limit
   ```
   Default limit: 3. Apply timeout (default 500ms) using Promise.race with a timeout promise. On timeout, return empty array (don't block suggestion generation).

4. `getDocuments(organizationId: string)` - List all documents for admin UI, ordered by updatedAt desc

5. `getDocumentById(id: string, organizationId: string)` - Single document with org check

6. `deleteDocument(id: string, organizationId: string)` - Soft delete (set isActive=false) or hard delete

7. `updateDocument(id: string, organizationId: string, data: Partial<{ title: string; content: string; category: string; tags: string[]; isActive: boolean }>)` - Update document. If content changes, re-embed (queue a background job).

Export all functions from services/index.ts.
  </action>
  <verify>Run `npx tsc --noEmit` in apps/slack-backend. Grep knowledge-base.ts for searchKnowledgeBase and indexDocument.</verify>
  <done>Knowledge base service embeds documents, performs semantic search with 500ms timeout, and provides CRUD operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create background indexer job and API routes</name>
  <files>apps/slack-backend/src/jobs/knowledge-base-indexer.ts, apps/slack-backend/src/jobs/types.ts, apps/slack-backend/src/jobs/queues.ts, apps/slack-backend/src/jobs/workers.ts, apps/web-portal/app/api/admin/knowledge-base/route.ts, apps/web-portal/app/api/admin/knowledge-base/[id]/route.ts</files>
  <action>
**Background Job:**

Add to `jobs/types.ts`:
```typescript
export interface KBIndexJobData {
  organizationId: string;
  title: string;
  content: string;
  category?: string;
  tags?: string[];
  sourceUrl?: string;
}
export interface KBIndexJobResult {
  documentId: string;
  chunksCreated: number;
}
```

Add to `jobs/queues.ts`: Create `kbIndexQueue` queue named 'kb-indexer' with 3 attempts, exponential backoff.

Add to `jobs/workers.ts`: Create `kbIndexWorker` that calls `indexDocument()` from knowledge-base service. Concurrency: 2. Add error/completed/failed event listeners following existing pattern. Add start/stop to startWorkers/stopWorkers.

**API Routes:**

`apps/web-portal/app/api/admin/knowledge-base/route.ts`:
- GET: List documents for admin's org from database
- POST: Accept { title, content, category?, tags?, sourceUrl? }. Validate with Zod (title required, content required min 10 chars). Queue a KB index job for async embedding. Insert a placeholder row (with empty embedding) that gets updated by the worker, OR have the API route call the service directly for small docs (<2000 chars) and queue for large ones.

`apps/web-portal/app/api/admin/knowledge-base/[id]/route.ts`:
- PUT: Update document metadata (title, category, tags, isActive). If content changes, re-index.
- DELETE: Delete document (set isActive=false or hard delete)
  </action>
  <verify>Run `npx tsc --noEmit` in both workspaces. Grep workers.ts for 'kbIndexWorker' and confirm it appears in both startWorkers and stopWorkers functions. Grep queues.ts for 'kbIndexQueue'.</verify>
  <done>Background indexer job processes document embeddings asynchronously. API routes provide CRUD for knowledge base documents with Zod validation.</done>
</task>

<task type="auto">
  <name>Task 3: Create admin knowledge base page</name>
  <files>apps/web-portal/app/admin/knowledge-base/page.tsx</files>
  <action>
**Admin Page: `apps/web-portal/app/admin/knowledge-base/page.tsx`**
Server component page following admin pattern (reference admin/organizations/page.tsx):
- Header: "Knowledge Base" with description "Upload product and service documentation for AI-powered suggestions"
- "Add Document" button
- Document list as Cards:
  - Title, category badge, tags as secondary badges
  - Content preview (first 200 chars with ellipsis)
  - sourceUrl link if present
  - lastReviewedAt timestamp
  - isActive toggle
  - Edit and Delete buttons
- Create/Edit dialog (client component section with 'use client' boundary):
  - title: text input (required)
  - content: textarea (required, show char/word count)
  - category: select or text input (predefined: "product_features", "sla_policies", "troubleshooting", "faq", "other")
  - tags: tag input (comma-separated)
  - sourceUrl: URL input
- Show "Indexing..." indicator while document is being processed (embedding = empty means pending)
- Form submits via fetch to /api/admin/knowledge-base (POST for create). Edit/delete via /api/admin/knowledge-base/[id].
- Use shadcn/ui Card, Badge, Button, Input, Textarea, Dialog, Select components
  </action>
  <verify>Run `npx tsc --noEmit` in apps/web-portal. Grep page.tsx for 'requireAdmin' and 'knowledge-base'. Navigate to /admin/knowledge-base page (visual check if dev server running).</verify>
  <done>Admin page shows document list with management actions. Create/edit/delete operations work via API routes from Task 2.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles in both workspaces
2. searchKnowledgeBase has timeout mechanism (500ms default)
3. indexDocument handles chunking for long documents
4. Background worker processes indexing jobs
5. Admin page shows document list with management actions
</verification>

<success_criteria>
- Documents are embedded and searchable via pgvector cosine similarity
- Search has 500ms timeout to prevent blocking suggestion generation
- Admin can upload, edit, delete knowledge base documents
- Large documents are chunked into 500-word segments with overlap
- End-to-end: Admin uploads a document via the page, background job indexes it, and searchKnowledgeBase returns it for a relevant query
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-context-support/12-05-SUMMARY.md`
</output>
