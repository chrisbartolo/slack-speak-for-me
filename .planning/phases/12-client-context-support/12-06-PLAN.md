---
phase: 12-client-context-support
plan: 06
type: execute
wave: 3
depends_on: ["12-02", "12-03", "12-04", "12-05"]
files_modified:
  - apps/slack-backend/src/services/ai.ts
autonomous: true

must_haves:
  truths:
    - "AI uses client profile context (company name, services, contract) when generating suggestions for client contacts"
    - "AI applies org brand voice guidelines when generating suggestions for client conversations"
    - "AI detects tension/frustration and switches to de-escalation mode with empathetic response guidance"
    - "AI references knowledge base documents when relevant to the conversation"
    - "Client context features are non-blocking - failures fall back to standard suggestion generation"
  artifacts:
    - path: "apps/slack-backend/src/services/ai.ts"
      provides: "Enhanced generateSuggestion with client context, brand voice, sentiment, and KB integration"
      contains: "client_context"
  key_links:
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/client-profiles.ts"
      via: "getClientContactBySlackUserId"
      pattern: "getClientContactBySlackUserId"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/brand-voice.ts"
      via: "getBrandVoiceContext"
      pattern: "getBrandVoiceContext"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/sentiment-detector.ts"
      via: "analyzeSentiment"
      pattern: "analyzeSentiment"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/knowledge-base.ts"
      via: "searchKnowledgeBase"
      pattern: "searchKnowledgeBase"
---

<objective>
Wire client context, brand voice, sentiment detection, and knowledge base into the AI suggestion generation pipeline.

Purpose: This is the critical integration plan that connects all Phase 12 services into the existing AI generation flow. When a client contact is detected in the conversation, the AI receives enriched context including client profile, brand voice guidelines, sentiment-based de-escalation instructions, and relevant knowledge base documents.
Output: Enhanced ai.ts that conditionally enriches prompts with client context when appropriate.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-client-context-support/12-02-SUMMARY.md
@.planning/phases/12-client-context-support/12-03-SUMMARY.md
@.planning/phases/12-client-context-support/12-04-SUMMARY.md
@.planning/phases/12-client-context-support/12-05-SUMMARY.md
@apps/slack-backend/src/services/ai.ts
@apps/slack-backend/src/services/client-profiles.ts
@apps/slack-backend/src/services/brand-voice.ts
@apps/slack-backend/src/services/sentiment-detector.ts
@apps/slack-backend/src/services/knowledge-base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate client context into generateSuggestion</name>
  <files>apps/slack-backend/src/services/ai.ts</files>
  <action>
Modify `generateSuggestion` in ai.ts to integrate Phase 12 services. All new logic is ADDITIVE -- do NOT change existing behavior for non-client conversations.

**Import new services at top:**
```typescript
import { getClientContactBySlackUserId } from './client-profiles.js';
import { getBrandVoiceContext } from './brand-voice.js';
import { analyzeSentiment, type SentimentAnalysis } from './sentiment-detector.js';
import { searchKnowledgeBase } from './knowledge-base.js';
```

**Add new logic AFTER the existing personContextMap section** (around line 200, after `additionalContextSection` is built from conversationContext and personContext). The key insertion point is after the existing `additionalContextSection` variable is built but before the `userPrompt` is constructed.

Add these steps:

1. **Detect client contact:**
   ```typescript
   // Check if any conversation participant is a client contact
   let clientContext = '';
   let sentimentResult: SentimentAnalysis | null = null;

   // Get organizationId from workspace
   const [workspace] = await db
     .select({ organizationId: workspaces.organizationId })
     .from(workspaces)
     .where(eq(workspaces.id, context.workspaceId))
     .limit(1);

   const organizationId = workspace?.organizationId;

   if (organizationId) {
     // Check participants for client contacts
     const clientContactResult = await getClientContactBySlackUserId(
       context.workspaceId,
       // Check the trigger message sender first (most likely the client)
       context.contextMessages.length > 0
         ? context.contextMessages[context.contextMessages.length - 1].userId
         : ''
     ).catch(err => {
       logger.warn({ error: err }, 'Failed to check client contact');
       return null;
     });
   ```

2. **If client contact found, load client profile context:**
   ```typescript
   if (clientContactResult) {
     const clientProfile = await db.query... // Get profile by clientContactResult.clientProfileId

     if (clientProfile) {
       clientContext += `\n<client_context>
   This conversation involves a client: ${prepareForAI(clientProfile.companyName).sanitized}
   ${clientProfile.servicesProvided?.length ? `Services provided: ${clientProfile.servicesProvided.join(', ')}` : ''}
   ${clientProfile.contractDetails ? `Contract context: ${prepareForAI(clientProfile.contractDetails).sanitized}` : ''}
   Relationship status: ${clientProfile.relationshipStatus || 'active'}
   Your response should be professional, solution-focused, and aligned with service commitments.
   </client_context>\n`;
     }
   ```

3. **Load brand voice:**
   ```typescript
     const brandVoice = await getBrandVoiceContext({
       organizationId,
       conversationType: 'client',
     }).catch(err => {
       logger.warn({ error: err }, 'Failed to load brand voice');
       return '';
     });

     if (brandVoice) {
       clientContext += brandVoice;
     }
   ```

4. **Analyze sentiment:**
   ```typescript
     sentimentResult = await analyzeSentiment({
       conversationMessages: context.contextMessages,
       targetMessage: context.triggerMessage,
     }).catch(err => {
       logger.warn({ error: err }, 'Sentiment analysis failed');
       return null;
     });

     if (sentimentResult && (sentimentResult.riskLevel === 'high' || sentimentResult.riskLevel === 'critical')) {
       clientContext += `\n<de_escalation_mode>
   ALERT: Client message shows ${sentimentResult.tone} tone (risk: ${sentimentResult.riskLevel.toUpperCase()})
   Indicators: ${sentimentResult.indicators.join(', ')}

   Your response MUST:
   1. Acknowledge their concern explicitly
   2. Show empathy ("I understand this is frustrating...")
   3. Take ownership (no blame/excuses)
   4. Provide clear next steps with timeline
   5. Maintain calm, professional tone

   Avoid: Defensive language, technical jargon, dismissing concerns, promising what you can't deliver
   </de_escalation_mode>\n`;
     }
   ```

5. **Search knowledge base (with 500ms timeout):**
   ```typescript
     const kbResults = await searchKnowledgeBase({
       organizationId,
       query: context.triggerMessage,
       limit: 3,
       timeout: 500,
     }).catch(err => {
       logger.warn({ error: err }, 'Knowledge base search failed');
       return [];
     });

     if (kbResults.length > 0 && kbResults[0].similarity > 0.7) {
       clientContext += `\n<knowledge_base>
   Relevant product/service documentation:
   ${kbResults.map((doc, idx) => `[${idx + 1}] ${doc.title} (${(doc.similarity * 100).toFixed(0)}% relevant)\n${doc.content.slice(0, 400)}...`).join('\n\n')}
   Reference this information when appropriate to provide accurate, helpful responses.
   </knowledge_base>\n`;
     }
   } // end if clientContactResult
   } // end if organizationId
   ```

6. **Append clientContext to additionalContextSection:**
   ```typescript
   additionalContextSection += clientContext;
   ```

7. **Add logging for client context features:**
   In the existing logger.info call near the end of generateSuggestion, add:
   ```typescript
   hasClientContext: !!clientContext,
   sentimentRisk: sentimentResult?.riskLevel || 'none',
   kbDocsRetrieved: kbResults?.length || 0,
   ```

**Critical design principles:**
- EVERY external call is wrapped in `.catch()` that returns null/empty -- client context features NEVER break standard suggestion generation
- All user-provided text from client profiles and brand voice uses `prepareForAI()` for sanitization
- Knowledge base search has explicit 500ms timeout
- Sentiment analysis result is used for both prompt enrichment AND logging (for escalation monitoring in Plan 07)
- The existing flow for non-client conversations remains UNCHANGED
  </action>
  <verify>Run `npx tsc --noEmit` in apps/slack-backend. Grep ai.ts for 'client_context', 'brand_voice', 'de_escalation_mode', 'knowledge_base' XML tags. Grep for '.catch(' to verify all external calls have error handling.</verify>
  <done>generateSuggestion enriches prompts with client profile, brand voice, de-escalation instructions, and knowledge base context when a client contact is detected. All features are non-blocking with graceful fallbacks.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. ai.ts imports all 4 new services
3. Every new external call has .catch() error handling
4. prepareForAI used for all client-provided text
5. Non-client conversations work identically to before (no regression)
6. Knowledge base search has timeout
7. Logging includes client context metadata
</verification>

<success_criteria>
- Client conversations get enriched AI prompts with client profile + brand voice + sentiment + KB context
- Non-client conversations work exactly as before (zero regression)
- All new features fail gracefully (never break suggestion generation)
- Sentiment risk level logged for escalation monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-context-support/12-06-SUMMARY.md`
</output>
