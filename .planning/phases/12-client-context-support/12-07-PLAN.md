---
phase: 12-client-context-support
plan: 07
type: execute
wave: 4
depends_on: ["12-06"]
files_modified:
  - apps/slack-backend/src/services/escalation-monitor.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/jobs/escalation-scanner.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/jobs/schedulers.ts
  - apps/web-portal/app/admin/escalations/page.tsx
  - apps/web-portal/app/api/admin/escalations/route.ts
  - apps/web-portal/app/api/admin/escalations/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Escalation alerts are created when sentiment analysis detects high/critical risk in client conversations"
    - "Org admins receive Slack DM notifications for escalation alerts"
    - "Admin can view, acknowledge, resolve, or mark alerts as false positive"
    - "4-hour cooldown prevents re-alerting on same channel"
    - "Background scanner runs periodically to detect escalations"
  artifacts:
    - path: "apps/slack-backend/src/services/escalation-monitor.ts"
      provides: "Escalation alert creation and notification"
      exports: ["triggerEscalationAlert", "acknowledgeAlert", "resolveAlert"]
    - path: "apps/slack-backend/src/jobs/escalation-scanner.ts"
      provides: "Background job scanning recent client conversations for escalation signals"
    - path: "apps/web-portal/app/admin/escalations/page.tsx"
      provides: "Admin dashboard for viewing and managing escalation alerts"
  key_links:
    - from: "apps/slack-backend/src/services/escalation-monitor.ts"
      to: "packages/database/src/schema.ts"
      via: "insert into escalationAlerts"
      pattern: "escalationAlerts"
    - from: "apps/slack-backend/src/services/escalation-monitor.ts"
      to: "@slack/web-api"
      via: "Slack DM for admin notifications"
      pattern: "chat\\.postMessage"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/escalation-monitor.ts"
      via: "triggerEscalationAlert on critical sentiment"
      pattern: "triggerEscalationAlert"
---

<objective>
Build escalation monitoring system with alert creation, admin notifications, background scanning, and management UI.

Purpose: When client messages show high/critical risk levels, org admins need to be alerted immediately so they can intervene before disputes escalate. The system creates alerts, sends Slack DMs to admins, and provides a management dashboard.
Output: Escalation monitor service + background scanner job + admin alerts page + real-time integration with AI service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-client-context-support/12-06-SUMMARY.md
@apps/slack-backend/src/services/ai.ts
@apps/slack-backend/src/services/sentiment-detector.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/schedulers.ts
@apps/slack-backend/src/jobs/types.ts
@apps/web-portal/lib/auth/admin.ts
@apps/web-portal/app/admin/organizations/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation monitor service and wire into AI</name>
  <files>apps/slack-backend/src/services/escalation-monitor.ts, apps/slack-backend/src/services/index.ts, apps/slack-backend/src/services/ai.ts</files>
  <action>
Create `apps/slack-backend/src/services/escalation-monitor.ts`:

1. `triggerEscalationAlert(params: { organizationId: string; workspaceId: string; clientProfileId?: string; channelId: string; messageTs: string; sentiment: SentimentAnalysis })` - Creates escalation alert and notifies admins:
   - Check for existing open alert on same channel within last 4 hours (cooldown). Use SQL: `WHERE channel_id = $channelId AND status = 'open' AND created_at > NOW() - INTERVAL '4 hours'`. If exists, skip (return existing alert ID).
   - Insert into escalationAlerts table with: alertType='tension_detected', severity based on sentiment.riskLevel (critical->critical, high->high), summary=`Client message shows ${sentiment.tone} tone`, suggestedAction based on severity.
   - Get org admins: query users table where workspaceId matches AND role='admin'
   - For each admin, send Slack DM notification:
     ```
     :rotating_light: *Escalation Alert*
     *Severity:* {severity}
     *Channel:* <#{channelId}>
     *Risk:* {sentiment.tone} (confidence: {sentiment.confidence})
     *Indicators:* {sentiment.indicators.join(', ')}
     *Suggested Action:* {suggestedAction}
     ```
   - Use the bot token from installations table to send DMs. Decrypt with getEncryptionKey().
   - Wrap everything in try/catch -- escalation alerts should NEVER crash suggestion generation

2. `acknowledgeAlert(alertId: string, organizationId: string, acknowledgedBy: string)` - Update status to 'acknowledged', set acknowledgedBy and acknowledgedAt

3. `resolveAlert(alertId: string, organizationId: string, resolvedBy: string, resolutionNotes?: string)` - Update status to 'resolved', set resolvedAt and resolutionNotes

4. `markFalsePositive(alertId: string, organizationId: string)` - Update status to 'false_positive'

5. `getEscalationAlerts(organizationId: string, filters?: { status?: string; severity?: string; limit?: number })` - List alerts for admin UI, ordered by createdAt desc. Support filtering by status and severity.

6. `getAlertStats(organizationId: string)` - Return counts: { open, acknowledged, resolved, falsePositive, totalThisMonth }

**Wire into ai.ts:**
In the generateSuggestion function, after the sentiment analysis section (added in Plan 06), add a call to triggerEscalationAlert when sentiment.riskLevel is 'critical':

```typescript
if (sentimentResult?.riskLevel === 'critical' && organizationId) {
  triggerEscalationAlert({
    organizationId,
    workspaceId: context.workspaceId,
    clientProfileId: clientContactResult?.clientProfileId,
    channelId: context.channelId || '',
    messageTs: context.contextMessages[context.contextMessages.length - 1]?.ts || '',
    sentiment: sentimentResult,
  }).catch(err => {
    logger.warn({ error: err }, 'Failed to trigger escalation alert');
  });
}
```

Note: Fire-and-forget pattern (.catch) -- never block suggestion generation.

Export triggerEscalationAlert, acknowledgeAlert, resolveAlert, markFalsePositive, getEscalationAlerts, getAlertStats from services/index.ts.
  </action>
  <verify>Run `npx tsc --noEmit` in apps/slack-backend. Grep escalation-monitor.ts for 'triggerEscalationAlert' and '4 hours' (cooldown). Grep ai.ts for 'triggerEscalationAlert'.</verify>
  <done>Escalation alerts are created on critical sentiment, admins get Slack DM notifications, 4-hour cooldown prevents alert fatigue. AI service triggers alerts as fire-and-forget.</done>
</task>

<task type="auto">
  <name>Task 2: Create background scanner job and admin escalation page</name>
  <files>apps/slack-backend/src/jobs/escalation-scanner.ts, apps/slack-backend/src/jobs/types.ts, apps/slack-backend/src/jobs/queues.ts, apps/slack-backend/src/jobs/workers.ts, apps/slack-backend/src/jobs/schedulers.ts, apps/web-portal/app/api/admin/escalations/route.ts, apps/web-portal/app/api/admin/escalations/[id]/route.ts, apps/web-portal/app/admin/escalations/page.tsx</files>
  <action>
**Background Scanner Job:**

Add to `jobs/types.ts`:
```typescript
export interface EscalationScanJobData {
  triggeredBy: 'scheduler' | 'manual';
}
export interface EscalationScanJobResult {
  organizationsScanned: number;
  alertsCreated: number;
}
```

Add to `jobs/queues.ts`: Create `escalationScanQueue` queue named 'escalation-scanner' with 2 attempts.

Create `jobs/escalation-scanner.ts` with function `scanForEscalations()`:
- Query organizations with active subscriptions
- For each org, find client contacts
- For each client contact, check recent messages in watched conversations (last 4 hours)
- NOTE: The app already stores conversation context. Use the existing message context retrieval to get recent messages for channels with client contacts.
- Run analyzeSentiment on recent conversation contexts
- If high/critical, call triggerEscalationAlert (which handles dedup via cooldown)
- Return count of alerts created

Add worker to `jobs/workers.ts`: Create `escalationScanWorker` processing 'escalation-scanner' queue. Concurrency: 1. Add to startWorkers/stopWorkers.

Add scheduler to `jobs/schedulers.ts`: Schedule escalation scan to run every 15 minutes using BullMQ repeatable job pattern. Follow the existing scheduler pattern (e.g., usage reporter scheduler).

**API Routes:**

`apps/web-portal/app/api/admin/escalations/route.ts`:
- GET: List escalation alerts for admin's org. Accept query params: status, severity, limit (default 50). Use requireAdmin() for auth.

`apps/web-portal/app/api/admin/escalations/[id]/route.ts`:
- PUT: Update alert status. Accept body: { status: 'acknowledged' | 'resolved' | 'false_positive', resolutionNotes?: string }. Validate org ownership.

**Admin Page: `apps/web-portal/app/admin/escalations/page.tsx`**
Server component page:
- Header: "Escalation Alerts" with description "Monitor and manage client communication risks"
- Stats row: Open count, Acknowledged count, Resolved this month, False positive rate
- Filter bar: Status select (all, open, acknowledged, resolved, false_positive), Severity select (all, medium, high, critical)
- Alert list as Cards:
  - Severity badge with color (critical=red/destructive, high=yellow/warning, medium=blue/default)
  - Summary text
  - Channel link (use Slack deep link: `slack://channel?team={teamId}&id={channelId}`)
  - Sentiment indicators shown as small tags
  - Suggested action text
  - Client name (if clientProfileId linked)
  - Timestamp with relative time ("2 hours ago")
  - Action buttons based on status:
    - open: Acknowledge button, Resolve button, False Positive button
    - acknowledged: Resolve button (with notes textarea), False Positive button
    - resolved: Read-only with resolution notes shown
    - false_positive: Read-only with "Marked as false positive" label
- Use shadcn/ui Card, Badge, Button, Select, Textarea components
- Client-component form section for status updates (use 'use client' boundary)
  </action>
  <verify>Run `npx tsc --noEmit` in both workspaces. Grep workers.ts for 'escalation' worker. Grep schedulers.ts for escalation scheduler.</verify>
  <done>Background scanner runs every 15 minutes, creates alerts for high-risk conversations. Admin page shows alerts with severity badges, filtering, and status management actions.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles in both workspaces
2. Escalation scanner scheduled every 15 minutes
3. 4-hour cooldown prevents duplicate alerts per channel
4. Admin page shows filtered alert list with status management
5. Slack DM notifications sent to org admins
6. ai.ts triggers alerts on critical sentiment (fire-and-forget)
</verification>

<success_criteria>
- Critical sentiment triggers immediate escalation alert + Slack DM to admins
- Background scanner catches escalations that happen outside suggestion generation
- Admin can acknowledge, resolve, or mark alerts as false positive
- Alert stats help track team responsiveness to escalations
- 4-hour cooldown prevents alert fatigue
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-context-support/12-07-SUMMARY.md`
</output>
