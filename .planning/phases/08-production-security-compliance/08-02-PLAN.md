---
phase: 08-production-security-compliance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/schema.ts
  - apps/slack-backend/src/services/audit-logger.ts
  - apps/slack-backend/src/services/index.ts
  - apps/web-portal/lib/audit.ts
autonomous: true

must_haves:
  truths:
    - "Audit log entries can be written to database"
    - "Audit logs capture user ID, workspace ID, action, resource, timestamp"
    - "Audit logging is non-blocking (fire and forget)"
    - "Failed audit writes don't break application flow"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "auditLogs table definition"
      contains: "auditLogs = pgTable"
    - path: "apps/slack-backend/src/services/audit-logger.ts"
      provides: "Audit logging service for slack-backend"
      exports: ["logAuditEvent", "auditLogin", "auditDataExport", "auditDataDeletion"]
    - path: "apps/web-portal/lib/audit.ts"
      provides: "Audit logging for web-portal"
      exports: ["logAuditEvent"]
  key_links:
    - from: "apps/slack-backend/src/services/audit-logger.ts"
      to: "packages/database/src/schema.ts"
      via: "auditLogs table import"
      pattern: "auditLogs"
---

<objective>
Create audit logging infrastructure for tracking security-relevant events like logins, data exports, and deletions.

Purpose: Audit logs are essential for security compliance, incident investigation, and GDPR accountability. They track who did what and when, providing a tamper-evident record of security-relevant actions.

Output: auditLogs table schema, audit logger services for both slack-backend and web-portal
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-production-security-compliance/08-RESEARCH.md
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auditLogs table to database schema</name>
  <files>packages/database/src/schema.ts</files>
  <action>
Add the auditLogs table to schema.ts:

```typescript
export const auditLogs = pgTable('audit_logs', {
  id: uuid('id').primaryKey().defaultRandom(),

  // Who
  userId: text('user_id'), // Slack user ID (may be null for system events)
  workspaceId: uuid('workspace_id').references(() => workspaces.id),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),

  // What
  action: text('action').notNull(), // 'login', 'logout', 'data_export', 'data_delete', etc.
  resource: text('resource'), // 'user', 'workspace', 'subscription', etc.
  resourceId: text('resource_id'), // UUID or ID of affected resource

  // Details
  details: jsonb('details').$type<Record<string, unknown>>(),
  previousValue: jsonb('previous_value'),
  newValue: jsonb('new_value'),

  // When
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  workspaceIdx: index('audit_logs_workspace_idx').on(table.workspaceId),
  userIdx: index('audit_logs_user_idx').on(table.userId),
  actionIdx: index('audit_logs_action_idx').on(table.action),
  createdAtIdx: index('audit_logs_created_at_idx').on(table.createdAt),
}));

// Type-safe audit action union
export type AuditAction =
  | 'login'
  | 'logout'
  | 'data_export_requested'
  | 'data_export_completed'
  | 'data_delete_requested'
  | 'data_delete_completed'
  | 'subscription_created'
  | 'subscription_cancelled'
  | 'settings_changed'
  | 'oauth_connected'
  | 'oauth_disconnected'
  | 'admin_action';
```

Push schema changes:
```bash
npm run db:push --workspace=@slack-speak-for-me/database
```
  </action>
  <verify>
Run `npm run db:push --workspace=@slack-speak-for-me/database` - should create audit_logs table.
TypeScript compiles without errors.
  </verify>
  <done>
auditLogs table exists in schema with all required columns and indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit logger service for slack-backend</name>
  <files>
apps/slack-backend/src/services/audit-logger.ts
apps/slack-backend/src/services/index.ts
  </files>
  <action>
Create apps/slack-backend/src/services/audit-logger.ts:

1. Import db from database package and auditLogs table
2. Define AuditLogEntry interface with:
   - action: AuditAction (required)
   - userId?: string
   - workspaceId?: string
   - ipAddress?: string
   - userAgent?: string
   - resource?: string
   - resourceId?: string
   - details?: Record<string, unknown>
   - previousValue?: unknown
   - newValue?: unknown

3. Create logAuditEvent async function:
   - Fire-and-forget pattern (don't await, catch errors internally)
   - Insert into auditLogs table
   - Log errors to pino logger but don't throw
   - This ensures audit failures never break application flow

4. Create convenience functions:
   - auditLogin(userId, workspaceId, ip): logs 'login' action
   - auditLogout(userId, workspaceId): logs 'logout' action
   - auditDataExport(userId, workspaceId): logs 'data_export_requested'
   - auditDataDeletion(userId, workspaceId): logs 'data_delete_requested'
   - auditSettingsChange(userId, workspaceId, setting, prevValue, newValue): logs 'settings_changed'

Update apps/slack-backend/src/services/index.ts to export all audit functions.
  </action>
  <verify>
TypeScript compiles without errors.
Exports are available: `import { logAuditEvent, auditLogin } from './services/index.js'`
  </verify>
  <done>
Audit logger service exists with fire-and-forget pattern and convenience functions for common audit events.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create audit logger for web-portal</name>
  <files>apps/web-portal/lib/audit.ts</files>
  <action>
Create apps/web-portal/lib/audit.ts:

1. Import db from '@/lib/db' and auditLogs from '@slack-speak/database'
2. Define same AuditLogEntry interface
3. Create logAuditEvent function with fire-and-forget pattern:
   - Use .execute().catch() pattern
   - Don't throw errors - audit failures shouldn't break user flows
   - Log errors to console.error for debugging

4. Create convenience functions mirroring slack-backend:
   - auditLogin(userId, workspaceId, ip)
   - auditDataExport(userId, workspaceId)
   - auditDataDeletion(userId, workspaceId)

The web-portal version is simpler since it doesn't have the pino logger, but follows the same non-blocking pattern.
  </action>
  <verify>
TypeScript compiles without errors.
File exports logAuditEvent and convenience functions.
  </verify>
  <done>
Web-portal has its own audit logger that mirrors slack-backend's API, enabling audit logging from API routes.
  </done>
</task>

</tasks>

<verification>
1. Build both workspaces: `npm run build --workspaces --if-present` - no errors
2. Schema pushed to database with audit_logs table
3. Both audit logger services export consistent APIs
</verification>

<success_criteria>
- auditLogs table created in database with indexes
- Audit logger services exist in both slack-backend and web-portal
- Logging is fire-and-forget (non-blocking)
- TypeScript compiles without errors
- Schema push succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-production-security-compliance/08-02-SUMMARY.md`
</output>
