---
phase: 06-production-polish-and-admin
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/schema.ts
  - apps/web-portal/lib/auth/admin.ts
  - apps/web-portal/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Database has organizations table with billing fields"
    - "Users table has role column for admin detection"
    - "Admin middleware prevents non-admins from accessing /admin routes"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "organizations table and user role column"
      contains: "organizations"
    - path: "apps/web-portal/lib/auth/admin.ts"
      provides: "Admin auth middleware"
      exports: ["requireAdmin"]
  key_links:
    - from: "apps/web-portal/lib/auth/admin.ts"
      to: "packages/database/src/schema.ts"
      via: "user role check"
      pattern: "role.*admin"
---

<objective>
Create admin foundation with organization schema and auth middleware

Purpose: Admin panel needs a foundation: (1) organizations table to group workspaces for billing, (2) user roles to control access, and (3) middleware to protect admin routes. This plan lays the groundwork for org/user/billing management.

Output: Database schema with organizations and roles, plus admin auth middleware.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-production-polish-and-admin/06-RESEARCH.md
@packages/database/src/schema.ts
@apps/web-portal/lib/auth/dal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add organizations table and user role column</name>
  <files>packages/database/src/schema.ts</files>
  <action>
  Add organizations table and update users table:

  1. Add organizations table after workspaces:
     ```typescript
     export const organizations = pgTable('organizations', {
       id: uuid('id').primaryKey().defaultRandom(),
       name: text('name').notNull(),
       slug: text('slug').notNull().unique(), // URL-friendly identifier

       // Billing fields
       stripeCustomerId: text('stripe_customer_id'),
       stripeSubscriptionId: text('stripe_subscription_id'),
       subscriptionStatus: text('subscription_status'), // 'active' | 'past_due' | 'canceled' | 'trialing'
       planId: text('plan_id'), // 'free' | 'pro' | 'enterprise'
       seatCount: integer('seat_count').default(1),
       billingEmail: text('billing_email'),

       createdAt: timestamp('created_at').defaultNow(),
       updatedAt: timestamp('updated_at').defaultNow(),
     }, (table) => ({
       slugIdx: uniqueIndex('organizations_slug_idx').on(table.slug),
       stripeCustomerIdx: index('organizations_stripe_customer_idx').on(table.stripeCustomerId),
     }));
     ```

  2. Add organization reference to workspaces:
     ```typescript
     export const workspaces = pgTable('workspaces', {
       id: uuid('id').primaryKey().defaultRandom(),
       teamId: text('team_id').notNull().unique(),
       enterpriseId: text('enterprise_id'),
       name: text('name'),
       organizationId: uuid('organization_id').references(() => organizations.id), // NEW
       createdAt: timestamp('created_at').defaultNow(),
       updatedAt: timestamp('updated_at').defaultNow(),
     });
     ```

  3. Add role column to users table:
     ```typescript
     export const users = pgTable('users', {
       id: uuid('id').primaryKey().defaultRandom(),
       workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
       slackUserId: text('slack_user_id').notNull(),
       email: text('email'),
       role: text('role').default('member'), // NEW: 'admin' | 'member' | 'viewer'
       createdAt: timestamp('created_at').defaultNow(),
     }, (table) => ({
       workspaceIdx: index('users_workspace_id_idx').on(table.workspaceId),
       slackUserIdx: index('users_slack_user_id_idx').on(table.slackUserId),
       roleIdx: index('users_role_idx').on(table.role), // NEW
     }));
     ```

  After changes, run: `npm run db:push --workspace=@slack-speak-for-me/database`
  </action>
  <verify>
  - Schema compiles: `npm run build --workspace=@slack-speak-for-me/database`
  - Migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
  </verify>
  <done>
  Database has organizations table with billing fields, workspaces link to orgs, users have role column
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin auth middleware</name>
  <files>apps/web-portal/lib/auth/admin.ts</files>
  <action>
  Create admin authentication middleware:

  ```typescript
  import 'server-only';
  import { redirect } from 'next/navigation';
  import { verifySession } from './dal';
  import { db, schema } from '../db';
  import { and, eq } from 'drizzle-orm';

  const { users, workspaces, organizations } = schema;

  export interface AdminSession {
    userId: string;
    workspaceId: string;
    organizationId?: string;
    role: 'admin' | 'member' | 'viewer';
  }

  /**
   * Verify user has admin role
   * Redirects to dashboard if not admin
   */
  export async function requireAdmin(): Promise<AdminSession> {
    const session = await verifySession();

    // Query user with role and org info
    const [user] = await db
      .select({
        role: users.role,
        organizationId: workspaces.organizationId,
      })
      .from(users)
      .innerJoin(workspaces, eq(users.workspaceId, workspaces.id))
      .where(
        and(
          eq(users.workspaceId, session.workspaceId),
          eq(users.slackUserId, session.userId)
        )
      )
      .limit(1);

    if (!user || user.role !== 'admin') {
      redirect('/dashboard');
    }

    return {
      userId: session.userId,
      workspaceId: session.workspaceId,
      organizationId: user.organizationId ?? undefined,
      role: user.role as 'admin',
    };
  }

  /**
   * Check if user is admin (non-blocking)
   */
  export async function isAdmin(): Promise<boolean> {
    try {
      const session = await verifySession();

      const [user] = await db
        .select({ role: users.role })
        .from(users)
        .where(
          and(
            eq(users.workspaceId, session.workspaceId),
            eq(users.slackUserId, session.userId)
          )
        )
        .limit(1);

      return user?.role === 'admin';
    } catch {
      return false;
    }
  }

  /**
   * Get user's organization with billing info
   */
  export async function getOrganization(organizationId: string) {
    const [org] = await db
      .select()
      .from(organizations)
      .where(eq(organizations.id, organizationId))
      .limit(1);

    return org ?? null;
  }
  ```

  Export from lib/auth/index.ts if one exists.
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=@slack-speak-for-me/web-portal`
  - No TypeScript errors
  </verify>
  <done>
  requireAdmin middleware blocks non-admins from admin routes
  </done>
</task>

<task type="auto">
  <name>Task 3: Update middleware to protect /admin routes</name>
  <files>apps/web-portal/middleware.ts</files>
  <action>
  Update Next.js middleware to handle /admin routes:

  1. Find the publicRoutes or matcher configuration
  2. Ensure /admin/* routes require authentication (not public)

  The route protection works as follows:
  - Middleware checks for valid session on protected routes
  - Admin pages call requireAdmin() server-side for role check
  - Non-admins are redirected to /dashboard

  If middleware currently allows all authenticated users:
  ```typescript
  // No changes needed - admin check happens at page level via requireAdmin()
  // Just ensure /admin is not in publicRoutes
  const publicRoutes = [
    '/',
    '/login',
    '/callback',
    '/install',
    '/install/success',
    '/api/health',
    // NOT /admin - should require auth
  ];
  ```

  This two-layer approach (middleware for auth, page for role) is the standard Next.js pattern.
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=@slack-speak-for-me/web-portal`
  - /admin routes are not in publicRoutes
  </verify>
  <done>
  /admin routes require authentication, role check happens at page level
  </done>
</task>

</tasks>

<verification>
1. Database migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
2. Build succeeds: `npm run build --workspace=@slack-speak-for-me/web-portal`
3. requireAdmin function exists and can be imported
4. /admin not in publicRoutes
</verification>

<success_criteria>
- organizations table exists with billing fields
- users table has role column
- workspaces table has organizationId reference
- requireAdmin middleware redirects non-admins
- isAdmin helper function available for conditional UI
</success_criteria>

<output>
After completion, create `.planning/phases/06-production-polish-and-admin/06-07-SUMMARY.md`
</output>
