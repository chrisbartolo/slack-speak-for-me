---
phase: 06-production-polish-and-admin
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/slack-backend/src/handlers/events/message-reply.ts
  - apps/slack-backend/src/handlers/events/message-reply.test.ts
  - apps/slack-backend/src/handlers/commands/watch.ts
  - apps/slack-backend/src/services/watch.ts
  - packages/database/src/schema.ts
autonomous: true

must_haves:
  truths:
    - "Bot does not respond to user's own messages"
    - "/watch works correctly in DM conversations"
    - "DM messages from others trigger suggestions when /watch is active"
  artifacts:
    - path: "apps/slack-backend/src/handlers/events/message-reply.ts"
      provides: "Own-message filtering and DM handling"
      contains: "channel_type"
    - path: "apps/slack-backend/src/services/watch.ts"
      provides: "Channel name storage function"
      contains: "channelName"
  key_links:
    - from: "apps/slack-backend/src/handlers/events/message-reply.ts"
      to: "services/watch.ts"
      via: "isWatching check with DM support"
      pattern: "channel_type.*im"
---

<objective>
Fix own-message filtering and enable DM conversation support for /watch

Purpose: Two production bugs need fixing: (1) users receive suggestions for their own messages, and (2) /watch in DMs doesn't trigger on incoming messages. Both issues stem from incomplete message-reply handler logic.

Output: Message handler that correctly filters own messages and handles DM conversations, with channel name caching in /watch command.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-production-polish-and-admin/06-RESEARCH.md
@apps/slack-backend/src/handlers/events/message-reply.ts
@apps/slack-backend/src/services/watch.ts
@apps/slack-backend/src/handlers/commands/watch.ts
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add channelName column to watchedConversations schema</name>
  <files>packages/database/src/schema.ts</files>
  <action>
  Add channelName column to watchedConversations table:

  ```typescript
  export const watchedConversations = pgTable('watched_conversations', {
    id: uuid('id').primaryKey().defaultRandom(),
    workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
    userId: text('user_id').notNull(),
    channelId: text('channel_id').notNull(),
    channelName: text('channel_name'),  // NEW: Store channel name for display
    channelType: text('channel_type'),  // NEW: 'channel' | 'group' | 'im' | 'mpim'
    watchedAt: timestamp('watched_at').defaultNow(),
  }, (table) => ({
    // existing indexes...
  }));
  ```

  These columns allow:
  - channelName: Display "#general" instead of "C04XXXXXX" in web portal
  - channelType: Track if this is a DM ('im') for special handling

  After schema change, run: `npm run db:push --workspace=@slack-speak-for-me/database`
  </action>
  <verify>
  - Schema compiles: `npm run build --workspace=@slack-speak-for-me/database`
  - Migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
  </verify>
  <done>
  watchedConversations table has channelName and channelType columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Update watch service and command to store channel info</name>
  <files>
    apps/slack-backend/src/services/watch.ts
    apps/slack-backend/src/handlers/commands/watch.ts
  </files>
  <action>
  Update watch.ts:

  1. Modify watchConversation function signature:
     ```typescript
     export async function watchConversation(
       workspaceId: string,
       userId: string,
       channelId: string,
       channelName?: string,
       channelType?: string
     ): Promise<void> {
       await db.insert(watchedConversations).values({
         workspaceId,
         userId,
         channelId,
         channelName,
         channelType,
       }).onConflictDoUpdate({
         target: [watchedConversations.workspaceId, watchedConversations.userId, watchedConversations.channelId],
         set: {
           channelName,  // Update if channel was renamed
           channelType,
         },
       });
     }
     ```

  Update watch.ts command:

  2. In /watch command handler, fetch channel info before calling watchConversation:
     ```typescript
     // Get channel info for display name and type
     let channelName: string | undefined;
     let channelType: string | undefined;
     try {
       const channelInfo = await client.conversations.info({ channel: channel_id });
       channelName = channelInfo.channel?.name;
       channelType = channelInfo.channel?.is_im ? 'im' :
                     channelInfo.channel?.is_mpim ? 'mpim' :
                     channelInfo.channel?.is_private ? 'group' : 'channel';
     } catch (e) {
       // Proceed without name if API fails
       logger.warn({ error: e, channel: channel_id }, 'Failed to get channel info');
     }

     await watchConversation(workspaceId, user_id, channel_id, channelName, channelType);
     ```

  3. Pass client to command context (ensure it's available - check existing pattern).
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=slack-backend`
  - Type check passes with new optional parameters
  </verify>
  <done>
  /watch command stores channel name and type in database when watching
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix message-reply handler for own-message and DM support</name>
  <files>
    apps/slack-backend/src/handlers/events/message-reply.ts
    apps/slack-backend/src/handlers/events/message-reply.test.ts
  </files>
  <action>
  Update message-reply.ts to handle DMs and filter own messages:

  1. Add channel_type detection near the top of handler:
     ```typescript
     const channelType = 'channel_type' in message ? message.channel_type : undefined;
     const isDM = channelType === 'im' || channelId.startsWith('D');
     ```

  2. For DM messages (isDM === true), add new handling block BEFORE the thread logic:
     ```typescript
     // Handle DM conversations
     if (isDM) {
       // Check if user is watching this DM
       const isWatchingDM = await isWatching(workspaceId, userId, channelId);

       // Skip if the watcher IS the message author (own message)
       // In DMs, we need to find who is watching and trigger for them
       // But not if they sent the message themselves

       // Get all users watching this DM channel
       const watchers = await getWatchersForChannel(workspaceId, channelId);

       for (const watcherUserId of watchers) {
         // Skip if watcher is the message author
         if (watcherUserId === userId) {
           logger.debug({ user: watcherUserId }, 'Skipping DM - user is message author');
           continue;
         }

         // Queue AI suggestion for the watcher
         const contextMessages = await getContextForMessage(client, channelId, messageTs);
         const job = await queueAIResponse({
           workspaceId,
           userId: watcherUserId,
           channelId,
           messageTs,
           triggerMessageText: typedMessage.text,
           contextMessages,
           triggeredBy: 'dm',
         });

         logger.info({
           jobId: job.id,
           watchingUser: watcherUserId,
           channelId,
         }, 'AI response job queued for DM message');
       }
       return;
     }
     ```

  3. In the thread participant loop (existing code), add own-message check:
     ```typescript
     for (const participantUserId of participantUserIds) {
       // FIX: Skip if the message author IS the watching user
       if (userId === participantUserId) {
         logger.debug({ user: participantUserId }, 'Skipping - user is message author');
         continue;
       }
       // ... rest of existing logic
     }
     ```

  4. Add getWatchersForChannel to watch.ts:
     ```typescript
     export async function getWatchersForChannel(
       workspaceId: string,
       channelId: string
     ): Promise<string[]> {
       const results = await db.select({
         userId: watchedConversations.userId,
       }).from(watchedConversations).where(
         and(
           eq(watchedConversations.workspaceId, workspaceId),
           eq(watchedConversations.channelId, channelId)
         )
       );
       return results.map(r => r.userId);
     }
     ```

  5. Update message-reply.test.ts with new test cases:
     - "should not trigger for user's own message in thread"
     - "should trigger DM suggestion when watched and message is from other user"
     - "should not trigger DM suggestion when message is from watcher"
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=slack-backend`
  - Tests pass: `npm test --workspace=slack-backend -- message-reply`
  </verify>
  <done>
  - Users don't receive suggestions for their own messages
  - DM conversations trigger suggestions when /watch is active and message is from other party
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build --workspace=slack-backend`
2. Database migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
3. Tests pass: `npm test --workspace=slack-backend`
4. Manual verification possible via test page
</verification>

<success_criteria>
- watchedConversations has channelName and channelType columns
- /watch command stores channel info when executed
- message-reply handler filters own messages
- message-reply handler detects DMs and triggers appropriately
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-production-polish-and-admin/06-02-SUMMARY.md`
</output>
