---
phase: 06-production-polish-and-admin
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - packages/database/src/schema.ts
  - apps/slack-backend/src/services/feedback-tracker.ts
  - apps/web-portal/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "Suggestion acceptance events are tracked separately from refinements"
    - "Database stores both 'accepted' and 'refined' action types"
    - "Web portal can query feedback by action type"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "suggestionFeedback table"
      contains: "suggestionFeedback"
    - path: "apps/slack-backend/src/services/feedback-tracker.ts"
      provides: "Feedback tracking service"
      exports: ["trackAcceptance", "trackRefinement", "trackDismissal"]
  key_links:
    - from: "apps/slack-backend/src/services/feedback-tracker.ts"
      to: "packages/database/src/schema.ts"
      via: "database insert"
      pattern: "db\\.insert\\(suggestionFeedback\\)"
---

<objective>
Create suggestion feedback tracking schema and service

Purpose: The AI Learning tab currently only shows refinements. To show accurate feedback (accepted vs refined), we need to track when users accept suggestions without modification. This requires a new table and tracking service.

Output: suggestionFeedback table and feedback-tracker service that tracks accepted, refined, and dismissed actions with timestamps.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-production-polish-and-admin/06-RESEARCH.md
@packages/database/src/schema.ts
@apps/slack-backend/src/handlers/actions/copy-suggestion.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add suggestionFeedback table to schema</name>
  <files>packages/database/src/schema.ts</files>
  <action>
  Add new suggestionFeedback table after refinementFeedback:

  ```typescript
  export const suggestionFeedback = pgTable('suggestion_feedback', {
    id: uuid('id').primaryKey().defaultRandom(),
    workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
    userId: text('user_id').notNull(),
    suggestionId: text('suggestion_id').notNull(), // Unique ID for the suggestion
    action: text('action').notNull(), // 'accepted' | 'refined' | 'dismissed' | 'sent'
    originalText: text('original_text'), // The AI suggestion text
    finalText: text('final_text'), // Final text after any modifications
    triggerContext: text('trigger_context'), // The message that triggered the suggestion
    channelId: text('channel_id'), // Where the suggestion was triggered
    createdAt: timestamp('created_at').defaultNow(),
  }, (table) => ({
    workspaceUserIdx: index('suggestion_feedback_workspace_user_idx').on(table.workspaceId, table.userId),
    createdAtIdx: index('suggestion_feedback_created_at_idx').on(table.createdAt),
    actionIdx: index('suggestion_feedback_action_idx').on(table.action),
    suggestionIdx: uniqueIndex('suggestion_feedback_suggestion_idx').on(table.suggestionId, table.action),
  }));
  ```

  Export the new table from the schema exports.

  Note: The suggestionIdx unique index prevents duplicate entries for the same suggestion+action combo.
  </action>
  <verify>
  - Schema compiles: `npm run build --workspace=@slack-speak-for-me/database`
  - Migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
  </verify>
  <done>
  suggestionFeedback table exists with proper indexes for querying by user, date, and action type
  </done>
</task>

<task type="auto">
  <name>Task 2: Create feedback-tracker service</name>
  <files>apps/slack-backend/src/services/feedback-tracker.ts</files>
  <action>
  Create new feedback tracking service:

  ```typescript
  import { db, suggestionFeedback } from '@slack-speak/database';
  import { logger } from '../utils/logger.js';

  interface TrackFeedbackParams {
    workspaceId: string;
    userId: string;
    suggestionId: string;
    action: 'accepted' | 'refined' | 'dismissed' | 'sent';
    originalText?: string;
    finalText?: string;
    triggerContext?: string;
    channelId?: string;
  }

  /**
   * Track suggestion feedback action
   * Handles duplicates gracefully via upsert
   */
  export async function trackFeedback(params: TrackFeedbackParams): Promise<void> {
    try {
      await db.insert(suggestionFeedback).values({
        workspaceId: params.workspaceId,
        userId: params.userId,
        suggestionId: params.suggestionId,
        action: params.action,
        originalText: params.originalText,
        finalText: params.finalText,
        triggerContext: params.triggerContext,
        channelId: params.channelId,
      }).onConflictDoUpdate({
        target: [suggestionFeedback.suggestionId, suggestionFeedback.action],
        set: {
          finalText: params.finalText,
        },
      });

      logger.info({
        suggestionId: params.suggestionId,
        action: params.action,
        userId: params.userId,
      }, 'Suggestion feedback tracked');
    } catch (error) {
      logger.error({ error, params }, 'Failed to track suggestion feedback');
      // Don't throw - feedback tracking shouldn't break the main flow
    }
  }

  /**
   * Track when user accepts suggestion without modification (clicks Copy)
   */
  export async function trackAcceptance(
    workspaceId: string,
    userId: string,
    suggestionId: string,
    suggestionText: string,
    channelId?: string
  ): Promise<void> {
    await trackFeedback({
      workspaceId,
      userId,
      suggestionId,
      action: 'accepted',
      originalText: suggestionText,
      finalText: suggestionText, // Same as original - no modification
      channelId,
    });
  }

  /**
   * Track when user refines and then accepts
   */
  export async function trackRefinement(
    workspaceId: string,
    userId: string,
    suggestionId: string,
    originalText: string,
    refinedText: string,
    channelId?: string
  ): Promise<void> {
    await trackFeedback({
      workspaceId,
      userId,
      suggestionId,
      action: 'refined',
      originalText,
      finalText: refinedText,
      channelId,
    });
  }

  /**
   * Track when user dismisses suggestion
   */
  export async function trackDismissal(
    workspaceId: string,
    userId: string,
    suggestionId: string,
    suggestionText?: string,
    channelId?: string
  ): Promise<void> {
    await trackFeedback({
      workspaceId,
      userId,
      suggestionId,
      action: 'dismissed',
      originalText: suggestionText,
      channelId,
    });
  }
  ```

  Add export to services/index.ts:
  ```typescript
  export * from './feedback-tracker.js';
  ```
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=slack-backend`
  - TypeScript types are correct
  </verify>
  <done>
  feedback-tracker service exports trackAcceptance, trackRefinement, trackDismissal functions
  </done>
</task>

<task type="auto">
  <name>Task 3: Add feedback queries for web portal</name>
  <files>apps/web-portal/lib/db/queries.ts</files>
  <action>
  Add queries to fetch suggestion feedback:

  1. Import suggestionFeedback from schema

  2. Add query for suggestion feedback with action types:
  ```typescript
  /**
   * Get suggestion feedback history (accepted, refined, dismissed)
   */
  export const getSuggestionFeedback = cache(async (limit = 50) => {
    const session = await verifySession();

    return db
      .select({
        id: suggestionFeedback.id,
        suggestionId: suggestionFeedback.suggestionId,
        action: suggestionFeedback.action,
        originalText: suggestionFeedback.originalText,
        finalText: suggestionFeedback.finalText,
        channelId: suggestionFeedback.channelId,
        createdAt: suggestionFeedback.createdAt,
      })
      .from(suggestionFeedback)
      .where(
        and(
          eq(suggestionFeedback.workspaceId, session.workspaceId),
          eq(suggestionFeedback.userId, session.userId)
        )
      )
      .orderBy(desc(suggestionFeedback.createdAt))
      .limit(limit);
  });

  /**
   * Get feedback stats by action type
   */
  export const getSuggestionFeedbackStats = cache(async () => {
    const session = await verifySession();

    const stats = await db
      .select({
        action: suggestionFeedback.action,
        count: count(),
      })
      .from(suggestionFeedback)
      .where(
        and(
          eq(suggestionFeedback.workspaceId, session.workspaceId),
          eq(suggestionFeedback.userId, session.userId)
        )
      )
      .groupBy(suggestionFeedback.action);

    return stats;
  });
  ```
  </action>
  <verify>
  - Build succeeds: `npm run build --workspace=@slack-speak-for-me/web-portal`
  - TypeScript types match schema
  </verify>
  <done>
  Web portal can query suggestion feedback by action type with getSuggestionFeedback and getSuggestionFeedbackStats
  </done>
</task>

</tasks>

<verification>
1. Database migration applies: `npm run db:push --workspace=@slack-speak-for-me/database`
2. Backend build succeeds: `npm run build --workspace=slack-backend`
3. Web portal build succeeds: `npm run build --workspace=@slack-speak-for-me/web-portal`
</verification>

<success_criteria>
- suggestionFeedback table exists in database
- feedback-tracker service can track all action types
- Web portal queries return feedback data grouped by action
</success_criteria>

<output>
After completion, create `.planning/phases/06-production-polish-and-admin/06-03-SUMMARY.md`
</output>
