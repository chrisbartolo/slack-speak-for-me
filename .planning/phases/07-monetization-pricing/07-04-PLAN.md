---
phase: 07-monetization-pricing
plan: 04
type: execute
wave: 2
depends_on: ["07-03"]
files_modified:
  - apps/web-portal/app/api/stripe/webhook/route.ts
  - apps/web-portal/lib/billing/trial.ts
autonomous: true

must_haves:
  truths:
    - "Webhooks handle trial_will_end event (sent 3 days before trial ends)"
    - "Webhooks handle subscription paused event"
    - "Webhooks handle subscription resumed event"
    - "Webhooks handle invoice payment_failed event"
    - "trialEndsAt is set from subscription trial_end"
  artifacts:
    - path: "apps/web-portal/app/api/stripe/webhook/route.ts"
      provides: "Complete subscription lifecycle handling"
      contains: "customer.subscription.trial_will_end"
    - path: "apps/web-portal/lib/billing/trial.ts"
      provides: "Trial state helper functions"
      exports: ["getTrialStatus", "isTrialExpired"]
  key_links:
    - from: "apps/web-portal/app/api/stripe/webhook/route.ts"
      to: "database organizations table"
      via: "update subscriptionStatus and trialEndsAt"
      pattern: "update.*organizations"
    - from: "Stripe webhook"
      to: "subscription.trial_end"
      via: "trialEndsAt timestamp"
      pattern: "trial_end"
---

<objective>
Extend webhook handler to cover full subscription lifecycle including trial events.

Purpose: React to all Stripe subscription state changes to keep database in sync and handle edge cases.
Output: Comprehensive webhook handler for trials, pauses, failures, and resumptions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-monetization-pricing/07-RESEARCH.md

@apps/web-portal/app/api/stripe/webhook/route.ts
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trial state helper functions</name>
  <files>apps/web-portal/lib/billing/trial.ts</files>
  <action>
Create utility functions for trial state management:

1. Create `apps/web-portal/lib/billing/trial.ts`:
   ```typescript
   import 'server-only';

   interface TrialStatus {
     isInTrial: boolean;
     daysRemaining: number | null;
     trialEndsAt: Date | null;
     hasExpired: boolean;
   }

   export function getTrialStatus(
     subscriptionStatus: string | null,
     trialEndsAt: Date | null
   ): TrialStatus {
     if (!trialEndsAt) {
       return { isInTrial: false, daysRemaining: null, trialEndsAt: null, hasExpired: false };
     }

     const now = new Date();
     const isInTrial = subscriptionStatus === 'trialing';
     const hasExpired = trialEndsAt < now && !isInTrial;
     const daysRemaining = isInTrial
       ? Math.max(0, Math.ceil((trialEndsAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)))
       : null;

     return { isInTrial, daysRemaining, trialEndsAt, hasExpired };
   }

   export function isTrialExpired(
     subscriptionStatus: string | null,
     trialEndsAt: Date | null
   ): boolean {
     if (!trialEndsAt) return false;
     return subscriptionStatus === 'paused' || (trialEndsAt < new Date() && subscriptionStatus !== 'active');
   }

   export function formatTrialDaysRemaining(days: number): string {
     if (days === 0) return 'Trial ends today';
     if (days === 1) return '1 day left in trial';
     return `${days} days left in trial`;
   }
   ```
  </action>
  <verify>
    - `npm run build --workspace=web-portal` succeeds
    - File exists with getTrialStatus and isTrialExpired exports
  </verify>
  <done>
    - Trial status helper returns isInTrial, daysRemaining, hasExpired
    - isTrialExpired handles paused and expired states
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend webhook handler for full lifecycle</name>
  <files>apps/web-portal/app/api/stripe/webhook/route.ts</files>
  <action>
Extend existing webhook handler with additional event types:

1. Add new case handlers to the switch statement:

   ```typescript
   case 'customer.subscription.trial_will_end': {
     // Sent 3 days before trial ends
     const subscription = event.data.object as Stripe.Subscription;
     const customerId = subscription.customer as string;
     // Log for now - could queue email reminder job in future
     console.log(`Trial ending soon for customer ${customerId}`);
     break;
   }

   case 'customer.subscription.paused': {
     const subscription = event.data.object as Stripe.Subscription;
     const customerId = subscription.customer as string;

     await db
       .update(organizations)
       .set({
         subscriptionStatus: 'paused',
         updatedAt: new Date(),
       })
       .where(eq(organizations.stripeCustomerId, customerId));

     console.log(`Subscription paused for customer ${customerId}`);
     break;
   }

   case 'customer.subscription.resumed': {
     const subscription = event.data.object as Stripe.Subscription;
     const customerId = subscription.customer as string;

     await db
       .update(organizations)
       .set({
         subscriptionStatus: 'active',
         updatedAt: new Date(),
       })
       .where(eq(organizations.stripeCustomerId, customerId));

     console.log(`Subscription resumed for customer ${customerId}`);
     break;
   }

   case 'invoice.payment_failed': {
     const invoice = event.data.object as Stripe.Invoice;
     const customerId = invoice.customer as string;

     // Log failure - Stripe handles retry automatically
     console.log(`Payment failed for customer ${customerId}, invoice ${invoice.id}`);
     break;
   }

   case 'invoice.paid': {
     const invoice = event.data.object as Stripe.Invoice;
     const customerId = invoice.customer as string;

     // Ensure status is active after successful payment
     await db
       .update(organizations)
       .set({
         subscriptionStatus: 'active',
         updatedAt: new Date(),
       })
       .where(eq(organizations.stripeCustomerId, customerId));
     break;
   }
   ```

2. Update the 'customer.subscription.created' and 'customer.subscription.updated' cases:
   - Extract trial_end from subscription and save as trialEndsAt
   - Handle 'trialing' status properly:
   ```typescript
   await db
     .update(organizations)
     .set({
       stripeSubscriptionId: subscription.id,
       subscriptionStatus: subscription.status,
       seatCount: subscription.items.data[0]?.quantity || 1,
       trialEndsAt: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
       updatedAt: new Date(),
     })
     .where(eq(organizations.stripeCustomerId, customerId));
   ```

3. Log all handled events for debugging
  </action>
  <verify>
    - `npm run build --workspace=web-portal` succeeds
    - Grep webhook/route.ts for 'trial_will_end' shows handler
    - Grep webhook/route.ts for 'paused' shows handler
    - Grep webhook/route.ts for 'trialEndsAt' shows field being set
  </verify>
  <done>
    - Webhook handles trial_will_end, paused, resumed events
    - invoice.payment_failed and invoice.paid handled
    - trialEndsAt saved from subscription.trial_end
    - All status transitions update database correctly
  </done>
</task>

</tasks>

<verification>
1. Build completes without errors
2. Webhook handler has case for all required event types
3. trialEndsAt is set from subscription.trial_end on create/update
4. Paused status correctly set when subscription pauses
</verification>

<success_criteria>
- customer.subscription.trial_will_end handled (logs for now)
- customer.subscription.paused sets status to 'paused'
- customer.subscription.resumed sets status to 'active'
- invoice.payment_failed logged (Stripe handles retries)
- trialEndsAt populated from subscription trial_end timestamp
</success_criteria>

<output>
After completion, create `.planning/phases/07-monetization-pricing/07-04-SUMMARY.md`
</output>
