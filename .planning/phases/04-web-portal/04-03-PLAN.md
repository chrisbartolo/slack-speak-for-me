---
phase: 04-web-portal
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/web-portal/lib/auth/session.ts
  - apps/web-portal/lib/auth/dal.ts
  - apps/web-portal/app/api/slack/oauth/route.ts
  - apps/web-portal/app/(auth)/callback/route.ts
  - apps/web-portal/app/(auth)/login/page.tsx
  - apps/web-portal/middleware.ts
  - apps/web-portal/.env.example
autonomous: true

must_haves:
  truths:
    - "User can click Sign in with Slack button"
    - "OAuth flow redirects to Slack and back"
    - "Session is created after successful OAuth"
    - "Protected routes redirect unauthenticated users to login"
  artifacts:
    - path: "apps/web-portal/lib/auth/session.ts"
      provides: "JWT session management with jose"
      exports: ["encrypt", "decrypt", "createSession", "deleteSession"]
    - path: "apps/web-portal/lib/auth/dal.ts"
      provides: "Data Access Layer for auth verification"
      exports: ["verifySession"]
    - path: "apps/web-portal/app/api/slack/oauth/route.ts"
      provides: "OAuth initiation endpoint"
      exports: ["GET"]
    - path: "apps/web-portal/app/(auth)/callback/route.ts"
      provides: "OAuth callback handler"
      exports: ["GET"]
    - path: "apps/web-portal/middleware.ts"
      provides: "Route protection middleware"
      contains: "middleware"
  key_links:
    - from: "apps/web-portal/app/(auth)/callback/route.ts"
      to: "apps/web-portal/lib/auth/session.ts"
      via: "createSession call"
      pattern: "createSession"
    - from: "apps/web-portal/middleware.ts"
      to: "apps/web-portal/lib/auth/session.ts"
      via: "decrypt call"
      pattern: "decrypt"
---

<objective>
Implement Slack OAuth authentication with stateless JWT sessions for the web portal.

Purpose: Enable PORTAL-01 requirement - user can sign in to web portal using Slack OAuth. This provides the authentication foundation for all other dashboard features.
Output: Complete authentication flow with login page, OAuth endpoints, session management, and route protection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-web-portal/04-CONTEXT.md
@.planning/phases/04-web-portal/04-RESEARCH.md
@.planning/phases/04-web-portal/04-01-SUMMARY.md
@apps/slack-backend/src/oauth/installation-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT session management with jose</name>
  <files>
    apps/web-portal/lib/auth/session.ts
    apps/web-portal/.env.example
    apps/web-portal/.env.local
  </files>
  <action>
Create apps/web-portal/lib/auth/session.ts with stateless JWT session management:

```typescript
import 'server-only';
import { SignJWT, jwtVerify } from 'jose';
import { cookies } from 'next/headers';

const secretKey = process.env.SESSION_SECRET!;
const encodedKey = new TextEncoder().encode(secretKey);

export type SessionPayload = {
  userId: string;        // Slack user ID
  workspaceId: string;   // Internal workspace UUID
  teamId: string;        // Slack team ID
  expiresAt: Date;
};

export async function encrypt(payload: SessionPayload): Promise<string> {
  return new SignJWT({ ...payload, expiresAt: payload.expiresAt.toISOString() })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey);
}

export async function decrypt(session: string | undefined = ''): Promise<SessionPayload | null> {
  if (!session) return null;

  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    });
    return {
      userId: payload.userId as string,
      workspaceId: payload.workspaceId as string,
      teamId: payload.teamId as string,
      expiresAt: new Date(payload.expiresAt as string),
    };
  } catch (error) {
    console.log('Failed to verify session');
    return null;
  }
}

export async function createSession(payload: Omit<SessionPayload, 'expiresAt'>): Promise<void> {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
  const session = await encrypt({ ...payload, expiresAt });
  const cookieStore = await cookies();

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  });
}

export async function deleteSession(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.delete('session');
}

export async function getSession(): Promise<SessionPayload | null> {
  const cookieStore = await cookies();
  const session = cookieStore.get('session')?.value;
  return decrypt(session);
}
```

Create apps/web-portal/.env.example:
```
# Slack OAuth
SLACK_CLIENT_ID=
SLACK_CLIENT_SECRET=
SLACK_WEB_REDIRECT_URI=http://localhost:3001/callback

# Session
SESSION_SECRET=your-32-character-secret-key-here

# Database (uses same as slack-backend)
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/slack_speak_for_me
```

Create apps/web-portal/.env.local with actual values (copy from slack-backend .env where applicable).

DO NOT commit .env.local - ensure it's in .gitignore.
  </action>
  <verify>
    ls apps/web-portal/lib/auth/session.ts
    grep -n "encrypt" apps/web-portal/lib/auth/session.ts
    ls apps/web-portal/.env.example
  </verify>
  <done>JWT session management implemented with encrypt, decrypt, createSession, deleteSession, getSession functions</done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth endpoints and callback handler</name>
  <files>
    apps/web-portal/app/api/slack/oauth/route.ts
    apps/web-portal/app/(auth)/callback/route.ts
    apps/web-portal/app/(auth)/login/page.tsx
    apps/web-portal/lib/auth/slack-oauth.ts
  </files>
  <action>
Create apps/web-portal/lib/auth/slack-oauth.ts for OAuth helpers:

```typescript
import { randomBytes } from 'crypto';

export function generateOAuthState(): string {
  return randomBytes(16).toString('hex');
}

export function getSlackOAuthUrl(state: string): string {
  const params = new URLSearchParams({
    client_id: process.env.SLACK_CLIENT_ID!,
    scope: '', // User scope for Sign in with Slack
    redirect_uri: process.env.SLACK_WEB_REDIRECT_URI!,
    state,
    // Use openid for Sign in with Slack
    user_scope: 'openid,profile',
  });

  return `https://slack.com/oauth/v2/authorize?${params.toString()}`;
}

export async function exchangeCodeForTokens(code: string) {
  const response = await fetch('https://slack.com/api/oauth.v2.access', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: process.env.SLACK_CLIENT_ID!,
      client_secret: process.env.SLACK_CLIENT_SECRET!,
      code,
      redirect_uri: process.env.SLACK_WEB_REDIRECT_URI!,
    }),
  });

  return response.json();
}
```

Create apps/web-portal/app/api/slack/oauth/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { generateOAuthState, getSlackOAuthUrl } from '@/lib/auth/slack-oauth';

export async function GET(request: NextRequest) {
  const state = generateOAuthState();
  const returnUrl = request.nextUrl.searchParams.get('return') || '/';

  const response = NextResponse.redirect(getSlackOAuthUrl(state));

  // Store state and return URL in cookies for verification
  response.cookies.set('oauth_state', state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 600, // 10 minutes
  });

  response.cookies.set('oauth_return', returnUrl, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 600,
  });

  return response;
}
```

Create apps/web-portal/app/(auth)/callback/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createSession } from '@/lib/auth/session';
import { exchangeCodeForTokens } from '@/lib/auth/slack-oauth';
import { db, workspaces } from '@slack-speak-for-me/database';
import { eq } from 'drizzle-orm';

export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl;
  const code = searchParams.get('code');
  const state = searchParams.get('state');
  const error = searchParams.get('error');

  const storedState = request.cookies.get('oauth_state')?.value;
  const returnUrl = request.cookies.get('oauth_return')?.value || '/';

  // Handle OAuth errors
  if (error) {
    return NextResponse.redirect(new URL(`/login?error=${error}`, request.url));
  }

  // Verify state parameter (CSRF protection)
  if (!state || state !== storedState) {
    return NextResponse.redirect(new URL('/login?error=invalid_state', request.url));
  }

  if (!code) {
    return NextResponse.redirect(new URL('/login?error=missing_code', request.url));
  }

  try {
    // Exchange code for tokens
    const tokens = await exchangeCodeForTokens(code);

    if (!tokens.ok) {
      console.error('Slack OAuth error:', tokens.error);
      return NextResponse.redirect(new URL('/login?error=oauth_failed', request.url));
    }

    // Look up workspace UUID from team_id
    const [workspace] = await db
      .select()
      .from(workspaces)
      .where(eq(workspaces.teamId, tokens.team.id))
      .limit(1);

    if (!workspace) {
      // Workspace not found - user needs to install app first
      return NextResponse.redirect(new URL('/login?error=workspace_not_found', request.url));
    }

    // Create session with workspace and user info
    await createSession({
      teamId: tokens.team.id,
      userId: tokens.authed_user.id,
      workspaceId: workspace.id,
    });

    // Clear OAuth cookies and redirect
    const response = NextResponse.redirect(new URL(returnUrl, request.url));
    response.cookies.delete('oauth_state');
    response.cookies.delete('oauth_return');

    return response;
  } catch (error) {
    console.error('OAuth error:', error);
    return NextResponse.redirect(new URL('/login?error=oauth_failed', request.url));
  }
}
```

Create apps/web-portal/app/(auth)/login/page.tsx:

```typescript
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

export default function LoginPage({
  searchParams,
}: {
  searchParams: { error?: string };
}) {
  const errorMessages: Record<string, string> = {
    invalid_state: 'Security verification failed. Please try again.',
    missing_code: 'Authentication was cancelled.',
    oauth_failed: 'Authentication failed. Please try again.',
    workspace_not_found: 'Your workspace has not installed Speak For Me. Please ask your admin to install the app first.',
  };

  const error = searchParams.error ? errorMessages[searchParams.error] || 'An error occurred' : null;

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <CardTitle className="text-2xl">Speak For Me</CardTitle>
          <CardDescription>
            Sign in to manage your AI response settings
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="p-3 text-sm text-red-600 bg-red-50 rounded-md">
              {error}
            </div>
          )}
          <Link href="/api/slack/oauth" className="block">
            <Button className="w-full" size="lg">
              <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor">
                <path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zM6.313 15.165a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zM8.834 6.313a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.522-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.522 2.521h-2.522V8.834zM17.688 8.834a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.165 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.165 18.956a2.528 2.528 0 0 1 2.523 2.522A2.528 2.528 0 0 1 15.165 24a2.527 2.527 0 0 1-2.52-2.522v-2.522h2.52zM15.165 17.688a2.527 2.527 0 0 1-2.52-2.523 2.526 2.526 0 0 1 2.52-2.52h6.313A2.527 2.527 0 0 1 24 15.165a2.528 2.528 0 0 1-2.522 2.523h-6.313z"/>
              </svg>
              Sign in with Slack
            </Button>
          </Link>
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
    ls apps/web-portal/app/api/slack/oauth/route.ts
    ls apps/web-portal/app/(auth)/callback/route.ts
    ls apps/web-portal/app/(auth)/login/page.tsx
    npm run build --workspace=web-portal
  </verify>
  <done>OAuth endpoints and login page implemented with state verification and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create middleware and Data Access Layer</name>
  <files>
    apps/web-portal/lib/auth/dal.ts
    apps/web-portal/middleware.ts
  </files>
  <action>
Create apps/web-portal/lib/auth/dal.ts (Data Access Layer for security):

```typescript
import 'server-only';
import { cache } from 'react';
import { cookies } from 'next/headers';
import { decrypt } from './session';
import { redirect } from 'next/navigation';

export const verifySession = cache(async () => {
  const cookieStore = await cookies();
  const cookie = cookieStore.get('session')?.value;
  const session = await decrypt(cookie);

  if (!session?.userId) {
    redirect('/login');
  }

  return {
    isAuth: true,
    userId: session.userId,
    workspaceId: session.workspaceId,
    teamId: session.teamId,
  };
});

// Optional: Get session without redirecting (for conditional rendering)
export const getOptionalSession = cache(async () => {
  const cookieStore = await cookies();
  const cookie = cookieStore.get('session')?.value;
  const session = await decrypt(cookie);

  if (!session?.userId) {
    return null;
  }

  return {
    isAuth: true,
    userId: session.userId,
    workspaceId: session.workspaceId,
    teamId: session.teamId,
  };
});
```

Create apps/web-portal/middleware.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { decrypt } from '@/lib/auth/session';

const protectedRoutes = ['/', '/style', '/conversations', '/people', '/reports', '/feedback'];
const publicRoutes = ['/login', '/callback'];

export async function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname;

  // Check if route needs protection
  const isProtectedRoute = protectedRoutes.some(route =>
    path === route || path.startsWith(route + '/')
  );
  const isPublicRoute = publicRoutes.some(route =>
    path === route || path.startsWith(route + '/')
  );

  // Get session from cookie
  const cookie = request.cookies.get('session')?.value;
  const session = await decrypt(cookie);

  // Redirect unauthenticated users from protected routes
  if (isProtectedRoute && !session?.userId) {
    const loginUrl = new URL('/login', request.nextUrl);
    loginUrl.searchParams.set('return', path);
    return NextResponse.redirect(loginUrl);
  }

  // Redirect authenticated users away from login page
  if (isPublicRoute && session?.userId && path === '/login') {
    return NextResponse.redirect(new URL('/', request.nextUrl));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - api routes (except our OAuth routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico, images, etc.
     */
    '/((?!api/(?!slack)|_next/static|_next/image|favicon.ico|.*\\.png$|.*\\.svg$).*)',
  ],
};
```

IMPORTANT: The middleware provides optimistic auth checks. The DAL (verifySession) provides the actual security boundary per CVE-2025-29927. Always use verifySession() in Server Components and Server Actions that access data.
  </action>
  <verify>
    ls apps/web-portal/lib/auth/dal.ts
    ls apps/web-portal/middleware.ts
    grep -n "verifySession" apps/web-portal/lib/auth/dal.ts
    npm run build --workspace=web-portal
  </verify>
  <done>Middleware and DAL implemented with proper security patterns</done>
</task>

</tasks>

<verification>
1. Login page renders at /login with "Sign in with Slack" button
2. Clicking button redirects to Slack OAuth
3. After Slack auth, user is redirected back to callback
4. Session cookie is set after successful OAuth
5. Protected routes redirect to /login when not authenticated
6. Authenticated users are redirected away from /login
7. Build passes without errors
</verification>

<success_criteria>
- User can navigate to /login and see Sign in with Slack button
- OAuth flow redirects to Slack with proper state parameter
- Callback handler validates state, exchanges code, creates session
- Session stored in HTTP-only cookie with 7-day expiration
- Middleware redirects unauthenticated users to login
- DAL verifySession() available for Server Components
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-portal/04-03-SUMMARY.md`
</output>
