---
phase: 05-weekly-reports
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/database/src/schema.ts
  - apps/slack-backend/src/services/google-sheets.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/handlers/events/workflow-submission.ts
  - apps/slack-backend/src/handlers/events/index.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/workers.ts
autonomous: true

must_haves:
  truths:
    - "App detects workflow form submissions in monitored channel"
    - "Workflow submissions are written to user's Google Sheet"
    - "Sheet operations are queued to prevent rate limit issues"
    - "Submission tracking records who has submitted this week"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "workflowConfig table for channel monitoring settings"
      contains: "workflowConfig"
    - path: "apps/slack-backend/src/services/google-sheets.ts"
      provides: "Google Sheets read/write service"
      exports: ["appendSubmission", "getSubmissions", "getSubmissionStatus"]
    - path: "apps/slack-backend/src/handlers/events/workflow-submission.ts"
      provides: "Slack event handler for workflow submissions"
      exports: ["registerWorkflowSubmissionHandler"]
  key_links:
    - from: "apps/slack-backend/src/handlers/events/workflow-submission.ts"
      to: "apps/slack-backend/src/jobs/queues.ts"
      via: "Queue sheets write job"
      pattern: "sheetsQueue\\.add"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/google-sheets.ts"
      via: "Worker calls Sheets service"
      pattern: "appendSubmission"
---

<objective>
Implement workflow submission detection and Google Sheets write service with queue-based processing.

Purpose: Monitor designated Slack channel for workflow form submissions from team members, parse the submission data, and write it to the user's connected Google Sheet. Use BullMQ queue for rate limit protection.

Output: Event handler for workflow submissions, Google Sheets write service, queued job processor for Sheets operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-weekly-reports/05-RESEARCH.md
@.planning/phases/05-weekly-reports/05-01-SUMMARY.md

# Existing patterns
@apps/slack-backend/src/handlers/events/message-reply.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflowConfig table for channel monitoring settings</name>
  <files>packages/database/src/schema.ts</files>
  <action>
Add workflowConfig table to store which channels to monitor for workflow submissions and mapping configuration.

```typescript
export const workflowConfig = pgTable('workflow_config', {
  id: uuid('id').primaryKey().defaultRandom(),
  workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
  userId: text('user_id').notNull(), // Owner of this config
  channelId: text('channel_id').notNull(), // Channel to monitor
  channelName: text('channel_name'), // Display name
  workflowBotId: text('workflow_bot_id'), // Bot ID that posts workflow submissions (learned from first submission)
  enabled: boolean('enabled').default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (table) => ({
  uniqueConfig: uniqueIndex('workflow_config_unique_idx').on(table.workspaceId, table.userId, table.channelId),
  channelIdx: index('workflow_config_channel_idx').on(table.workspaceId, table.channelId),
}));
```

Run `npm run db:push --workspace=@slack-speak/database` after adding.
  </action>
  <verify>
`npm run db:push --workspace=@slack-speak/database` succeeds.
`npm run build --workspace=@slack-speak/database` compiles.
  </verify>
  <done>
workflowConfig table exists with channel monitoring settings and unique constraint per user/channel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Google Sheets service for write operations</name>
  <files>
apps/slack-backend/src/services/google-sheets.ts
apps/slack-backend/src/services/index.ts
  </files>
  <action>
Create Google Sheets service for reading/writing submission data.

```typescript
// apps/slack-backend/src/services/google-sheets.ts
import { google } from 'googleapis';
import { getGoogleClient } from '../oauth/google-oauth.js';
import { logger } from '../utils/logger.js';

export interface WorkflowSubmission {
  timestamp: Date;
  submitterName: string;
  submitterSlackId: string;
  achievements: string;
  focus: string;
  blockers: string;
  shoutouts: string;
}

/**
 * Append a workflow submission to the user's configured Google Sheet
 */
export async function appendSubmission(
  workspaceId: string,
  userId: string,
  spreadsheetId: string,
  submission: WorkflowSubmission
): Promise<void> {
  const oauth2Client = await getGoogleClient(workspaceId, userId);
  const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

  const values = [[
    submission.timestamp.toISOString(),
    submission.submitterName,
    submission.submitterSlackId,
    submission.achievements,
    submission.focus,
    submission.blockers,
    submission.shoutouts,
  ]];

  await sheets.spreadsheets.values.append({
    spreadsheetId,
    range: 'Weekly Updates!A:G', // Columns: timestamp, name, slackId, achievements, focus, blockers, shoutouts
    valueInputOption: 'USER_ENTERED',
    insertDataOption: 'INSERT_ROWS',
    requestBody: { values },
  });

  logger.info({
    workspaceId,
    userId,
    spreadsheetId,
    submitter: submission.submitterName,
  }, 'Appended submission to Google Sheet');
}

/**
 * Get all submissions from this week
 */
export async function getSubmissions(
  workspaceId: string,
  userId: string,
  spreadsheetId: string,
  weekStartDate: Date
): Promise<WorkflowSubmission[]> {
  const oauth2Client = await getGoogleClient(workspaceId, userId);
  const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

  const result = await sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Weekly Updates!A2:G', // Skip header row
  });

  const rows = result.data.values || [];

  return rows
    .map((row) => ({
      timestamp: new Date(row[0]),
      submitterName: row[1] || '',
      submitterSlackId: row[2] || '',
      achievements: row[3] || '',
      focus: row[4] || '',
      blockers: row[5] || '',
      shoutouts: row[6] || '',
    }))
    .filter((sub) => sub.timestamp >= weekStartDate);
}

/**
 * Get submission status - who has submitted this week
 */
export async function getSubmissionStatus(
  workspaceId: string,
  userId: string,
  spreadsheetId: string,
  weekStartDate: Date
): Promise<{ submitterSlackId: string; submitterName: string; submittedAt: Date }[]> {
  const submissions = await getSubmissions(workspaceId, userId, spreadsheetId, weekStartDate);

  // Get unique submitters (latest submission per person)
  const submitterMap = new Map<string, { submitterSlackId: string; submitterName: string; submittedAt: Date }>();

  for (const sub of submissions) {
    const existing = submitterMap.get(sub.submitterSlackId);
    if (!existing || sub.timestamp > existing.submittedAt) {
      submitterMap.set(sub.submitterSlackId, {
        submitterSlackId: sub.submitterSlackId,
        submitterName: sub.submitterName,
        submittedAt: sub.timestamp,
      });
    }
  }

  return Array.from(submitterMap.values());
}
```

Add to services/index.ts:
```typescript
export * from './google-sheets.js';
```
  </action>
  <verify>
`npm run build --workspace=slack-backend` compiles.
Service exports appendSubmission, getSubmissions, getSubmissionStatus.
  </verify>
  <done>
Google Sheets service handles append (write), get (read), and status (tracking) operations for workflow submissions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Sheets queue and workflow submission handler</name>
  <files>
apps/slack-backend/src/jobs/types.ts
apps/slack-backend/src/jobs/queues.ts
apps/slack-backend/src/jobs/workers.ts
apps/slack-backend/src/handlers/events/workflow-submission.ts
apps/slack-backend/src/handlers/events/index.ts
  </files>
  <action>
Add queue for Sheets operations and event handler for workflow submissions.

In jobs/types.ts, add:
```typescript
export interface SheetsWriteJobData {
  workspaceId: string;
  userId: string; // Report owner
  spreadsheetId: string;
  submission: {
    timestamp: string; // ISO string
    submitterName: string;
    submitterSlackId: string;
    achievements: string;
    focus: string;
    blockers: string;
    shoutouts: string;
  };
}

export interface SheetsWriteJobResult {
  success: boolean;
}
```

In jobs/queues.ts, add:
```typescript
export const sheetsQueue = new Queue<SheetsWriteJobData>('sheets-writes', {
  connection: redis,
  defaultJobOptions: {
    attempts: 5,
    backoff: {
      type: 'exponential',
      delay: 2000,
    },
    removeOnComplete: { count: 100 },
    removeOnFail: { count: 500 },
  },
});

export async function queueSheetsWrite(data: SheetsWriteJobData) {
  return sheetsQueue.add('append-submission', data);
}
```

In jobs/workers.ts, add Sheets worker:
```typescript
import type { SheetsWriteJobData, SheetsWriteJobResult } from './types.js';
import { appendSubmission } from '../services/google-sheets.js';

let sheetsWorker: Worker<SheetsWriteJobData, SheetsWriteJobResult> | null = null;

// In startWorkers(), add:
sheetsWorker = new Worker<SheetsWriteJobData, SheetsWriteJobResult>(
  'sheets-writes',
  async (job) => {
    const { workspaceId, userId, spreadsheetId, submission } = job.data;

    await appendSubmission(workspaceId, userId, spreadsheetId, {
      timestamp: new Date(submission.timestamp),
      submitterName: submission.submitterName,
      submitterSlackId: submission.submitterSlackId,
      achievements: submission.achievements,
      focus: submission.focus,
      blockers: submission.blockers,
      shoutouts: submission.shoutouts,
    });

    return { success: true };
  },
  {
    connection: redis,
    concurrency: 1, // One at a time to avoid rate limits per spreadsheet
    limiter: {
      max: 30, // Max 30 writes per minute (well under 60/min limit)
      duration: 60000,
    },
  }
);

sheetsWorker.on('error', (err) => logger.error({ err }, 'Sheets worker error'));
sheetsWorker.on('failed', (job, err) => logger.error({ jobId: job?.id, err: err.message }, 'Sheets job failed'));
sheetsWorker.on('completed', (job) => logger.info({ jobId: job.id }, 'Sheets job completed'));

// In stopWorkers(), add:
if (sheetsWorker) {
  await sheetsWorker.close();
  sheetsWorker = null;
}
```

Create handlers/events/workflow-submission.ts:
```typescript
import type { App, MessageEvent } from '@slack/bolt';
import { db, workflowConfig, googleIntegrations, workspaces } from '@slack-speak/database';
import { eq, and } from 'drizzle-orm';
import { queueSheetsWrite } from '../../jobs/queues.js';
import { logger } from '../../utils/logger.js';

export function registerWorkflowSubmissionHandler(app: App): void {
  app.event('message', async ({ event, client }) => {
    // Only process bot messages (workflow submissions are posted by a bot)
    if ((event as any).subtype !== 'bot_message' || !(event as any).bot_id) {
      return;
    }

    const botMessage = event as any;
    const channelId = botMessage.channel;
    const botId = botMessage.bot_id;

    // Find any workflow configs monitoring this channel
    const configs = await db
      .select({
        config: workflowConfig,
        workspace: workspaces,
        googleIntegration: googleIntegrations,
      })
      .from(workflowConfig)
      .innerJoin(workspaces, eq(workflowConfig.workspaceId, workspaces.id))
      .leftJoin(googleIntegrations, and(
        eq(googleIntegrations.workspaceId, workflowConfig.workspaceId),
        eq(googleIntegrations.userId, workflowConfig.userId)
      ))
      .where(
        and(
          eq(workflowConfig.channelId, channelId),
          eq(workflowConfig.enabled, true)
        )
      );

    if (configs.length === 0) return;

    // Parse workflow submission from message blocks
    const submission = parseWorkflowSubmission(botMessage);
    if (!submission) {
      logger.debug({ channelId, botId }, 'Message is not a workflow submission');
      return;
    }

    // Queue write for each config owner who has Google connected
    for (const { config, googleIntegration } of configs) {
      if (!googleIntegration?.spreadsheetId) {
        logger.debug({
          configId: config.id,
          userId: config.userId,
        }, 'Skipping - no Google Sheets configured');
        continue;
      }

      // If this is first submission from this bot, store the bot_id
      if (!config.workflowBotId) {
        await db
          .update(workflowConfig)
          .set({ workflowBotId: botId, updatedAt: new Date() })
          .where(eq(workflowConfig.id, config.id));
      }

      // Queue the write operation
      await queueSheetsWrite({
        workspaceId: config.workspaceId,
        userId: config.userId,
        spreadsheetId: googleIntegration.spreadsheetId,
        submission: {
          timestamp: new Date(parseFloat(botMessage.ts) * 1000).toISOString(),
          submitterName: submission.submitterName,
          submitterSlackId: submission.submitterSlackId,
          achievements: submission.achievements,
          focus: submission.focus,
          blockers: submission.blockers,
          shoutouts: submission.shoutouts,
        },
      });

      logger.info({
        configId: config.id,
        userId: config.userId,
        submitter: submission.submitterName,
      }, 'Queued workflow submission write');
    }
  });
}

interface ParsedSubmission {
  submitterName: string;
  submitterSlackId: string;
  achievements: string;
  focus: string;
  blockers: string;
  shoutouts: string;
}

function parseWorkflowSubmission(message: any): ParsedSubmission | null {
  const blocks = message.blocks || [];

  // Workflow forms typically have specific structure with section blocks
  // containing field labels and rich_text with values
  // This is a heuristic parser - may need adjustment based on actual workflow structure

  const fields: Record<string, string> = {};

  for (const block of blocks) {
    if (block.type === 'section' && block.text) {
      const text = block.text.text || '';
      // Look for patterns like "*Achievements*\nContent here"
      const match = text.match(/\*([^*]+)\*\n?(.*)/s);
      if (match) {
        const label = match[1].toLowerCase();
        const value = match[2].trim();
        fields[label] = value;
      }
    }
    if (block.type === 'rich_text') {
      // Handle rich text blocks
      for (const element of block.elements || []) {
        if (element.type === 'rich_text_section') {
          const textParts = element.elements
            ?.filter((e: any) => e.type === 'text')
            .map((e: any) => e.text)
            .join('');
          if (textParts) {
            // Try to extract label: value pairs
            const labelMatch = textParts.match(/^([^:]+):\s*(.*)$/s);
            if (labelMatch) {
              fields[labelMatch[1].toLowerCase()] = labelMatch[2].trim();
            }
          }
        }
      }
    }
  }

  // Check if we have minimum required fields
  const hasRequiredFields =
    fields['achievements'] || fields['accomplishments'] ||
    fields['focus'] || fields['next week'] ||
    fields['blockers'] || fields['challenges'];

  if (!hasRequiredFields) {
    return null;
  }

  // Extract submitter info from message metadata or username
  const submitterName = message.username || 'Unknown';
  const submitterSlackId = message.user || message.bot_id || '';

  return {
    submitterName,
    submitterSlackId,
    achievements: fields['achievements'] || fields['accomplishments'] || '',
    focus: fields['focus'] || fields['next week'] || '',
    blockers: fields['blockers'] || fields['challenges'] || '',
    shoutouts: fields['shoutouts'] || fields['kudos'] || '',
  };
}
```

Update handlers/events/index.ts to register the new handler:
```typescript
import { registerWorkflowSubmissionHandler } from './workflow-submission.js';

export function registerEventHandlers(app: App): void {
  // ... existing handlers
  registerWorkflowSubmissionHandler(app);
}
```
  </action>
  <verify>
`npm run build --workspace=slack-backend` compiles.
Workflow submission handler is registered.
Sheets queue and worker are created.
  </verify>
  <done>
Workflow submission detection works for bot messages in monitored channels.
Submissions are parsed and queued for Google Sheets write.
Sheets worker processes writes with rate limiting.
  </done>
</task>

</tasks>

<verification>
1. `npm run db:push --workspace=@slack-speak/database` applies new table
2. `npm run build --workspace=slack-backend` compiles
3. workflowConfig table has expected schema
4. Google Sheets service exports all functions
5. Sheets queue and worker are initialized on startup
6. Event handler registered for message events
</verification>

<success_criteria>
- workflowConfig table stores channel monitoring configuration
- Google Sheets service handles append/read/status operations
- Sheets operations queued via BullMQ with rate limiting (30/min)
- Message event handler detects and parses workflow submissions
- Submissions queued for each config owner with connected Google account
- All builds pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-weekly-reports/05-03-SUMMARY.md`
</output>
