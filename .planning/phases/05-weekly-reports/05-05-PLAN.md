---
phase: 05-weekly-reports
plan: 05
type: execute
wave: 4
depends_on: ["05-04"]
files_modified:
  - apps/slack-backend/src/handlers/commands/generate-report.ts
  - apps/slack-backend/src/handlers/commands/index.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/workers.ts
autonomous: true

must_haves:
  truths:
    - "User can trigger report generation via /generate-report command"
    - "Command responds within 3 seconds with acknowledgment"
    - "Report is generated asynchronously and delivered to user"
    - "User without Google connection gets helpful error message"
  artifacts:
    - path: "apps/slack-backend/src/handlers/commands/generate-report.ts"
      provides: "Slash command handler for manual report generation"
      exports: ["registerGenerateReportCommand"]
    - path: "apps/slack-backend/src/jobs/types.ts"
      provides: "ReportGenerationJobData type"
      contains: "ReportGenerationJobData"
  key_links:
    - from: "apps/slack-backend/src/handlers/commands/generate-report.ts"
      to: "apps/slack-backend/src/jobs/queues.ts"
      via: "Queue report generation job"
      pattern: "reportQueue\\.add"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/report-generator.ts"
      via: "generateWeeklyReport call"
      pattern: "generateWeeklyReport"
---

<objective>
Implement /generate-report slash command for manual report generation with async job processing.

Purpose: Allow users to manually trigger weekly report generation when they want it on-demand rather than waiting for scheduled generation. Command acknowledges immediately and delivers report via DM.

Output: Slash command handler, report generation queue, worker that generates and delivers report.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-weekly-reports/05-RESEARCH.md
@.planning/phases/05-weekly-reports/05-04-SUMMARY.md

# Existing patterns
@apps/slack-backend/src/handlers/commands/watch.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add report generation job types and queue</name>
  <files>
apps/slack-backend/src/jobs/types.ts
apps/slack-backend/src/jobs/queues.ts
  </files>
  <action>
Add types and queue for report generation jobs.

In jobs/types.ts, add:
```typescript
export interface ReportGenerationJobData {
  workspaceId: string;
  userId: string;
  slackUserId: string; // For DM delivery
  spreadsheetId: string;
  format: 'concise' | 'detailed';
  sections: string[];
  responseUrl?: string; // For slash command delayed response
  triggeredBy: 'manual' | 'scheduled';
}

export interface ReportGenerationJobResult {
  report: string;
  submitterCount: number;
  missingSubmitters: string[];
  processingTimeMs: number;
  delivered: boolean;
}
```

In jobs/queues.ts, add:
```typescript
import type { ReportGenerationJobData } from './types.js';

export const reportQueue = new Queue<ReportGenerationJobData>('report-generation', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000, // Start at 5s for AI operations
    },
    removeOnComplete: { count: 50 },
    removeOnFail: { count: 200 },
  },
});

export async function queueReportGeneration(
  data: ReportGenerationJobData,
  options?: { priority?: number; delay?: number }
) {
  return reportQueue.add('generate-report', data, {
    priority: options?.priority,
    delay: options?.delay,
  });
}
```
  </action>
  <verify>
`npm run build --workspace=slack-backend` compiles.
Types and queue are exported correctly.
  </verify>
  <done>
ReportGenerationJobData and ReportGenerationJobResult types defined.
reportQueue created with retry logic and job retention.
queueReportGeneration helper function available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create report generation worker</name>
  <files>apps/slack-backend/src/jobs/workers.ts</files>
  <action>
Add worker to process report generation jobs.

Add imports:
```typescript
import type { ReportGenerationJobData, ReportGenerationJobResult } from './types.js';
import { generateWeeklyReport } from '../services/report-generator.js';
```

Add worker variable:
```typescript
let reportWorker: Worker<ReportGenerationJobData, ReportGenerationJobResult> | null = null;
```

In startWorkers(), add:
```typescript
reportWorker = new Worker<ReportGenerationJobData, ReportGenerationJobResult>(
  'report-generation',
  async (job) => {
    const {
      workspaceId,
      userId,
      slackUserId,
      spreadsheetId,
      format,
      sections,
      responseUrl,
      triggeredBy,
    } = job.data;

    logger.info({
      jobId: job.id,
      workspaceId,
      userId,
      triggeredBy,
    }, 'Processing report generation job');

    // Generate the report
    const result = await generateWeeklyReport({
      workspaceId,
      userId,
      spreadsheetId,
      format: format as 'concise' | 'detailed',
      sections,
    });

    // Get bot token for delivery
    const [installation] = await db
      .select({
        installation: installations,
        workspace: workspaces,
      })
      .from(installations)
      .innerJoin(workspaces, eq(installations.workspaceId, workspaces.id))
      .where(eq(workspaces.id, workspaceId))
      .limit(1);

    let delivered = false;

    if (installation) {
      const encryptionKey = getEncryptionKey();
      const botToken = decrypt(installation.installation.botToken, encryptionKey);
      const client = new WebClient(botToken);

      try {
        // Deliver via DM
        const dmResult = await client.conversations.open({
          users: slackUserId,
        });

        if (dmResult.channel?.id) {
          await client.chat.postMessage({
            channel: dmResult.channel.id,
            text: `Your weekly report is ready!`,
            blocks: [
              {
                type: 'header',
                text: {
                  type: 'plain_text',
                  text: 'Weekly Team Report',
                  emoji: true,
                },
              },
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: result.report.substring(0, 3000), // Slack limit
                },
              },
              {
                type: 'context',
                elements: [
                  {
                    type: 'mrkdwn',
                    text: `Generated from ${result.submitterCount} submission(s) | ${new Date().toLocaleDateString()}`,
                  },
                ],
              },
              {
                type: 'divider',
              },
              {
                type: 'actions',
                elements: [
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Copy Report',
                      emoji: true,
                    },
                    action_id: 'report_copy',
                    value: JSON.stringify({ report: result.report.substring(0, 2000) }),
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Refine Report',
                      emoji: true,
                    },
                    action_id: 'report_refine',
                    value: JSON.stringify({ report: result.report.substring(0, 2000) }),
                  },
                ],
              },
            ],
          });

          delivered = true;

          logger.info({
            jobId: job.id,
            userId,
            slackUserId,
            channelId: dmResult.channel.id,
          }, 'Report delivered via DM');
        }

        // Also respond to slash command if response_url provided
        if (responseUrl) {
          await fetch(responseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              response_type: 'ephemeral',
              text: 'Your weekly report has been sent to your DMs!',
            }),
          });
        }
      } catch (deliveryError) {
        logger.error({
          error: deliveryError,
          jobId: job.id,
        }, 'Failed to deliver report');
      }
    }

    return {
      report: result.report,
      submitterCount: result.submitterCount,
      missingSubmitters: result.missingSubmitters,
      processingTimeMs: result.processingTimeMs,
      delivered,
    };
  },
  {
    connection: redis,
    concurrency: 2, // Process 2 reports at a time
    limiter: {
      max: 5, // Max 5 reports per minute (AI rate limiting)
      duration: 60000,
    },
  }
);

reportWorker.on('error', (err) => logger.error({ err }, 'Report worker error'));
reportWorker.on('failed', (job, err) => logger.error({ jobId: job?.id, err: err.message }, 'Report job failed'));
reportWorker.on('completed', (job, result) => {
  logger.info({
    jobId: job.id,
    submitterCount: result.submitterCount,
    delivered: result.delivered,
    processingTimeMs: result.processingTimeMs,
  }, 'Report job completed');
});
```

In stopWorkers(), add:
```typescript
if (reportWorker) {
  await reportWorker.close();
  reportWorker = null;
}
```
  </action>
  <verify>
`npm run build --workspace=slack-backend` compiles.
Worker handles report generation and DM delivery.
  </verify>
  <done>
Report worker processes generation jobs.
Reports delivered via DM with Block Kit formatting.
Response URL used for slash command feedback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create /generate-report slash command</name>
  <files>
apps/slack-backend/src/handlers/commands/generate-report.ts
apps/slack-backend/src/handlers/commands/index.ts
  </files>
  <action>
Create slash command handler for manual report generation.

Create handlers/commands/generate-report.ts:
```typescript
import type { App } from '@slack/bolt';
import { db, googleIntegrations, reportSettings, workspaces } from '@slack-speak/database';
import { eq, and } from 'drizzle-orm';
import { queueReportGeneration } from '../../jobs/queues.js';
import { logger } from '../../utils/logger.js';

/**
 * Register /generate-report slash command
 *
 * Manually triggers weekly report generation and delivers to user's DM
 */
export function registerGenerateReportCommand(app: App): void {
  app.command('/generate-report', async ({ command, ack, respond }) => {
    try {
      // Acknowledge immediately (3-second requirement)
      await ack();

      const { team_id, user_id, response_url } = command;

      // Get workspace ID
      const [workspace] = await db
        .select()
        .from(workspaces)
        .where(eq(workspaces.teamId, team_id))
        .limit(1);

      if (!workspace) {
        await respond({
          response_type: 'ephemeral',
          text: 'Workspace not found. Please reinstall the app.',
        });
        return;
      }

      // Check if user has Google connected
      const [integration] = await db
        .select()
        .from(googleIntegrations)
        .where(
          and(
            eq(googleIntegrations.workspaceId, workspace.id),
            eq(googleIntegrations.userId, user_id)
          )
        )
        .limit(1);

      if (!integration?.spreadsheetId) {
        await respond({
          response_type: 'ephemeral',
          text: 'Please connect your Google account and configure a spreadsheet first. Visit the web portal to set up weekly reports.',
        });
        return;
      }

      // Get user's report settings
      const [settings] = await db
        .select()
        .from(reportSettings)
        .where(
          and(
            eq(reportSettings.workspaceId, workspace.id),
            eq(reportSettings.userId, user_id)
          )
        )
        .limit(1);

      const format = (settings?.format as 'concise' | 'detailed') || 'detailed';
      const sections = (settings?.sections as string[]) || ['achievements', 'focus', 'blockers', 'shoutouts'];

      // Queue report generation
      await queueReportGeneration({
        workspaceId: workspace.id,
        userId: user_id,
        slackUserId: user_id,
        spreadsheetId: integration.spreadsheetId,
        format,
        sections,
        responseUrl: response_url,
        triggeredBy: 'manual',
      });

      await respond({
        response_type: 'ephemeral',
        text: 'Generating your weekly report... I\'ll send it to your DMs when ready.',
      });

      logger.info({
        workspaceId: workspace.id,
        teamId: team_id,
        userId: user_id,
      }, 'Manual report generation queued');
    } catch (error) {
      logger.error({ error, command: '/generate-report' }, 'Failed to process /generate-report command');

      try {
        await respond({
          response_type: 'ephemeral',
          text: 'Failed to start report generation. Please try again.',
        });
      } catch (respondError) {
        logger.error({ error: respondError }, 'Failed to send error response');
      }
    }
  });
}
```

Update handlers/commands/index.ts:
```typescript
import { registerGenerateReportCommand } from './generate-report.js';

export function registerCommandHandlers(app: App): void {
  // ... existing commands
  registerGenerateReportCommand(app);
}
```
  </action>
  <verify>
`npm run build --workspace=slack-backend` compiles.
Command handler is registered.
  </verify>
  <done>
/generate-report command acknowledges within 3 seconds.
Validates Google connection before queuing.
Uses user's report settings for format/sections.
Queues async report generation job.
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=slack-backend` compiles
2. /generate-report command is registered
3. Command validates Google connection
4. Job is queued with correct data
5. Worker generates and delivers report via DM
</verification>

<success_criteria>
- /generate-report slash command registered and acknowledges immediately
- Command checks for Google integration before proceeding
- Report generation queued asynchronously
- Worker generates report using configured format/sections
- Report delivered via DM with Block Kit formatting
- Response URL used for slash command feedback
</success_criteria>

<output>
After completion, create `.planning/phases/05-weekly-reports/05-05-SUMMARY.md`
</output>
