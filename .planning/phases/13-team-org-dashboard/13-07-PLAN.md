---
phase: 13-team-org-dashboard
plan: 07
type: execute
wave: 3
depends_on: ["13-03", "13-04", "13-06"]
files_modified:
  - apps/slack-backend/src/services/ai.ts
  - apps/slack-backend/src/services/guardrails.ts
  - apps/slack-backend/src/services/org-style.ts
  - apps/slack-backend/src/services/template-matcher.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/jobs/data-retention.ts
  - apps/slack-backend/src/jobs/worker.ts
autonomous: true

must_haves:
  truths:
    - "AI suggestions are filtered through guardrails before delivery"
    - "AI applies org-wide style guidelines according to the configured style mode"
    - "AI can incorporate approved response templates when relevant"
    - "Guardrail violations are logged and trigger configured behavior (block/regenerate/warn)"
    - "Data retention job cleans up old audit data based on plan retention period"
    - "YOLO mode check uses org settings for auto-send permission"
  artifacts:
    - path: "apps/slack-backend/src/services/guardrails.ts"
      provides: "Guardrail checking and violation logging for slack-backend"
      exports: ["checkAndEnforceGuardrails"]
    - path: "apps/slack-backend/src/services/org-style.ts"
      provides: "Org style resolution combining org and user preferences"
      exports: ["resolveStyleContext", "checkYoloPermission"]
    - path: "apps/slack-backend/src/services/template-matcher.ts"
      provides: "Template matching for AI context injection"
      exports: ["findRelevantTemplates"]
    - path: "apps/slack-backend/src/jobs/data-retention.ts"
      provides: "Scheduled job for cleaning expired audit/feedback data"
      exports: ["processDataRetention"]
  key_links:
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/guardrails.ts"
      via: "post-generation filtering"
      pattern: "checkAndEnforceGuardrails"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/org-style.ts"
      via: "style context injection into prompt"
      pattern: "resolveStyleContext"
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/template-matcher.ts"
      via: "template context injection"
      pattern: "findRelevantTemplates"
    - from: "apps/slack-backend/src/jobs/worker.ts"
      to: "apps/slack-backend/src/jobs/data-retention.ts"
      via: "BullMQ job processor"
      pattern: "data-retention"
---

<objective>
Wire guardrails, org-wide style, and response templates into the AI suggestion generation flow. Add data retention cleanup job. This plan connects the admin-configured features (Plans 03, 04, 06) to the actual AI pipeline in slack-backend.

Purpose: Makes all admin dashboard configurations effective -- guardrails filter AI output, org style influences generation, templates provide context, and data retention enforces plan limits.
Output: Guardrails enforcement, org style resolution, template matching, data retention job in slack-backend.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-team-org-dashboard/13-CONTEXT.md
@.planning/phases/13-team-org-dashboard/13-03-SUMMARY.md
@.planning/phases/13-team-org-dashboard/13-04-SUMMARY.md
@.planning/phases/13-team-org-dashboard/13-06-SUMMARY.md
@apps/slack-backend/src/services/ai.ts
@apps/slack-backend/src/services/index.ts
@apps/slack-backend/src/jobs/worker.ts
@apps/web-portal/lib/admin/guardrails.ts
@apps/web-portal/lib/admin/org-style.ts
@apps/web-portal/lib/admin/plan-features.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create guardrails, org-style, and template services for slack-backend</name>
  <files>
    apps/slack-backend/src/services/guardrails.ts
    apps/slack-backend/src/services/org-style.ts
    apps/slack-backend/src/services/template-matcher.ts
    apps/slack-backend/src/services/index.ts
  </files>
  <action>
    Create `apps/slack-backend/src/services/guardrails.ts`:
    - Import guardrailConfig, guardrailViolations from database schema
    - **getGuardrailConfig(organizationId)**: Fetch config from DB (cache-friendly, no mutations)
    - **checkGuardrails(text, config)**: Same logic as web-portal version:
      - Check custom keywords (case-insensitive, word boundary regex)
      - Check enabled category keywords using PREDEFINED_CATEGORIES (duplicate the constant here for independence)
      - Return { violated: boolean, violations: Array<{ type, rule, matchedText }> }
    - **checkAndEnforceGuardrails(organizationId, workspaceId, userId, suggestionText, channelId)**: Full enforcement:
      1. Fetch guardrail config (return text unchanged if no config exists)
      2. Run checkGuardrails
      3. If no violations: return { text: suggestionText, blocked: false, warnings: [] }
      4. If violations and triggerMode='hard_block': log violations, return { text: null, blocked: true, blockReason: violations[0].rule }
      5. If violations and triggerMode='regenerate': log violations, return { text: null, blocked: false, shouldRegenerate: true, avoidTopics: violations.map(v => v.rule) }
      6. If violations and triggerMode='soft_warning': log violations, return { text: suggestionText, blocked: false, warnings: violations.map(v => `Contains ${v.rule}`) }
    - Log each violation via DB insert (fire-and-forget, wrapped in try/catch)
    - Include suggestionText in violation log ONLY (plan-gated visibility is enforced at read time in web-portal)

    Create `apps/slack-backend/src/services/org-style.ts`:
    - Import orgStyleSettings, userStylePreferences from database schema
    - **resolveStyleContext(organizationId, workspaceId, userId)**: Combine org + user style based on styleMode:
      - Fetch org settings and user preferences
      - If no org settings: return user preferences only
      - If styleMode='override': return org settings only (ignore user)
      - If styleMode='layer': merge -- org provides base, user overrides where set (non-null user values win)
      - If styleMode='fallback': user preferences first, org fills null gaps
      - Return combined: { tone, formality, preferredPhrases, avoidPhrases, customGuidance }
    - **checkYoloPermission(organizationId, userId)**: Check if YOLO auto-send is allowed:
      - Fetch org settings
      - If user has override in yoloModeUserOverrides, use that
      - Otherwise use yoloModeGlobal
      - Default false if no settings exist

    Create `apps/slack-backend/src/services/template-matcher.ts`:
    - Import responseTemplates from database schema
    - **findRelevantTemplates(organizationId, triggerMessage, maxResults?)**: Simple keyword matching:
      - Fetch approved templates for org
      - Score each template by keyword overlap with triggerMessage (split into words, count matches)
      - Return top N (default 2) templates with score > threshold (at least 1 keyword match)
      - Return empty array if no matches (templates are optional context, not required)
      - Format output for AI prompt injection: "Relevant team templates:\n- [name]: [content preview]"

    Update `apps/slack-backend/src/services/index.ts`:
    - Export functions from all 3 new services
  </action>
  <verify>TypeScript compiles. Grep for 'checkAndEnforceGuardrails' in guardrails.ts. Grep for 'resolveStyleContext' in org-style.ts. Grep for 'findRelevantTemplates' in template-matcher.ts.</verify>
  <done>Three new services created with guardrail enforcement, style resolution, and template matching.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate into AI service and add data retention job</name>
  <files>
    apps/slack-backend/src/services/ai.ts
    apps/slack-backend/src/jobs/data-retention.ts
    apps/slack-backend/src/jobs/worker.ts
  </files>
  <action>
    Update `apps/slack-backend/src/services/ai.ts`:
    - Import resolveStyleContext, checkAndEnforceGuardrails, findRelevantTemplates
    - In the main suggestion generation function (generateSuggestion or similar):
      1. **Before AI call:** Resolve style context using resolveStyleContext()
         - Inject org style into the system prompt alongside existing user style
         - Format: "Organization style guidelines: [tone], [formality], [guidance]"
      2. **Before AI call:** Find relevant templates using findRelevantTemplates()
         - If templates found, add to context: "Relevant team response templates that may help:\n..."
      3. **After AI call:** Check guardrails using checkAndEnforceGuardrails()
         - If blocked: return error message to user via ephemeral: "This suggestion was blocked by your organization's content guardrails."
         - If shouldRegenerate: call AI again with additional instruction: "Avoid these topics: [avoidTopics]. Generate an alternative suggestion."
           - Max 1 retry to prevent infinite loops
         - If warnings: append warning footer to suggestion: "\n\n:warning: Note: This suggestion may contain content flagged by org guardrails: [warnings]"
    - All new calls wrapped in try/catch with graceful fallback (fail open -- guardrails/style/templates should never block core suggestion generation)
    - Add logging for guardrail blocks and regenerations

    Create `apps/slack-backend/src/jobs/data-retention.ts`:
    - **processDataRetention()**: Cleanup expired data:
      1. Fetch all organizations with their planId
      2. For each org: get dataRetentionDays from PLAN_FEATURES (import from a shared config or duplicate minimal version)
      3. Calculate cutoff date: new Date() - retentionDays
      4. Delete from suggestionFeedback WHERE workspaceId matches AND createdAt < cutoff
      5. Delete from guardrailViolations WHERE organizationId matches AND createdAt < cutoff
      6. Delete from auditLogs WHERE workspaceId matches AND createdAt < cutoff
      7. Log counts: "Cleaned X feedback, Y violations, Z audit logs for org [name]"
      8. Process orgs in batches (500 records max per delete to prevent long transactions)

    Update `apps/slack-backend/src/jobs/worker.ts`:
    - Register 'data-retention' job processor
    - Add BullMQ Job Scheduler: repeat at '0 3 * * *' (3 AM daily UTC)
    - Pattern follows existing report scheduler setup
  </action>
  <verify>Grep ai.ts for 'checkAndEnforceGuardrails' and 'resolveStyleContext'. Check data-retention.ts exists. Check worker.ts registers data-retention processor.</verify>
  <done>AI flow integrates guardrails, org style, and templates. Data retention job runs daily at 3 AM.</done>
</task>

</tasks>

<verification>
- `grep 'resolveStyleContext' apps/slack-backend/src/services/ai.ts` shows style integration
- `grep 'checkAndEnforceGuardrails' apps/slack-backend/src/services/ai.ts` shows guardrail enforcement
- `grep 'findRelevantTemplates' apps/slack-backend/src/services/ai.ts` shows template context
- `grep 'data-retention' apps/slack-backend/src/jobs/worker.ts` shows job registration
- `ls apps/slack-backend/src/jobs/data-retention.ts` exists
- TypeScript compiles clean
</verification>

<success_criteria>
- AI suggestions pass through guardrail checks after generation
- Guardrail violations trigger correct behavior based on triggerMode
- Org style guidelines influence AI prompt based on styleMode
- Relevant approved templates are injected as context
- Data retention job runs daily and cleans expired data
- All integrations fail gracefully (never block core functionality)
- YOLO mode permission check available for auto-send flow
</success_criteria>

<output>
After completion, create `.planning/phases/13-team-org-dashboard/13-07-SUMMARY.md`
</output>
