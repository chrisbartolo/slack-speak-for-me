---
phase: 19-satisfaction-measurement
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - apps/slack-backend/src/services/satisfaction-survey.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/handlers/actions/satisfaction-survey.ts
  - apps/slack-backend/src/handlers/actions/index.ts
  - apps/slack-backend/src/app.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/jobs/schedulers.ts
  - apps/slack-backend/src/jobs/index.ts
  - apps/slack-backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Satisfaction surveys are delivered as Slack Block Kit DMs with 0-10 radio buttons"
    - "Survey frequency is enforced (minimum 30-day gap per user)"
    - "Survey responses are stored with NPS category and feedback text"
    - "Weekly BullMQ job delivers surveys to eligible users"
  artifacts:
    - path: "apps/slack-backend/src/services/satisfaction-survey.ts"
      provides: "Survey Block Kit builder, delivery, frequency check, response recording"
      exports: ["buildSurveyBlocks", "deliverSurvey", "canSurveyUser", "recordSurveyResponse"]
    - path: "apps/slack-backend/src/handlers/actions/satisfaction-survey.ts"
      provides: "Slack action handlers for survey submission"
      exports: ["registerSatisfactionSurveyActions"]
    - path: "apps/slack-backend/src/jobs/schedulers.ts"
      provides: "Weekly survey delivery scheduler"
      contains: "setupSatisfactionSurveyScheduler"
  key_links:
    - from: "apps/slack-backend/src/handlers/actions/satisfaction-survey.ts"
      to: "apps/slack-backend/src/services/satisfaction-survey.ts"
      via: "recordSurveyResponse import"
      pattern: "recordSurveyResponse"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/satisfaction-survey.ts"
      via: "canSurveyUser and deliverSurvey imports"
      pattern: "deliverSurvey|canSurveyUser"
    - from: "apps/slack-backend/src/index.ts"
      to: "apps/slack-backend/src/jobs/schedulers.ts"
      via: "setupSatisfactionSurveyScheduler call on startup"
      pattern: "setupSatisfactionSurveyScheduler"
---

<objective>
Build the satisfaction survey service with Slack Block Kit delivery, action handlers for recording responses, and a BullMQ scheduled job for weekly survey delivery.

Purpose: Enable periodic NPS satisfaction surveys delivered via Slack DM to measure user satisfaction with the product. Users respond asynchronously with a 0-10 rating and optional feedback.
Output: Complete survey delivery pipeline from scheduled job through Slack DM to response recording.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-satisfaction-measurement/19-RESEARCH.md
@packages/database/src/schema.ts
@apps/slack-backend/src/services/index.ts
@apps/slack-backend/src/handlers/actions/index.ts
@apps/slack-backend/src/jobs/types.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/schedulers.ts
@apps/slack-backend/src/jobs/index.ts
@apps/slack-backend/src/index.ts
@apps/slack-backend/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create satisfaction survey service</name>
  <files>apps/slack-backend/src/services/satisfaction-survey.ts, apps/slack-backend/src/services/index.ts</files>
  <action>
Create `apps/slack-backend/src/services/satisfaction-survey.ts` with these functions:

**buildSurveyBlocks(surveyId: string):** Returns Block Kit blocks array for NPS survey DM:
- Header block: "Quick Feedback"
- Section: "On a scale from 0 to 10, how likely are you to recommend Slack Speak for Me to a colleague?"
- Actions block with `radio_buttons` element, action_id `satisfaction_rating`, block_id `satisfaction_survey_{surveyId}`, 11 options (0-10 as plain_text)
- Context block: "0 = Not at all likely  |  10 = Extremely likely"
- Input block (optional: true): "What can we improve?" with plain_text_input, action_id `feedback_text`, multiline true, max_length 500, block_id `satisfaction_feedback`
- Actions block: Submit button (action_id `submit_satisfaction_survey`, value = surveyId, style `primary`) and Dismiss button (action_id `dismiss_satisfaction_survey`, value = surveyId)

**categorizNPS(rating: number): 'promoter' | 'passive' | 'detractor':**
- 9-10 = promoter, 7-8 = passive, 0-6 = detractor

**canSurveyUser(workspaceId: string, userId: string): Promise<boolean>:**
- Query satisfactionSurveys for most recent survey for this workspace+user
- Return true if no previous survey OR last survey was 30+ days ago
- Use `desc(satisfactionSurveys.deliveredAt)` and `.limit(1)`

**deliverSurvey(client: WebClient, workspaceId: string, organizationId: string, userId: string): Promise<string | null>:**
- Check canSurveyUser first, return null if too soon
- Generate survey ID: `crypto.randomUUID()`
- Insert row into satisfactionSurveys: organizationId, workspaceId, userId, surveyType 'nps', status 'delivered'
- Call client.chat.postMessage({ channel: userId, text: 'Quick feedback request', blocks: buildSurveyBlocks(surveyId) })
- Update the row with slackMessageTs from postMessage result
- Return surveyId
- Wrap in try/catch, log errors with logger.warn (fire-and-forget safe)

**recordSurveyResponse(surveyId: string, rating: number, feedbackText?: string): Promise<void>:**
- Update satisfactionSurveys row: set rating, npsCategory (from categorizeNPS), feedbackText, status 'completed', respondedAt to now
- Log with logger.info

**expireOldSurveys(): Promise<number>:**
- Update all surveys where status='delivered' AND deliveredAt < 7 days ago -> set status='expired', expiredAt=now
- Return count of expired surveys

Export all functions from services/index.ts:
```typescript
export {
  buildSurveyBlocks,
  canSurveyUser,
  deliverSurvey,
  recordSurveyResponse,
  expireOldSurveys,
  categorizeNPS,
} from './satisfaction-survey.js';
```

Import WebClient from '@slack/web-api'. Import db, satisfactionSurveys from '@slack-speak/database'. Import logger from '../utils/logger.js'. Use crypto import for randomUUID.
  </action>
  <verify>Run `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` to verify no type errors.</verify>
  <done>Satisfaction survey service created with all 5 functions, exports registered in services/index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create action handlers and BullMQ survey delivery job</name>
  <files>apps/slack-backend/src/handlers/actions/satisfaction-survey.ts, apps/slack-backend/src/handlers/actions/index.ts, apps/slack-backend/src/app.ts, apps/slack-backend/src/jobs/types.ts, apps/slack-backend/src/jobs/queues.ts, apps/slack-backend/src/jobs/workers.ts, apps/slack-backend/src/jobs/schedulers.ts, apps/slack-backend/src/jobs/index.ts, apps/slack-backend/src/index.ts</files>
  <action>
**1. Create action handler** `apps/slack-backend/src/handlers/actions/satisfaction-survey.ts`:

Export function `registerSatisfactionSurveyActions(app: App)`:

Register action `submit_satisfaction_survey`:
- Extract surveyId from action.value
- Extract rating from the radio_buttons state (parse block_id starting with `satisfaction_survey_`, action_id `satisfaction_rating`, get selected_option.value, parseInt)
- Extract feedback text from block state (block_id `satisfaction_feedback`, action_id `feedback_text`, get value -- may be undefined)
- Call recordSurveyResponse(surveyId, rating, feedbackText)
- Acknowledge with ack()
- Update original message to show "Thank you for your feedback!" confirmation (use respond() or client.chat.update with body.message.ts and body.channel.id)

Register action `dismiss_satisfaction_survey`:
- Extract surveyId from action.value
- Update satisfaction_surveys row: status='dismissed'
- Acknowledge with ack()
- Update message to show "Survey dismissed" with muted text

Register action `satisfaction_rating` (radio_buttons interaction requires action acknowledgment):
- Just ack() -- the submit button handles actual recording

**2. Register in actions/index.ts:**
Add import and call `registerSatisfactionSurveyActions(app)` following existing pattern.

**3. Register in app.ts:**
Ensure the action handlers module is imported and registered with the Bolt app. Check if actions/index.ts is already wired up in app.ts -- if so, just adding to index.ts is sufficient.

**4. Add job types** in `apps/slack-backend/src/jobs/types.ts`:
```typescript
export interface SatisfactionSurveyJobData {
  triggeredBy: 'schedule' | 'manual';
}

export interface SatisfactionSurveyJobResult {
  usersEligible: number;
  surveysSent: number;
  errors: number;
}
```

**5. Add queue** in `apps/slack-backend/src/jobs/queues.ts`:
```typescript
export const satisfactionSurveyQueue = new Queue<SatisfactionSurveyJobData>('satisfaction-survey', {
  connection: redis,
  defaultJobOptions: {
    attempts: 2,
    backoff: { type: 'exponential', delay: 60000 },
    removeOnComplete: { count: 50 },
    removeOnFail: { count: 100 },
  },
});
```

**6. Add worker** in `apps/slack-backend/src/jobs/workers.ts`:
Add satisfactionSurveyWorker variable and setup in startWorkers():
- Worker for 'satisfaction-survey' queue
- Fetch all active organizations
- For each org, get workspace + installation + users
- For each user, call canSurveyUser. If eligible, create WebClient from decrypted bot token and call deliverSurvey
- Also call expireOldSurveys() at the end to clean up stale surveys
- Concurrency: 1 (one batch at a time)
- Fire-and-forget per-user errors (log warn, continue to next user)
- Track usersEligible, surveysSent, errors counts
- Add to stopWorkers() cleanup

**7. Add scheduler** in `apps/slack-backend/src/jobs/schedulers.ts`:
```typescript
export async function setupSatisfactionSurveyScheduler(): Promise<void> {
  try {
    const jobData: SatisfactionSurveyJobData = { triggeredBy: 'schedule' };
    await satisfactionSurveyQueue.upsertJobScheduler(
      'weekly-satisfaction-survey',
      { pattern: '0 9 * * 1' }, // Monday 9 AM UTC
      { name: 'deliver-satisfaction-surveys', data: jobData }
    );
    logger.info('Satisfaction survey scheduler configured (Monday 9 AM UTC)');
  } catch (error) {
    logger.error({ error }, 'Failed to setup satisfaction survey scheduler');
    throw error;
  }
}
```
Import SatisfactionSurveyJobData from types, satisfactionSurveyQueue from queues.

**8. Export scheduler** in `apps/slack-backend/src/jobs/index.ts`:
Add `setupSatisfactionSurveyScheduler` to the re-exports from schedulers.

**9. Call scheduler on startup** in `apps/slack-backend/src/index.ts`:
Import and call `setupSatisfactionSurveyScheduler()` after existing scheduler setups, with matching log line.
  </action>
  <verify>Run `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` to verify no type errors.</verify>
  <done>Survey action handlers registered, BullMQ job delivers surveys weekly to eligible users, scheduler runs Monday 9 AM UTC, expired surveys cleaned up automatically.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` passes
- All new files exist and follow existing codebase patterns
- Survey service exports are accessible from services/index.ts
- Action handlers are registered in actions/index.ts
- Scheduler is called on startup in index.ts
- Worker fetches eligible users, delivers surveys, expires old ones
</verification>

<success_criteria>
- Satisfaction surveys can be delivered via Slack DM with 0-10 NPS radio buttons
- 30-day frequency cap prevents survey fatigue
- Submit and dismiss actions record responses and update original messages
- Weekly BullMQ job automatically delivers surveys to eligible users
- Expired surveys (7+ days unanswered) are cleaned up
</success_criteria>

<output>
After completion, create `.planning/phases/19-satisfaction-measurement/19-02-SUMMARY.md`
</output>
