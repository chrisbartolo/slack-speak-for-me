---
phase: 19-satisfaction-measurement
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - apps/slack-backend/src/services/health-score.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/jobs/schedulers.ts
  - apps/slack-backend/src/jobs/index.ts
  - apps/slack-backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Health score computed as weighted composite: acceptance 25%, response time 20%, sentiment 20%, satisfaction 20%, engagement 15%"
    - "All metrics normalized to 0-100 scale before weighting"
    - "Weekly job computes per-user and team-aggregate scores every Sunday 2 AM UTC"
    - "First 30 days of scores marked as baseline for before/after comparison"
    - "Users with fewer than 5 suggestions get null health score (insufficient data)"
  artifacts:
    - path: "apps/slack-backend/src/services/health-score.ts"
      provides: "Health score calculation, metric fetching, baseline detection"
      exports: ["calculateHealthScore", "fetchWeeklyMetrics", "computeAndStoreHealthScores"]
    - path: "apps/slack-backend/src/jobs/schedulers.ts"
      provides: "Weekly health score scheduler"
      contains: "setupHealthScoreScheduler"
  key_links:
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/health-score.ts"
      via: "computeAndStoreHealthScores import"
      pattern: "computeAndStoreHealthScores"
    - from: "apps/slack-backend/src/services/health-score.ts"
      to: "packages/database/src/schema.ts"
      via: "queries against suggestionFeedback, suggestionMetrics, topicClassifications, satisfactionSurveys, usageEvents"
      pattern: "suggestionFeedback|suggestionMetrics|topicClassifications|satisfactionSurveys|usageEvents"
    - from: "apps/slack-backend/src/index.ts"
      to: "apps/slack-backend/src/jobs/schedulers.ts"
      via: "setupHealthScoreScheduler call on startup"
      pattern: "setupHealthScoreScheduler"
---

<objective>
Build the health score calculator service and weekly BullMQ job that computes communication health scores (0-100) for each user and team aggregate.

Purpose: Health scores combine five metrics (acceptance rate, response time, sentiment, satisfaction, engagement) into a single 0-100 composite score that tracks communication quality over time. The first 30 days serve as baseline for before/after comparison.
Output: Health score computation service and Sunday 2 AM UTC weekly scheduled job.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-satisfaction-measurement/19-RESEARCH.md
@packages/database/src/schema.ts
@apps/slack-backend/src/services/index.ts
@apps/slack-backend/src/jobs/types.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/jobs/schedulers.ts
@apps/slack-backend/src/jobs/index.ts
@apps/slack-backend/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health score calculator service</name>
  <files>apps/slack-backend/src/services/health-score.ts, apps/slack-backend/src/services/index.ts</files>
  <action>
Create `apps/slack-backend/src/services/health-score.ts`:

**Types:**
```typescript
interface HealthMetrics {
  acceptanceRate: number | null;      // 0-1, null if no data
  avgResponseTimeMs: number | null;   // milliseconds, null if no data
  avgSentimentScore: number | null;   // 0-1, null if no data
  avgSatisfactionScore: number | null; // 0-10 NPS, null if no surveys
  engagementRate: number | null;      // 0-1, null if no data
  totalSuggestions: number;           // total suggestions in period
}

interface HealthScoreWeights {
  acceptance: number;
  responseTime: number;
  sentiment: number;
  satisfaction: number;
  engagement: number;
}
```

**DEFAULT_WEIGHTS constant:**
```typescript
const DEFAULT_WEIGHTS: HealthScoreWeights = {
  acceptance: 0.25,
  responseTime: 0.20,
  sentiment: 0.20,
  satisfaction: 0.20,
  engagement: 0.15,
};
```

**MIN_SUGGESTIONS_FOR_SCORE = 5** (below this, return null -- insufficient data)

**calculateHealthScore(metrics: HealthMetrics, weights = DEFAULT_WEIGHTS): number | null:**
- If metrics.totalSuggestions < MIN_SUGGESTIONS_FOR_SCORE, return null
- For each metric component, normalize to 0-100:
  - acceptanceRate: multiply by 100 (already 0-1). If null, use 50 (neutral default)
  - responseTime: invert (lower is better). Score = ((60000 - clamp(ms, 0, 60000)) / 60000) * 100. If null, use 50
  - sentimentScore: multiply by 100 (already 0-1). If null, use 50
  - satisfactionScore: multiply by 10 (0-10 to 0-100). If null, use 50
  - engagementRate: multiply by 100 (already 0-1). If null, use 50
- Compute weighted sum: sum(normalizedScore * weight for each component)
- Return Math.round(healthScore), clamped to 0-100

**fetchWeeklyMetrics(organizationId: string, workspaceId: string, userId: string | null, weekStart: Date, weekEnd: Date): Promise<HealthMetrics>:**
Use raw SQL queries (following trend-aggregator pattern) to fetch metrics from the past week:

1. **Acceptance rate** from suggestion_feedback: count accepted / total feedback WHERE workspaceId and createdAt between weekStart-weekEnd. If userId provided, also filter by userId.
2. **Avg response time** from suggestion_metrics: AVG(total_duration_ms) WHERE organizationId and deliveredAt between weekStart-weekEnd and total_duration_ms IS NOT NULL. Filter by userId if provided.
3. **Avg sentiment** from topic_classifications: AVG(CASE WHEN sentiment->>'tone' IN ('positive','neutral') THEN 1.0 WHEN sentiment->>'tone' = 'cautious' THEN 0.5 ELSE 0.0 END) WHERE organizationId and createdAt between weekStart-weekEnd. Filter by userId if provided.
4. **Avg satisfaction** from satisfaction_surveys: AVG(rating) WHERE organizationId and status='completed' and respondedAt between weekStart-weekEnd. Filter by userId if provided.
5. **Engagement rate** from usage_events: COUNT(DISTINCT date) / 5 (working days) WHERE organizationId and createdAt between weekStart-weekEnd. Clamp to 0-1. Filter by slackUserId if userId provided.
6. **Total suggestions** from suggestion_metrics: COUNT(*) WHERE organizationId and createdAt between weekStart-weekEnd. Filter by userId if provided.

Use `db.execute(sql`...`)` with parameterized queries. Return HealthMetrics object.

**isBaselinePeriod(organizationId: string, userId: string | null): Promise<boolean>:**
- Query communicationHealthScores for this org+user, count existing records
- If count < 5 (less than 5 weeks of data), return true (still in baseline)
- Otherwise return false

**computeAndStoreHealthScores(weekStartDate?: Date): Promise<{ orgsProcessed: number; scoresCreated: number; errors: number }>:**
- Determine weekStart (default: start of previous week, Monday-based using date-fns startOfWeek with weekStartsOn:1, then subtract 7 days)
- weekEnd = weekStart + 7 days
- Fetch all active organizations
- For each org:
  - Try/catch per org (error isolation, same pattern as trend-aggregator)
  - Get workspace for org
  - Get all users for workspace
  - For each user: fetchWeeklyMetrics, calculateHealthScore, check isBaselinePeriod
  - If score is not null, insert into communicationHealthScores with all component values + isBaseline flag
  - Also compute team aggregate: fetchWeeklyMetrics with userId=null, calculateHealthScore, insert with userId=null
  - Track scoresCreated count
- Return summary object

Export from services/index.ts:
```typescript
export {
  calculateHealthScore,
  fetchWeeklyMetrics,
  computeAndStoreHealthScores,
} from './health-score.js';
```

Import db, organizations, workspaces, users, communicationHealthScores from '@slack-speak/database'. Import sql, eq, and, gte, lt, count from 'drizzle-orm'. Import logger from '../utils/logger.js'.
  </action>
  <verify>Run `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` to verify no type errors.</verify>
  <done>Health score calculator service with weighted composite scoring, metric fetching from 5 data sources, baseline detection, and batch computation for all orgs/users.</done>
</task>

<task type="auto">
  <name>Task 2: Add BullMQ health score job and weekly scheduler</name>
  <files>apps/slack-backend/src/jobs/types.ts, apps/slack-backend/src/jobs/queues.ts, apps/slack-backend/src/jobs/workers.ts, apps/slack-backend/src/jobs/schedulers.ts, apps/slack-backend/src/jobs/index.ts, apps/slack-backend/src/index.ts</files>
  <action>
**1. Add job types** in `apps/slack-backend/src/jobs/types.ts`:
```typescript
export interface HealthScoreJobData {
  triggeredBy: 'schedule' | 'manual';
  weekStartDate?: string; // ISO date, defaults to previous week
}

export interface HealthScoreJobResult {
  orgsProcessed: number;
  scoresCreated: number;
  errors: number;
}
```

**2. Add queue** in `apps/slack-backend/src/jobs/queues.ts`:
```typescript
export const healthScoreQueue = new Queue<HealthScoreJobData>('health-score', {
  connection: redis,
  defaultJobOptions: {
    attempts: 2,
    backoff: { type: 'exponential', delay: 60000 },
    removeOnComplete: { count: 50 },
    removeOnFail: { count: 100 },
  },
});
```
Import HealthScoreJobData from types.

**3. Add worker** in `apps/slack-backend/src/jobs/workers.ts`:
Add healthScoreWorker variable declaration at top.
In startWorkers(), add:
```typescript
healthScoreWorker = new Worker<HealthScoreJobData, HealthScoreJobResult>(
  'health-score',
  async (job) => {
    logger.info({ jobId: job.id, triggeredBy: job.data.triggeredBy }, 'Processing health score job');
    const weekStart = job.data.weekStartDate ? new Date(job.data.weekStartDate) : undefined;
    const result = await computeAndStoreHealthScores(weekStart);
    logger.info({ jobId: job.id, ...result }, 'Health score computation completed');
    return result;
  },
  { connection: redis, concurrency: 1 }
);

healthScoreWorker.on('error', (err) => logger.error({ err }, 'Health score worker error'));
healthScoreWorker.on('failed', (job, err) => logger.error({ jobId: job?.id, err: err.message }, 'Health score job failed'));
healthScoreWorker.on('completed', (job, result) => logger.info({ jobId: job.id, ...result }, 'Health score job completed'));

logger.info('Health score worker started');
```
Import computeAndStoreHealthScores from services. Import HealthScoreJobData, HealthScoreJobResult from types. Import healthScoreQueue from queues (not needed for worker but for consistency).
Add cleanup in stopWorkers().

**4. Add scheduler** in `apps/slack-backend/src/jobs/schedulers.ts`:
```typescript
export async function setupHealthScoreScheduler(): Promise<void> {
  try {
    const jobData: HealthScoreJobData = { triggeredBy: 'schedule' };
    await healthScoreQueue.upsertJobScheduler(
      'weekly-health-score',
      { pattern: '0 2 * * 0' }, // Sunday 2 AM UTC
      { name: 'calculate-health-scores', data: jobData }
    );
    logger.info('Health score scheduler configured (Sunday 2 AM UTC)');
  } catch (error) {
    logger.error({ error }, 'Failed to setup health score scheduler');
    throw error;
  }
}
```
Import HealthScoreJobData from types, healthScoreQueue from queues.

**5. Export in index.ts:**
Add `setupHealthScoreScheduler` to re-exports from schedulers in `apps/slack-backend/src/jobs/index.ts`.

**6. Call on startup** in `apps/slack-backend/src/index.ts`:
Import setupHealthScoreScheduler and call it after existing scheduler setups:
```typescript
await setupHealthScoreScheduler();
logger.info('Health score scheduler configured');
```
  </action>
  <verify>Run `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` to verify no type errors.</verify>
  <done>BullMQ health score job runs every Sunday 2 AM UTC, computes per-user and team-aggregate scores for previous week, marks baseline period scores.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project apps/slack-backend/tsconfig.json` passes
- Health score calculation uses correct weights (25/20/20/20/15)
- Metrics fetch from 5 data sources (feedback, metrics, classifications, surveys, usage)
- Insufficient data (< 5 suggestions) returns null score
- Baseline period detected for first 5 weeks of data
- Weekly scheduler configured for Sunday 2 AM UTC
- Error isolation per org in batch computation
</verification>

<success_criteria>
- calculateHealthScore produces 0-100 composite with correct weights
- All 5 metric sources queried with proper date filtering
- Users with < 5 suggestions get null (insufficient data) instead of misleading score
- First 30 days (approx 5 weekly scores) flagged as baseline
- Team aggregate score computed alongside individual user scores
- Sunday 2 AM UTC scheduler registered on startup
</success_criteria>

<output>
After completion, create `.planning/phases/19-satisfaction-measurement/19-03-SUMMARY.md`
</output>
