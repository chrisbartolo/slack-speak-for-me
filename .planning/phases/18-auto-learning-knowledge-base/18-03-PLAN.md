---
phase: 18-auto-learning-knowledge-base
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - apps/slack-backend/src/services/kb-effectiveness.ts
  - apps/slack-backend/src/services/ai.ts
  - apps/slack-backend/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - "When KB docs are used in suggestion generation, usage is tracked in kb_effectiveness table"
    - "Effectiveness data links KB document usage to suggestion outcomes (accepted/refined/dismissed)"
    - "Low-performing KB docs (below 30% acceptance rate) can be identified"
  artifacts:
    - path: "apps/slack-backend/src/services/kb-effectiveness.ts"
      provides: "recordKBUsage and getKBEffectiveness functions"
      exports: ["recordKBUsage", "getKBEffectiveness"]
    - path: "apps/slack-backend/src/services/ai.ts"
      provides: "KB usage tracking integrated into suggestion generation"
      contains: "recordKBUsage"
  key_links:
    - from: "apps/slack-backend/src/services/ai.ts"
      to: "apps/slack-backend/src/services/kb-effectiveness.ts"
      via: "recordKBUsage call after KB search returns results"
      pattern: "recordKBUsage"
    - from: "apps/slack-backend/src/services/kb-effectiveness.ts"
      to: "packages/database/src/schema.ts"
      via: "kbEffectiveness table insert and join queries"
      pattern: "kbEffectiveness"
---

<objective>
Build KB effectiveness tracking service and integrate it into the AI suggestion generation pipeline.

Purpose: Track which KB documents are actually used when generating suggestions, then correlate with suggestion outcomes (accepted/refined/dismissed) to measure each document's effectiveness. This is the feedback loop that tells admins which KB content is valuable and which should be removed.
Output: kb-effectiveness.ts service with recording and query functions, integrated into ai.ts suggestion generation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-auto-learning-knowledge-base/18-RESEARCH.md
@.planning/phases/18-auto-learning-knowledge-base/18-01-SUMMARY.md
@packages/database/src/schema.ts
@apps/slack-backend/src/services/ai.ts
@apps/slack-backend/src/services/knowledge-base.ts
@apps/slack-backend/src/services/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create kb-effectiveness service</name>
  <files>apps/slack-backend/src/services/kb-effectiveness.ts</files>
  <action>
Create `kb-effectiveness.ts` following existing service patterns (suggestion-metrics.ts for fire-and-forget recording, knowledge-base.ts for DB query patterns).

**Export 1: `recordKBUsage`** (fire-and-forget)
- Takes: `{ suggestionId: string, organizationId: string, kbDocumentIds: string[], similarities: number[] }`
- Inserts one row per KB document used into kbEffectiveness table
- Each row: suggestionId, kbDocumentId, organizationId, similarity (convert float 0-1 to integer 0-100 by multiplying by 100)
- Wrap entire function in try/catch, log with logger.warn on failure, never throw
- Use batch insert: `db.insert(kbEffectiveness).values(records)`

**Export 2: `getKBEffectiveness`**
- Takes: `organizationId: string, options?: { days?: number }`
- Returns per-document effectiveness by joining kbEffectiveness with suggestionFeedback
- SQL query (use `db.execute(sql`...`)` pattern from trend-aggregator.ts):
  ```sql
  SELECT
    ke.kb_document_id as "documentId",
    kbd.title,
    kbd.category,
    COUNT(ke.id) as "timesUsed",
    COUNT(DISTINCT ke.suggestion_id) as "uniqueSuggestions",
    SUM(CASE WHEN sf.action = 'accepted' THEN 1 ELSE 0 END) as "acceptedCount",
    SUM(CASE WHEN sf.action = 'refined' THEN 1 ELSE 0 END) as "refinedCount",
    SUM(CASE WHEN sf.action = 'dismissed' THEN 1 ELSE 0 END) as "dismissedCount",
    ROUND(
      SUM(CASE WHEN sf.action = 'accepted' THEN 1 ELSE 0 END)::numeric /
      NULLIF(COUNT(ke.id), 0) * 100
    ) as "acceptanceRate",
    ROUND(AVG(ke.similarity)) as "avgSimilarity"
  FROM kb_effectiveness ke
  JOIN knowledge_base_documents kbd ON ke.kb_document_id = kbd.id
  LEFT JOIN suggestion_feedback sf ON ke.suggestion_id = sf.suggestion_id
  WHERE ke.organization_id = $orgId
    AND ke.created_at > NOW() - INTERVAL '$days days'
  GROUP BY ke.kb_document_id, kbd.title, kbd.category
  ORDER BY "timesUsed" DESC
  ```
- Default days = 30
- Return typed array with documentId, title, category, timesUsed, uniqueSuggestions, acceptedCount, refinedCount, dismissedCount, acceptanceRate, avgSimilarity

**Export 3: `getLowPerformingDocs`**
- Takes: `organizationId: string`
- Calls getKBEffectiveness then filters to documents with acceptanceRate < 30 and timesUsed >= 5 (enough data to be meaningful)
- Returns same type as getKBEffectiveness but filtered

Import: db, kbEffectiveness, knowledgeBaseDocuments, suggestionFeedback from '@slack-speak/database'. Import sql from 'drizzle-orm'. Import logger from '../utils/logger.js'.
  </action>
  <verify>Run `npx tsc --noEmit --project /Users/christopherbartolo/Documents/GitHub/slack-speak-for-me/apps/slack-backend/tsconfig.json` to confirm no type errors.</verify>
  <done>kb-effectiveness.ts exports recordKBUsage (fire-and-forget), getKBEffectiveness (query), and getLowPerformingDocs (filtered query). All handle errors gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate KB usage tracking into AI service and exports</name>
  <files>
    apps/slack-backend/src/services/ai.ts
    apps/slack-backend/src/services/index.ts
  </files>
  <action>
**ai.ts** -- Find the section where `searchKnowledgeBase` is called during suggestion generation. After KB search returns results and before the results are used in the prompt, add fire-and-forget KB usage tracking:

```typescript
import { recordKBUsage } from './kb-effectiveness.js';

// After searchKnowledgeBase returns kbResults:
if (kbResults.length > 0) {
  // Fire-and-forget: track which KB docs were used for this suggestion
  recordKBUsage({
    suggestionId: context.suggestionId, // or however suggestionId is accessed
    organizationId: context.organizationId, // or however org ID is accessed
    kbDocumentIds: kbResults.map(r => r.id),
    similarities: kbResults.map(r => r.similarity),
  }).catch(() => {}); // Non-blocking
}
```

The key is to find WHERE searchKnowledgeBase is called, understand the variable names for suggestionId and organizationId in that scope, and add the recordKBUsage call with the correct variable references. Do NOT modify any other logic in ai.ts. This is a pure addition.

If suggestionId or organizationId are not available in the scope where KB search happens, trace them through the function parameters. The generateSuggestion function receives context that should contain these values (check the function signature and the AIResponseJobData type).

**index.ts** -- Add exports for the new service:
```typescript
// KB effectiveness - track knowledge base document impact on suggestions
export {
  recordKBUsage,
  getKBEffectiveness,
  getLowPerformingDocs,
} from './kb-effectiveness.js';
```
  </action>
  <verify>Run `npx tsc --noEmit --project /Users/christopherbartolo/Documents/GitHub/slack-speak-for-me/apps/slack-backend/tsconfig.json` to confirm no type errors. Grep for `recordKBUsage` in ai.ts to confirm integration exists.</verify>
  <done>AI service tracks KB document usage during suggestion generation via fire-and-forget recordKBUsage call. Effectiveness service exported from index.ts.</done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit` in apps/slack-backend passes
- kb-effectiveness.ts exports three functions
- ai.ts calls recordKBUsage after KB search results are retrieved
- Fire-and-forget pattern used (`.catch(() => {})`)
- No existing tests broken
</verification>

<success_criteria>
- Every suggestion that uses KB docs has usage tracked in kb_effectiveness table
- getKBEffectiveness returns per-document acceptance rates and usage counts
- getLowPerformingDocs surfaces documents with below 30% acceptance rate
- Zero latency impact on suggestion generation (fire-and-forget)
</success_criteria>

<output>
After completion, create `.planning/phases/18-auto-learning-knowledge-base/18-03-SUMMARY.md`
</output>
