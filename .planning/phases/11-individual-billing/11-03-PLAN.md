---
phase: 11-individual-billing
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - apps/web-portal/lib/billing/access-check.ts
  - apps/web-portal/app/api/stripe/user-portal/route.ts
autonomous: true

must_haves:
  truths:
    - "Access check correctly identifies individual subscription holders"
    - "Access check falls back to organization subscription if no individual sub"
    - "User can open Stripe Customer Portal for individual subscription"
  artifacts:
    - path: "apps/web-portal/lib/billing/access-check.ts"
      provides: "checkUserAccess function with dual-path logic"
      exports: ["checkUserAccess", "AccessResult"]
    - path: "apps/web-portal/app/api/stripe/user-portal/route.ts"
      provides: "Individual user portal endpoint"
      exports: ["POST"]
  key_links:
    - from: "apps/web-portal/lib/billing/access-check.ts"
      to: "userSubscriptions"
      via: "database query for individual subscription"
      pattern: "userSubscriptions"
    - from: "apps/web-portal/lib/billing/access-check.ts"
      to: "organizations"
      via: "database query for org subscription fallback"
      pattern: "organizations"
---

<objective>
Create dual-path access checking service and individual user portal endpoint.

Purpose: Users may have access via individual subscription OR organization-provided access. The system must check both and prioritize individual (user may leave org but keep personal sub). User portal allows managing individual subscription via Stripe.
Output: checkUserAccess function and /api/stripe/user-portal endpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-individual-billing/11-RESEARCH.md
@.planning/phases/11-individual-billing/11-01-SUMMARY.md
@apps/web-portal/lib/billing/seat-enforcement.ts
@apps/web-portal/lib/stripe.ts
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dual-path access checking service</name>
  <files>apps/web-portal/lib/billing/access-check.ts</files>
  <action>
Create new file apps/web-portal/lib/billing/access-check.ts:

```typescript
import 'server-only';
import { db, schema } from '@/lib/db';
import { eq } from 'drizzle-orm';

const { userSubscriptions, workspaces, organizations } = schema;

/**
 * Result of access check - indicates whether user has access and why
 */
export type AccessResult =
  | {
      hasAccess: true;
      source: 'individual' | 'organization';
      status: 'active' | 'trialing';
      planId: string | null;
    }
  | {
      hasAccess: false;
      reason: 'no_subscription' | 'paused' | 'canceled' | 'expired';
    };

/**
 * Check if user has access to premium features
 *
 * Priority order:
 * 1. Individual subscription (by email) - checked first
 * 2. Organization subscription (via workspace) - fallback
 *
 * This priority ensures users who leave an org but have personal subs
 * retain access, and users with both don't get double-counted.
 *
 * @param email User email (lowercased)
 * @param workspaceId Internal workspace UUID
 */
export async function checkUserAccess(
  email: string | null,
  workspaceId: string
): Promise<AccessResult> {
  // Priority 1: Check individual subscription by email
  if (email) {
    const userSub = await db.query.userSubscriptions.findFirst({
      where: eq(userSubscriptions.email, email.toLowerCase()),
    });

    if (userSub) {
      if (userSub.subscriptionStatus === 'active' || userSub.subscriptionStatus === 'trialing') {
        return {
          hasAccess: true,
          source: 'individual',
          status: userSub.subscriptionStatus as 'active' | 'trialing',
          planId: userSub.planId,
        };
      }
      if (userSub.subscriptionStatus === 'paused') {
        // Individual sub is paused - check if org access is available
        // before returning paused (they might have org coverage)
      }
      if (userSub.subscriptionStatus === 'canceled') {
        // Continue to check org access
      }
    }
  }

  // Priority 2: Check organization subscription via workspace
  const workspace = await db.query.workspaces.findFirst({
    where: eq(workspaces.id, workspaceId),
  });

  if (workspace?.organizationId) {
    const org = await db.query.organizations.findFirst({
      where: eq(organizations.id, workspace.organizationId),
    });

    if (org) {
      const orgStatus = org.subscriptionStatus;
      if (orgStatus === 'active' || orgStatus === 'trialing') {
        return {
          hasAccess: true,
          source: 'organization',
          status: orgStatus as 'active' | 'trialing',
          planId: org.planId,
        };
      }
      // past_due still allows access while Stripe retries
      if (orgStatus === 'past_due') {
        return {
          hasAccess: true,
          source: 'organization',
          status: 'active', // Treat past_due as active
          planId: org.planId,
        };
      }
      if (orgStatus === 'paused') {
        return { hasAccess: false, reason: 'paused' };
      }
      if (orgStatus === 'canceled') {
        return { hasAccess: false, reason: 'canceled' };
      }
    }
  }

  // Check if individual subscription was paused (after org check failed)
  if (email) {
    const userSub = await db.query.userSubscriptions.findFirst({
      where: eq(userSubscriptions.email, email.toLowerCase()),
    });

    if (userSub?.subscriptionStatus === 'paused') {
      return { hasAccess: false, reason: 'paused' };
    }
    if (userSub?.subscriptionStatus === 'canceled') {
      return { hasAccess: false, reason: 'canceled' };
    }
  }

  return { hasAccess: false, reason: 'no_subscription' };
}

/**
 * Get individual subscription details for a user
 */
export async function getIndividualSubscription(email: string) {
  if (!email) return null;

  return db.query.userSubscriptions.findFirst({
    where: eq(userSubscriptions.email, email.toLowerCase()),
  });
}

/**
 * Check if user has an active individual subscription
 */
export async function hasIndividualSubscription(email: string): Promise<boolean> {
  const sub = await getIndividualSubscription(email);
  return sub?.subscriptionStatus === 'active' || sub?.subscriptionStatus === 'trialing';
}
```

Key design decisions:
- Individual subscription checked FIRST (priority over org)
- past_due treated as active (Stripe is retrying payment)
- Returns source so UI can show appropriate messaging
- Separate helper functions for individual sub queries
  </action>
  <verify>
Run `npm run typecheck --workspace=web-portal` to verify types compile.
Verify AccessResult type covers all cases.
  </verify>
  <done>checkUserAccess function exists with dual-path logic, getIndividualSubscription and hasIndividualSubscription helpers exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create user portal endpoint for individual subscriptions</name>
  <files>apps/web-portal/app/api/stripe/user-portal/route.ts</files>
  <action>
Create new file apps/web-portal/app/api/stripe/user-portal/route.ts:

```typescript
import { NextResponse } from 'next/server';
import { verifySession } from '@/lib/auth/dal';
import { createPortalSession } from '@/lib/stripe';
import { getIndividualSubscription } from '@/lib/billing/access-check';

/**
 * POST /api/stripe/user-portal
 *
 * Creates a Stripe Customer Portal session for individual subscriptions.
 * Unlike /api/stripe/portal (org admin), this uses the user's email to find
 * their individual subscription customer.
 */
export async function POST() {
  try {
    const session = await verifySession();

    if (!session.email) {
      return NextResponse.json(
        { error: 'Email required for individual billing' },
        { status: 400 }
      );
    }

    const userSub = await getIndividualSubscription(session.email);

    if (!userSub?.stripeCustomerId) {
      return NextResponse.json(
        { error: 'No individual subscription found' },
        { status: 404 }
      );
    }

    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://speakforme.app';

    const portalSession = await createPortalSession(
      userSub.stripeCustomerId,
      `${baseUrl}/settings/billing`
    );

    return NextResponse.redirect(portalSession.url);
  } catch (error) {
    console.error('User portal error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create portal session' },
      { status: 500 }
    );
  }
}
```

Key design decisions:
- Uses verifySession (not requireAdmin) - any authenticated user can access
- Looks up subscription by email, not organization
- Returns redirect to Stripe portal (consistent with org portal behavior)
- Returns 404 if no individual subscription found (user should subscribe first)
- Return URL is /settings/billing (individual billing page, created in Plan 05)
  </action>
  <verify>
Run `npm run typecheck --workspace=web-portal` to verify types compile.
Verify endpoint file is in correct location for Next.js routing.
  </verify>
  <done>POST /api/stripe/user-portal endpoint exists and creates portal session for individual subscriptions.</done>
</task>

</tasks>

<verification>
1. checkUserAccess function checks individual subscription first, then org
2. checkUserAccess returns correct AccessResult for all subscription states
3. User portal endpoint authenticates user and finds individual subscription
4. User portal returns redirect to Stripe Customer Portal
</verification>

<success_criteria>
- checkUserAccess(email, workspaceId) returns correct AccessResult
- Individual subscription with active/trialing status grants access via individual source
- Org subscription fallback works when no individual subscription
- POST /api/stripe/user-portal creates portal session for individual customers
- User portal returns 404 when no individual subscription exists
</success_criteria>

<output>
After completion, create `.planning/phases/11-individual-billing/11-03-SUMMARY.md`
</output>
