---
phase: 11-individual-billing
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - apps/web-portal/app/api/stripe/checkout/route.ts
  - apps/web-portal/lib/stripe.ts
  - apps/web-portal/app/api/stripe/webhook/route.ts
autonomous: true

must_haves:
  truths:
    - "User can start individual checkout without being org admin"
    - "Stripe subscription metadata identifies individual vs org type"
    - "Webhook handler updates userSubscriptions table for individual subscriptions"
  artifacts:
    - path: "apps/web-portal/app/api/stripe/checkout/route.ts"
      provides: "Individual checkout flow"
      contains: "individual"
    - path: "apps/web-portal/lib/stripe.ts"
      provides: "createIndividualCheckout function"
      contains: "createIndividualCheckout"
    - path: "apps/web-portal/app/api/stripe/webhook/route.ts"
      provides: "Individual subscription webhook handling"
      contains: "userSubscriptions"
  key_links:
    - from: "apps/web-portal/app/api/stripe/checkout/route.ts"
      to: "createIndividualCheckout"
      via: "function call for individual mode"
      pattern: "createIndividualCheckout"
    - from: "apps/web-portal/app/api/stripe/webhook/route.ts"
      to: "userSubscriptions"
      via: "database insert/update"
      pattern: "userSubscriptions.*insert|insert.*userSubscriptions"
---

<objective>
Extend checkout and webhook handling to support individual subscriptions alongside organization subscriptions.

Purpose: Individual users need a billing path that doesn't require organization admin access. The subscription is tied to their email and works across any workspace.
Output: Checkout endpoint that accepts mode=individual, webhook handler that routes to correct table based on metadata.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-individual-billing/11-RESEARCH.md
@.planning/phases/11-individual-billing/11-01-SUMMARY.md
@apps/web-portal/app/api/stripe/checkout/route.ts
@apps/web-portal/app/api/stripe/webhook/route.ts
@apps/web-portal/lib/stripe.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add individual checkout support</name>
  <files>
    apps/web-portal/app/api/stripe/checkout/route.ts
    apps/web-portal/lib/stripe.ts
  </files>
  <action>
1. Add createIndividualCheckout function to lib/stripe.ts:

```typescript
/**
 * Create individual user checkout session - not tied to organization
 * Subscription follows user email across all workspaces
 */
export async function createIndividualCheckout(options: {
  email: string;
  planId: string;
  successUrl: string;
  cancelUrl: string;
}): Promise<Stripe.Checkout.Session> {
  const stripe = getStripe();
  const trialDays = parseInt(process.env.TRIAL_DAYS || '14');

  // Get or create individual customer by email
  const existingCustomers = await stripe.customers.list({
    email: options.email.toLowerCase(),
    limit: 1,
  });

  let customerId: string;
  if (existingCustomers.data.length > 0) {
    customerId = existingCustomers.data[0].id;
  } else {
    const customer = await stripe.customers.create({
      email: options.email.toLowerCase(),
      metadata: { type: 'individual' },
    });
    customerId = customer.id;
  }

  // Map plan to price ID
  const priceId = options.planId === 'individual_starter'
    ? process.env.STRIPE_PRICE_ID_INDIVIDUAL_STARTER
    : process.env.STRIPE_PRICE_ID_INDIVIDUAL_PRO || process.env.STRIPE_PRICE_ID_PRO;

  if (!priceId) {
    throw new Error(`No price configured for individual plan: ${options.planId}`);
  }

  return stripe.checkout.sessions.create({
    customer: customerId,
    mode: 'subscription',
    line_items: [{ price: priceId, quantity: 1 }], // Individual = 1 seat
    success_url: options.successUrl,
    cancel_url: options.cancelUrl,
    subscription_data: {
      trial_period_days: trialDays,
      trial_settings: { end_behavior: { missing_payment_method: 'pause' } },
      metadata: {
        type: 'individual',
        email: options.email.toLowerCase(),
        planId: options.planId
      },
    },
    payment_method_collection: 'if_required',
    metadata: {
      type: 'individual',
      email: options.email.toLowerCase(),
      planId: options.planId
    },
  });
}
```

2. Modify checkout route to accept mode parameter and route accordingly:

```typescript
import { verifySession } from '@/lib/auth/dal';
import { createIndividualCheckout } from '@/lib/stripe';

export async function POST(request: Request) {
  try {
    const body = await request.json().catch(() => ({}));
    const mode: 'individual' | 'organization' = body.mode || 'organization';

    if (mode === 'individual') {
      // Individual checkout - just needs authenticated user with email
      const session = await verifySession();

      if (!session.email) {
        return NextResponse.json(
          { error: 'Email required for individual billing' },
          { status: 400 }
        );
      }

      const planId = body.planId || 'individual_pro';
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://speakforme.app';

      const checkoutSession = await createIndividualCheckout({
        email: session.email,
        planId,
        successUrl: `${baseUrl}/settings/billing?success=true&trial_started=true`,
        cancelUrl: `${baseUrl}/settings/billing?canceled=true`,
      });

      return NextResponse.json({ url: checkoutSession.url });
    }

    // Existing organization checkout logic (unchanged)
    const session = await requireAdmin();
    // ... rest of existing code
  }
}
```

The route now handles both modes:
- mode=individual: Uses verifySession (any authenticated user), creates individual checkout
- mode=organization (default): Uses requireAdmin, creates org checkout (existing behavior)
  </action>
  <verify>
Run `npm run typecheck --workspace=web-portal` to verify types.
Verify createIndividualCheckout is exported from lib/stripe.ts.
  </verify>
  <done>Checkout endpoint accepts mode=individual and creates individual checkout session with email metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Extend webhook to handle individual subscriptions</name>
  <files>apps/web-portal/app/api/stripe/webhook/route.ts</files>
  <action>
Extend the webhook handler to route subscription events based on metadata.type:

1. Import userSubscriptions from schema:
```typescript
const { organizations, userSubscriptions } = schema;
```

2. Modify subscription event handlers to check metadata.type:

```typescript
case 'customer.subscription.created':
case 'customer.subscription.updated': {
  const subscription = event.data.object as Stripe.Subscription;
  const customerId = subscription.customer as string;
  const type = subscription.metadata?.type;

  if (type === 'individual') {
    // Individual subscription - update userSubscriptions table
    const email = subscription.metadata.email;
    if (!email) {
      console.error('Individual subscription missing email in metadata');
      break;
    }

    await db.insert(userSubscriptions)
      .values({
        email: email.toLowerCase(),
        stripeCustomerId: customerId,
        stripeSubscriptionId: subscription.id,
        subscriptionStatus: subscription.status,
        planId: subscription.metadata.planId || 'individual_pro',
        trialEndsAt: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
        updatedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: userSubscriptions.email,
        set: {
          stripeCustomerId: customerId,
          stripeSubscriptionId: subscription.id,
          subscriptionStatus: subscription.status,
          planId: subscription.metadata.planId || 'individual_pro',
          trialEndsAt: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
          updatedAt: new Date(),
        },
      });

    console.log(`Individual subscription ${event.type} for ${email}, status: ${subscription.status}`);
  } else {
    // Organization subscription - existing logic
    await db.update(organizations)
      .set({
        stripeSubscriptionId: subscription.id,
        subscriptionStatus: subscription.status,
        seatCount: subscription.items.data[0]?.quantity || 1,
        trialEndsAt: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
        updatedAt: new Date(),
      })
      .where(eq(organizations.stripeCustomerId, customerId));

    console.log(`Org subscription ${event.type} for customer ${customerId}, status: ${subscription.status}`);
  }
  break;
}
```

3. Similarly update customer.subscription.deleted handler:

```typescript
case 'customer.subscription.deleted': {
  const subscription = event.data.object as Stripe.Subscription;
  const customerId = subscription.customer as string;
  const type = subscription.metadata?.type;

  if (type === 'individual') {
    const email = subscription.metadata.email;
    if (email) {
      await db.update(userSubscriptions)
        .set({ subscriptionStatus: 'canceled', updatedAt: new Date() })
        .where(eq(userSubscriptions.email, email.toLowerCase()));
    }
  } else {
    await db.update(organizations)
      .set({ subscriptionStatus: 'canceled', updatedAt: new Date() })
      .where(eq(organizations.stripeCustomerId, customerId));
  }
  break;
}
```

4. Update customer.subscription.paused and resumed handlers similarly.

5. Update checkout.session.completed to handle individual:

```typescript
case 'checkout.session.completed': {
  const session = event.data.object as Stripe.Checkout.Session;
  const type = session.metadata?.type;

  if (type === 'individual') {
    // Individual checkout - userSubscriptions already updated by subscription.created
    console.log(`Individual checkout completed for ${session.metadata?.email}`);
  } else if (session.metadata?.organizationId) {
    // Existing org logic
    // ...
  }
  break;
}
```

6. For email notifications (trial_will_end, paused, resumed, payment_failed), add individual handling to send to the subscription email directly rather than org billingEmail.
  </action>
  <verify>
Run `npm run typecheck --workspace=web-portal` to verify types.
Review that all subscription event handlers check metadata.type.
  </verify>
  <done>Webhook handler routes individual subscription events to userSubscriptions table, org events to organizations table.</done>
</task>

</tasks>

<verification>
1. createIndividualCheckout function exists and creates proper Stripe session
2. Checkout route handles mode=individual and mode=organization
3. Webhook handler checks metadata.type and routes to correct table
4. Individual subscription events create/update userSubscriptions records
</verification>

<success_criteria>
- POST /api/stripe/checkout with mode=individual creates individual checkout
- Individual checkout includes trial, metadata with type=individual and email
- Webhook updates userSubscriptions for individual subscriptions
- Webhook updates organizations for org subscriptions (unchanged behavior)
- Email notifications work for both individual and org subscriptions
</success_criteria>

<output>
After completion, create `.planning/phases/11-individual-billing/11-02-SUMMARY.md`
</output>
