---
phase: 15-slack-ai-assistant-experience
plan: 03
type: execute
wave: 2
depends_on: ["15-01", "15-02"]
files_modified:
  - apps/slack-backend/src/assistant/assistant.ts
  - apps/slack-backend/src/assistant/handlers/thread-started.ts
  - apps/slack-backend/src/assistant/handlers/thread-context.ts
  - apps/slack-backend/src/assistant/handlers/user-message.ts
  - apps/slack-backend/src/assistant/suggested-prompts.ts
  - apps/slack-backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - "User can open the assistant panel and see a welcome message"
    - "User sees context-aware suggested prompts based on the channel they are viewing"
    - "When user switches channels, the assistant detects the new context"
    - "When user types a message in the assistant panel, it is received and acknowledged"
  artifacts:
    - path: "apps/slack-backend/src/assistant/assistant.ts"
      provides: "Assistant class instantiation with three handlers"
      contains: "new Assistant"
    - path: "apps/slack-backend/src/assistant/handlers/thread-started.ts"
      provides: "threadStarted handler with welcome message and prompts"
      exports: ["handleThreadStarted"]
    - path: "apps/slack-backend/src/assistant/handlers/thread-context.ts"
      provides: "threadContextChanged handler with saveThreadContext"
      exports: ["handleThreadContextChanged"]
    - path: "apps/slack-backend/src/assistant/handlers/user-message.ts"
      provides: "userMessage handler with status and placeholder response"
      exports: ["handleUserMessage"]
    - path: "apps/slack-backend/src/assistant/suggested-prompts.ts"
      provides: "Dynamic prompt generation based on channel context"
      exports: ["generateSuggestedPrompts"]
  key_links:
    - from: "apps/slack-backend/src/app.ts"
      to: "apps/slack-backend/src/assistant/assistant.ts"
      via: "app.assistant() registration"
      pattern: "app\\.assistant"
    - from: "apps/slack-backend/src/assistant/handlers/thread-started.ts"
      to: "apps/slack-backend/src/assistant/suggested-prompts.ts"
      via: "import and call generateSuggestedPrompts"
      pattern: "generateSuggestedPrompts"
---

<objective>
Create the Assistant class with threadStarted, threadContextChanged, and userMessage handlers. The assistant will greet users with context-aware suggested prompts and route messages for processing.

Purpose: This is the core assistant infrastructure that enables the side-panel UX. threadStarted provides the entry point, threadContextChanged enables context awareness, and userMessage routes user input for AI generation.
Output: Working assistant that greets users, shows prompts, tracks context, and acknowledges messages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-slack-ai-assistant-experience/15-RESEARCH.md
@apps/slack-backend/src/app.ts
@apps/slack-backend/src/services/context.ts
@apps/slack-backend/src/services/watch.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create suggested prompts generator and assistant handlers</name>
  <files>
    apps/slack-backend/src/assistant/suggested-prompts.ts
    apps/slack-backend/src/assistant/handlers/thread-started.ts
    apps/slack-backend/src/assistant/handlers/thread-context.ts
    apps/slack-backend/src/assistant/handlers/user-message.ts
  </files>
  <action>
1. Create `apps/slack-backend/src/assistant/suggested-prompts.ts`:
   - Export `generateSuggestedPrompts(context: { channel_id?: string }): Array<{ title: string; message: string }>`
   - Generate prompts based on channel context:
     - If `channel_id` starts with 'D' (DM): prompts like "Help me respond professionally", "Make this more empathetic", "Help me de-escalate this"
     - If `channel_id` starts with 'C' or 'G' (channel/group): prompts like "Suggest a response to the latest message", "Help me contribute to this discussion", "Summarize the key points"
     - If no channel_id: generic prompts like "Help me craft a professional message", "Rewrite this more concisely"
   - Each prompt object has `title` (short label, ~3 words) and `message` (the actual prompt text, 1 sentence)
   - Return 3-4 prompts per context type

2. Create `apps/slack-backend/src/assistant/handlers/thread-started.ts`:
   - Export `handleThreadStarted` as an async function matching Bolt's Assistant threadStarted handler signature
   - Destructure: `{ say, setSuggestedPrompts, event }`
   - Send welcome message via `say()`:
     ```
     "Hi! I'm Speak for Me. I'll help you craft professional responses to workplace messages. Tell me what you need help with, or pick a suggestion below."
     ```
   - Extract `channel_id` from `event.assistant_thread.context` (may be undefined if no context)
   - Call `generateSuggestedPrompts({ channel_id })` to get prompts
   - Call `setSuggestedPrompts({ prompts })` with the generated prompts
   - Wrap in try/catch, log errors with the project's logger (`import { logger } from '../../utils/logger.js'`)

3. Create `apps/slack-backend/src/assistant/handlers/thread-context.ts`:
   - Export `handleThreadContextChanged` as an async function matching Bolt's Assistant threadContextChanged handler signature
   - Destructure: `{ saveThreadContext, event }`
   - Call `await saveThreadContext()` — this automatically persists the channel context via message metadata (built into Bolt's ThreadContextStore)
   - Log the context change: `logger.debug({ channel_id: event?.assistant_thread?.context?.channel_id }, 'Assistant thread context changed')`
   - Wrap in try/catch, log errors

4. Create `apps/slack-backend/src/assistant/handlers/user-message.ts`:
   - Export `handleUserMessage` as an async function matching Bolt's Assistant userMessage handler signature
   - Destructure: `{ say, client, setTitle, setStatus, event, context }`
   - Set title: `await setTitle(event.text?.slice(0, 50) || 'Response suggestion')`
   - Set status: `await setStatus('thinking...')`
   - For NOW (placeholder — streaming wired in plan 15-04): Just call `say()` with a placeholder message: "I'm working on your suggestion... (streaming coming soon)"
   - Then clear status: `await setStatus('')`
   - The `context` object from the Assistant's ThreadContextStore provides `channel_id` (the channel the user is viewing). Log it.
   - Wrap in try/catch. On error, clear status and send error message via `say()`.
  </action>
  <verify>
All four files exist and export the expected functions. `npm run build --workspace=@slack-speak/slack-backend` compiles without errors.
  </verify>
  <done>
Four assistant handler files created: suggested-prompts generator, threadStarted handler with welcome + prompts, threadContextChanged handler with context persistence, and userMessage handler with placeholder response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Assistant class and register with app</name>
  <files>
    apps/slack-backend/src/assistant/assistant.ts
    apps/slack-backend/src/app.ts
  </files>
  <action>
1. Create `apps/slack-backend/src/assistant/assistant.ts`:
   - Import `{ Assistant }` from `'@slack/bolt'`
   - Import the three handlers from their files
   - Import logger
   - Create and export the assistant instance:
     ```typescript
     import { Assistant } from '@slack/bolt';
     import { handleThreadStarted } from './handlers/thread-started.js';
     import { handleThreadContextChanged } from './handlers/thread-context.js';
     import { handleUserMessage } from './handlers/user-message.js';
     import { logger } from '../utils/logger.js';

     export const assistant = new Assistant({
       threadStarted: handleThreadStarted,
       threadContextChanged: handleThreadContextChanged,
       userMessage: handleUserMessage,
     });

     logger.info('Assistant instance created');
     ```

2. Update `apps/slack-backend/src/app.ts`:
   - Add import: `import { assistant } from './assistant/assistant.js';`
   - After all existing handler registrations (after `registerTaskCompletionModalHandler(app);`), add:
     ```typescript
     // Register AI assistant
     app.assistant(assistant);
     ```
   - Add a log line: `logger.info('AI assistant registered');` (use the existing logger import, or add one if not present — check if logger is already imported in app.ts; if not, import it from `'./utils/logger.js'`)
   - Do NOT modify any existing handler registrations or the App constructor
  </action>
  <verify>
`npm run build --workspace=@slack-speak/slack-backend` compiles without errors. `grep 'app.assistant' apps/slack-backend/src/app.ts` returns a match.
  </verify>
  <done>
Assistant class created with three handlers and registered with the Bolt app. The app is ready to receive assistant_thread_started, assistant_thread_context_changed, and message.im events in the assistant context.
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=@slack-speak/slack-backend` — zero errors
2. `ls apps/slack-backend/src/assistant/` shows assistant.ts, suggested-prompts.ts, and handlers/ directory
3. `grep 'app.assistant' apps/slack-backend/src/app.ts` — confirms registration
4. `grep 'new Assistant' apps/slack-backend/src/assistant/assistant.ts` — confirms instantiation
</verification>

<success_criteria>
- Assistant class instantiated with threadStarted, threadContextChanged, userMessage handlers
- Assistant registered with app via app.assistant()
- threadStarted sends welcome message and context-aware suggested prompts
- threadContextChanged persists context via saveThreadContext()
- userMessage acknowledges input with placeholder (streaming wired in 15-04)
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-slack-ai-assistant-experience/15-03-SUMMARY.md`
</output>
