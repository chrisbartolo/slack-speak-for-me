---
phase: 03-ai-personalization
plan: 04
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - apps/slack-backend/src/services/personalization/consentService.ts
  - apps/slack-backend/src/services/personalization/index.ts
autonomous: true

must_haves:
  truths:
    - "User can grant consent for message history analysis"
    - "User can revoke consent at any time"
    - "System checks consent before accessing message history"
    - "Consent status is tracked per user per workspace"
  artifacts:
    - path: "apps/slack-backend/src/services/personalization/consentService.ts"
      provides: "GDPR consent management for message history access"
      exports: ["grantConsent", "revokeConsent", "hasConsent", "ConsentType"]
  key_links:
    - from: "apps/slack-backend/src/services/personalization/consentService.ts"
      to: "packages/database"
      via: "drizzle client for gdprConsent table"
      pattern: "import.*gdprConsent.*from"
---

<objective>
Create the GDPR consent service that manages user consent for message history analysis, addressing the critical blocker identified in STATE.md.

Purpose: Phase 3 cannot access user message history without explicit GDPR consent. This service provides the consent tracking mechanism that gates access to the historical message analysis feature (AI-05, AI-06).

Output: consentService.ts with grantConsent(), revokeConsent(), and hasConsent() functions. Message history features will check hasConsent() before accessing any historical data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-personalization/03-RESEARCH.md
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create consent service</name>
  <files>apps/slack-backend/src/services/personalization/consentService.ts</files>
  <action>
Create consentService.ts with GDPR-compliant consent management:

```typescript
import { eq, and, isNull } from 'drizzle-orm';
import { db } from '@slack-speak/database';
import { gdprConsent } from '@slack-speak/database/schema';
import { logger } from '../../utils/logger.js';

/**
 * Types of consent that can be requested
 */
export const ConsentType = {
  MESSAGE_HISTORY_ANALYSIS: 'message_history_analysis',
} as const;

export type ConsentType = typeof ConsentType[keyof typeof ConsentType];

interface ConsentKey {
  workspaceId: string;
  userId: string;
  consentType: ConsentType;
}

/**
 * Check if user has active consent for a specific purpose
 * Returns true only if consent was granted AND not revoked
 */
export async function hasConsent(key: ConsentKey): Promise<boolean> {
  const result = await db
    .select()
    .from(gdprConsent)
    .where(
      and(
        eq(gdprConsent.workspaceId, key.workspaceId),
        eq(gdprConsent.userId, key.userId),
        eq(gdprConsent.consentType, key.consentType)
      )
    )
    .limit(1);

  if (result.length === 0) {
    return false;
  }

  const consent = result[0];

  // Must have consented and not revoked
  return consent.consentedAt !== null && consent.revokedAt === null;
}

/**
 * Grant consent for a specific purpose
 * Creates new record or updates existing revoked consent
 */
export async function grantConsent(key: ConsentKey): Promise<void> {
  const existing = await db
    .select()
    .from(gdprConsent)
    .where(
      and(
        eq(gdprConsent.workspaceId, key.workspaceId),
        eq(gdprConsent.userId, key.userId),
        eq(gdprConsent.consentType, key.consentType)
      )
    )
    .limit(1);

  if (existing.length > 0) {
    // Update existing record (re-granting after revocation)
    await db
      .update(gdprConsent)
      .set({
        consentedAt: new Date(),
        revokedAt: null,
      })
      .where(
        and(
          eq(gdprConsent.workspaceId, key.workspaceId),
          eq(gdprConsent.userId, key.userId),
          eq(gdprConsent.consentType, key.consentType)
        )
      );

    logger.info({
      userId: key.userId,
      consentType: key.consentType,
    }, 'Consent re-granted');
  } else {
    // Create new consent record
    await db.insert(gdprConsent).values({
      workspaceId: key.workspaceId,
      userId: key.userId,
      consentType: key.consentType,
      consentedAt: new Date(),
    });

    logger.info({
      userId: key.userId,
      consentType: key.consentType,
    }, 'Consent granted');
  }
}

/**
 * Revoke consent for a specific purpose
 * Sets revokedAt timestamp but preserves consent history for audit
 */
export async function revokeConsent(key: ConsentKey): Promise<boolean> {
  const result = await db
    .update(gdprConsent)
    .set({
      revokedAt: new Date(),
    })
    .where(
      and(
        eq(gdprConsent.workspaceId, key.workspaceId),
        eq(gdprConsent.userId, key.userId),
        eq(gdprConsent.consentType, key.consentType),
        isNull(gdprConsent.revokedAt) // Only revoke if not already revoked
      )
    );

  const revoked = (result.rowCount ?? 0) > 0;

  if (revoked) {
    logger.info({
      userId: key.userId,
      consentType: key.consentType,
    }, 'Consent revoked');
  }

  return revoked;
}

/**
 * Get consent status with timestamps for a user
 * Returns null if no consent record exists
 */
export async function getConsentStatus(key: ConsentKey): Promise<{
  consentedAt: Date | null;
  revokedAt: Date | null;
  isActive: boolean;
} | null> {
  const result = await db
    .select()
    .from(gdprConsent)
    .where(
      and(
        eq(gdprConsent.workspaceId, key.workspaceId),
        eq(gdprConsent.userId, key.userId),
        eq(gdprConsent.consentType, key.consentType)
      )
    )
    .limit(1);

  if (result.length === 0) {
    return null;
  }

  const consent = result[0];
  return {
    consentedAt: consent.consentedAt,
    revokedAt: consent.revokedAt,
    isActive: consent.consentedAt !== null && consent.revokedAt === null,
  };
}

/**
 * Helper to check consent before accessing message history
 * Throws if consent not granted (for use in service layer)
 */
export async function requireConsent(
  workspaceId: string,
  userId: string
): Promise<void> {
  const hasAccess = await hasConsent({
    workspaceId,
    userId,
    consentType: ConsentType.MESSAGE_HISTORY_ANALYSIS,
  });

  if (!hasAccess) {
    throw new ConsentRequiredError(
      'User has not granted consent for message history analysis'
    );
  }
}

/**
 * Custom error for consent-related failures
 */
export class ConsentRequiredError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ConsentRequiredError';
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/slack-backend/tsconfig.json` - should compile without errors.
  </verify>
  <done>
consentService.ts exports hasConsent, grantConsent, revokeConsent, getConsentStatus, requireConsent, ConsentType, and ConsentRequiredError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Export consent service from personalization index</name>
  <files>apps/slack-backend/src/services/personalization/index.ts</files>
  <action>
Update the personalization index.ts to include consent service exports:

```typescript
export * from './preferencesStore.js';
export * from './feedbackTracker.js';
export * from './consentService.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/slack-backend/tsconfig.json` to verify exports work.
  </verify>
  <done>
Consent service functions are accessible via services/personalization.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/slack-backend/tsconfig.json` passes
2. hasConsent returns false for user without consent record
3. grantConsent creates consent record with consentedAt timestamp
4. hasConsent returns true after grantConsent
5. revokeConsent sets revokedAt timestamp
6. hasConsent returns false after revocation
7. requireConsent throws ConsentRequiredError when consent not granted
</verification>

<success_criteria>
- Consent is tracked per (workspaceId, userId, consentType) tuple
- grantConsent/revokeConsent maintain audit trail (both timestamps preserved)
- hasConsent returns accurate active status
- requireConsent helper provides clean error handling for service layer
- Addresses GDPR blocker identified in STATE.md
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-personalization/03-04-SUMMARY.md`
</output>
