---
phase: 16-response-time-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/schema.ts
autonomous: true

must_haves:
  truths:
    - "suggestion_metrics table exists in PostgreSQL with all 6 pipeline stage timestamp columns"
    - "Composite indexes on (workspace_id, created_at) and (organization_id, created_at) exist for fast analytics queries"
    - "suggestionId column has unique constraint for upsert pattern"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "suggestionMetrics table definition with indexes"
      contains: "suggestionMetrics"
  key_links:
    - from: "packages/database/src/schema.ts"
      to: "workspaces table"
      via: "foreign key reference"
      pattern: "references.*workspaces\\.id"
---

<objective>
Add the `suggestion_metrics` table to the Drizzle schema for tracking pipeline timing at every stage of suggestion generation.

Purpose: This table is the foundation for all response time analytics — every subsequent plan depends on it existing.
Output: Updated schema.ts with `suggestionMetrics` table exported, ready for `db:push`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@packages/database/src/schema.ts
@.planning/phases/16-response-time-analytics/16-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add suggestionMetrics table to schema.ts</name>
  <files>packages/database/src/schema.ts</files>
  <action>
Add a new `suggestionMetrics` pgTable at the end of schema.ts (before any export aggregation if present). Use these exact columns and indexes:

```typescript
export const suggestionMetrics = pgTable('suggestion_metrics', {
  id: uuid('id').primaryKey().defaultRandom(),
  suggestionId: text('suggestion_id').notNull().unique(),
  workspaceId: uuid('workspace_id').notNull().references(() => workspaces.id),
  organizationId: uuid('organization_id'), // Denormalized for fast org-wide queries
  userId: text('user_id').notNull(),
  channelId: text('channel_id'),
  triggerType: text('trigger_type'), // 'mention' | 'reply' | 'thread' | 'message_action' | 'dm'

  // Pipeline stage timestamps (nullable — filled incrementally via upsert)
  eventReceivedAt: timestamp('event_received_at'),
  jobQueuedAt: timestamp('job_queued_at'),
  aiStartedAt: timestamp('ai_started_at'),
  aiCompletedAt: timestamp('ai_completed_at'),
  deliveredAt: timestamp('delivered_at'),
  userActionAt: timestamp('user_action_at'),

  // Computed durations (milliseconds) for easier querying
  totalDurationMs: integer('total_duration_ms'),        // deliveredAt - eventReceivedAt
  aiProcessingMs: integer('ai_processing_ms'),          // aiCompletedAt - aiStartedAt
  queueDelayMs: integer('queue_delay_ms'),              // aiStartedAt - jobQueuedAt

  // Outcome tracking
  userAction: text('user_action'), // 'accepted' | 'refined' | 'dismissed' | 'sent' | null
  errorType: text('error_type'),   // 'usage_limit' | 'guardrail' | 'ai_error' | 'delivery_error' | null

  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  workspaceTimeIdx: index('suggestion_metrics_workspace_time_idx')
    .on(table.workspaceId, table.createdAt),
  orgTimeIdx: index('suggestion_metrics_org_time_idx')
    .on(table.organizationId, table.createdAt),
  userIdx: index('suggestion_metrics_user_idx')
    .on(table.userId, table.createdAt),
  channelIdx: index('suggestion_metrics_channel_idx')
    .on(table.channelId, table.createdAt),
}));
```

Important notes:
- Import `integer` from drizzle-orm/pg-core if not already imported (check existing imports).
- The `unique()` constraint on suggestionId enables the `onConflictDoUpdate` upsert pattern used by the metrics service.
- organizationId is intentionally NOT a foreign key — it's denormalized for query performance and filled at record time.
- All pipeline timestamps are nullable because they're filled incrementally at different stages.
- The computed duration columns (totalDurationMs, aiProcessingMs, queueDelayMs) are set at delivery/completion time to avoid recalculating in every query.
  </action>
  <verify>
Run `npx tsc --noEmit` in the database package to confirm no type errors:
```bash
cd packages/database && npx tsc --noEmit
```
Verify the export is available:
```bash
grep -n "suggestionMetrics" packages/database/src/schema.ts
```
  </verify>
  <done>
schema.ts contains `suggestionMetrics` table with all 6 pipeline timestamps, 3 computed duration columns, outcome tracking, 4 composite indexes, and unique constraint on suggestionId. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Push schema to database</name>
  <files>packages/database/src/schema.ts</files>
  <action>
Run the Drizzle schema push to create the table in the development database:
```bash
npm run db:push --workspace=@slack-speak-for-me/database
```

If the database is not running, start it first with `docker compose up -d`.

After push completes, verify the table and indexes exist. No need to generate a migration file — this project uses `db:push` for development.
  </action>
  <verify>
Schema push completes without errors. If database is not available (CI environment), this step can be skipped — the schema definition in schema.ts is the source of truth.
  </verify>
  <done>
suggestion_metrics table exists in PostgreSQL (or schema.ts is ready for push on next deployment).
  </done>
</task>

</tasks>

<verification>
1. `packages/database/src/schema.ts` exports `suggestionMetrics`
2. Table has columns: id, suggestion_id, workspace_id, organization_id, user_id, channel_id, trigger_type, event_received_at, job_queued_at, ai_started_at, ai_completed_at, delivered_at, user_action_at, total_duration_ms, ai_processing_ms, queue_delay_ms, user_action, error_type, created_at
3. Four composite indexes exist for workspace, org, user, and channel time-range queries
4. unique constraint on suggestion_id column
5. TypeScript compiles without errors
</verification>

<success_criteria>
- suggestionMetrics table definition exists in schema.ts with all required columns and indexes
- TypeScript compiles without errors
- Table can be pushed to database without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-response-time-analytics/16-01-SUMMARY.md`
</output>
