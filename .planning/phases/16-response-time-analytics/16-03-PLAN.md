---
phase: 16-response-time-analytics
plan: 03
type: execute
wave: 2
depends_on: ["16-01", "16-02"]
files_modified:
  - apps/slack-backend/src/handlers/events/message-reply.ts
  - apps/slack-backend/src/handlers/shortcuts/help-me-respond.ts
  - apps/slack-backend/src/assistant/handlers/user-message.ts
  - apps/slack-backend/src/assistant/streaming.ts
  - apps/slack-backend/src/jobs/queues.ts
  - apps/slack-backend/src/jobs/types.ts
  - apps/slack-backend/src/jobs/workers.ts
  - apps/slack-backend/src/services/delivery-router.ts
  - apps/slack-backend/src/services/feedback-tracker.ts
autonomous: true

must_haves:
  truths:
    - "Every suggestion gets a suggestionId generated at event entry, carried through the entire pipeline"
    - "eventReceivedAt is recorded in message-reply, help-me-respond, and assistant user-message handlers"
    - "jobQueuedAt is recorded when queueAIResponse adds the BullMQ job"
    - "aiStartedAt and aiCompletedAt are recorded in the worker before/after generateSuggestion"
    - "deliveredAt is recorded in delivery-router after successful delivery"
    - "userActionAt is recorded in feedback-tracker when user accepts/refines/dismisses"
    - "All recording calls are fire-and-forget (no await, .catch(() => {}))"
  artifacts:
    - path: "apps/slack-backend/src/jobs/types.ts"
      provides: "suggestionId field in AIResponseJobData"
      contains: "suggestionId"
    - path: "apps/slack-backend/src/handlers/events/message-reply.ts"
      provides: "recordEventReceived calls at handler entry"
      contains: "recordEventReceived"
    - path: "apps/slack-backend/src/jobs/workers.ts"
      provides: "recordAIStarted, recordAICompleted, recordDelivered calls"
      contains: "recordAIStarted"
  key_links:
    - from: "apps/slack-backend/src/handlers/events/message-reply.ts"
      to: "apps/slack-backend/src/jobs/queues.ts"
      via: "suggestionId passed through AIResponseJobData"
      pattern: "suggestionId.*queueAIResponse"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/suggestion-metrics.ts"
      via: "recording calls at AI start/end/delivery"
      pattern: "recordAI.*recordDelivered"
---

<objective>
Wire metrics recording into every stage of the suggestion pipeline: event handlers, job queue, AI worker, delivery, and feedback.

Purpose: Without integration at every stage, the metrics table stays empty. This plan ensures every suggestion generates a complete timing record from event receipt to user action.
Output: Modified handlers, queues, workers, and services with fire-and-forget metrics recording at each stage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@apps/slack-backend/src/handlers/events/message-reply.ts
@apps/slack-backend/src/handlers/shortcuts/help-me-respond.ts
@apps/slack-backend/src/assistant/handlers/user-message.ts
@apps/slack-backend/src/assistant/streaming.ts
@apps/slack-backend/src/jobs/types.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/workers.ts
@apps/slack-backend/src/services/delivery-router.ts
@apps/slack-backend/src/services/feedback-tracker.ts
@.planning/phases/16-response-time-analytics/16-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add suggestionId to job data and wire event handlers</name>
  <files>
    apps/slack-backend/src/jobs/types.ts
    apps/slack-backend/src/jobs/queues.ts
    apps/slack-backend/src/handlers/events/message-reply.ts
    apps/slack-backend/src/handlers/shortcuts/help-me-respond.ts
    apps/slack-backend/src/assistant/handlers/user-message.ts
    apps/slack-backend/src/assistant/streaming.ts
  </files>
  <action>
**Step 1: Add suggestionId to AIResponseJobData (types.ts)**

Add `suggestionId: string;` field to the `AIResponseJobData` interface, right after `workspaceId`.

**Step 2: Update queueAIResponse to accept and pass suggestionId (queues.ts)**

No change needed — the data already gets passed through. But verify it will work since we're adding a new field to the type.

**Step 3: Wire message-reply handler (message-reply.ts)**

Import `{ generateSuggestionId, recordEventReceived, recordJobQueued }` from `../../services/suggestion-metrics.js`.

At each point where `queueAIResponse` is called (there are 3 call sites: DM handler, thread reply handler), do this BEFORE the queue call:

```typescript
const suggestionId = generateSuggestionId();

// Fire-and-forget metrics recording
recordEventReceived({
  suggestionId,
  workspaceId,
  userId: watcherUserId, // or participantUserId depending on context
  channelId,
  triggerType: 'dm', // or 'thread' depending on context
}).catch(() => {});
```

Then add `suggestionId` to the `queueAIResponse` call data object.

After `queueAIResponse` returns, add:
```typescript
recordJobQueued({ suggestionId }).catch(() => {});
```

**Step 4: Wire help-me-respond shortcut (help-me-respond.ts)**

Import `{ generateSuggestionId, recordEventReceived, recordJobQueued }` from `../../services/suggestion-metrics.js`.

Right after `ack()`, generate the ID and record event:
```typescript
const suggestionId = generateSuggestionId();
recordEventReceived({
  suggestionId,
  workspaceId, // resolved later — move recording after workspaceId is resolved
  userId,
  channelId,
  triggerType: 'message_action',
}).catch(() => {});
```

Note: workspaceId isn't available until after `getWorkspaceId(teamId)`. Move the `recordEventReceived` call to right after workspaceId is resolved, but BEFORE `queueAIResponse`. Add `suggestionId` to the queue data. Record `recordJobQueued` after queue call.

**Step 5: Wire assistant user-message handler (user-message.ts)**

Import `{ generateSuggestionId, recordEventReceived }` from `../../services/suggestion-metrics.js`.

After workspaceId is resolved and before calling `streamSuggestionToAssistant`, generate ID and record:
```typescript
const suggestionId = generateSuggestionId();
recordEventReceived({
  suggestionId,
  workspaceId,
  userId,
  channelId: viewingChannelId || channelId,
  triggerType: viewingChannelId?.startsWith('D') ? 'dm' : 'message_action',
}).catch(() => {});
```

Pass `suggestionId` to `streamSuggestionToAssistant` options.

**Step 6: Wire streaming.ts**

Add `suggestionId?: string` to the `StreamOptions` interface. Import `{ recordAIStarted, recordAICompleted, recordDelivered }` from `../services/suggestion-metrics.js`.

Before `generateSuggestionStream` call, record AI started:
```typescript
if (options.suggestionId) {
  recordAIStarted({ suggestionId: options.suggestionId }).catch(() => {});
}
```

After streaming completes (after the `streamer.finalize` or final send), record AI completed and delivered:
```typescript
if (options.suggestionId) {
  const processingTimeMs = Date.now() - startTime;
  recordAICompleted({ suggestionId: options.suggestionId, aiProcessingMs: processingTimeMs }).catch(() => {});
  recordDelivered({ suggestionId: options.suggestionId }).catch(() => {});
}
```

**CRITICAL: All recording calls MUST be fire-and-forget.** Use `.catch(() => {})` after every call. NEVER await these calls in the critical path.
  </action>
  <verify>
```bash
cd apps/slack-backend && npx tsc --noEmit
```
Verify integration points:
```bash
grep -rn "recordEventReceived\|recordJobQueued\|recordAIStarted" apps/slack-backend/src/handlers/ apps/slack-backend/src/assistant/ apps/slack-backend/src/jobs/
```
Should find recordEventReceived in message-reply.ts, help-me-respond.ts, user-message.ts. recordJobQueued in message-reply.ts, help-me-respond.ts. recordAIStarted in streaming.ts and workers.ts.
  </verify>
  <done>
All event handlers generate a suggestionId and record eventReceivedAt. suggestionId flows through AIResponseJobData to the worker. jobQueuedAt recorded after queue add. Assistant path records AI timing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire worker, delivery, and feedback recording</name>
  <files>
    apps/slack-backend/src/jobs/workers.ts
    apps/slack-backend/src/services/delivery-router.ts
    apps/slack-backend/src/services/feedback-tracker.ts
  </files>
  <action>
**Step 1: Wire AI worker (workers.ts)**

Import `{ recordAIStarted, recordAICompleted, recordDelivered, recordError }` from `../services/suggestion-metrics.js`.

In the aiResponseWorker processor, extract `suggestionId` from `job.data` (it's now part of AIResponseJobData).

Before `generateSuggestion()` call:
```typescript
recordAIStarted({ suggestionId }).catch(() => {});
```

After `generateSuggestion()` returns:
```typescript
recordAICompleted({ suggestionId, aiProcessingMs: result.processingTimeMs }).catch(() => {});
```

Remove the inline `const suggestionId = ...` generation that currently exists in the worker (around line 101). The ID now comes from job.data.

When usage limit blocks generation, record the error:
```typescript
recordError({ suggestionId, errorType: 'usage_limit' }).catch(() => {});
```
Note: For the usage-blocked path, the suggestionId from job.data is used (not the `blocked_${Date.now()}` pattern).

**Step 2: Wire delivery router (delivery-router.ts)**

Import `{ recordDelivered }` from `./suggestion-metrics.js`.

Add `suggestionId?: string` to the `DeliveryOptions` interface.

After `sendSuggestionEphemeral(options)` succeeds, record delivery:
```typescript
if (options.suggestionId) {
  recordDelivered({ suggestionId: options.suggestionId }).catch(() => {});
}
```

Update the worker code that calls `routeDelivery` to pass `suggestionId` in the options.

**Step 3: Wire feedback tracker (feedback-tracker.ts)**

Import `{ recordUserAction }` from `./suggestion-metrics.js`.

In the `trackFeedback` function, after the successful db.insert, add:
```typescript
recordUserAction({
  suggestionId: params.suggestionId,
  action: params.action,
}).catch(() => {});
```

This ensures every feedback action (accepted, refined, dismissed, sent, liked, disliked) records the user action timestamp in suggestion_metrics.

**CRITICAL: All `.catch(() => {})` — no await, no error handling needed for metrics.**
  </action>
  <verify>
```bash
cd apps/slack-backend && npx tsc --noEmit
```
Verify complete pipeline coverage:
```bash
grep -rn "recordEventReceived\|recordJobQueued\|recordAIStarted\|recordAICompleted\|recordDelivered\|recordUserAction\|recordError" apps/slack-backend/src/
```
Should see at minimum:
- recordEventReceived: 3+ locations (message-reply, help-me-respond, user-message)
- recordJobQueued: 2+ locations (message-reply, help-me-respond)
- recordAIStarted: 2 locations (workers, streaming)
- recordAICompleted: 2 locations (workers, streaming)
- recordDelivered: 2 locations (delivery-router, streaming)
- recordUserAction: 1 location (feedback-tracker)
- recordError: 1+ locations (workers)
  </verify>
  <done>
Complete pipeline wired: event receipt -> job queue -> AI start -> AI complete -> delivery -> user action. Error cases tracked. All calls fire-and-forget. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. suggestionId field exists in AIResponseJobData interface
2. message-reply.ts generates suggestionId, records eventReceived and jobQueued at appropriate points
3. help-me-respond.ts generates suggestionId, records eventReceived and jobQueued
4. user-message.ts generates suggestionId, records eventReceived
5. streaming.ts records aiStarted, aiCompleted, and delivered
6. workers.ts uses job.data.suggestionId, records aiStarted, aiCompleted; passes to delivery
7. delivery-router.ts records delivered on success
8. feedback-tracker.ts records userAction on every feedback
9. All recording calls use .catch(() => {}) — zero can throw
10. TypeScript compiles without errors
</verification>

<success_criteria>
- Every suggestion path (channel, thread, DM, shortcut, assistant) generates and tracks a suggestionId from entry to user action
- All 6 pipeline stages are recorded via fire-and-forget calls
- No recording call can block or break the suggestion pipeline
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-response-time-analytics/16-03-SUMMARY.md`
</output>
