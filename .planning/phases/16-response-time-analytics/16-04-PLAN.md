---
phase: 16-response-time-analytics
plan: 04
type: execute
wave: 3
depends_on: ["16-01", "16-03"]
files_modified:
  - apps/web-portal/lib/admin/response-time-analytics.ts
  - apps/web-portal/app/admin/response-times/page.tsx
  - apps/web-portal/components/admin/response-time-charts.tsx
  - apps/web-portal/app/api/admin/response-times/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin dashboard shows avg/median/p95 response times with trend chart over last 30 days"
    - "Per-channel and per-user response time breakdowns are displayed"
    - "SLA compliance metric shows % of suggestions delivered within configurable threshold (default 10s)"
    - "Time-saved estimate compares AI-assisted response time vs assumed manual response time"
    - "CSV export downloads all response time data for the selected period"
    - "Stage-by-stage breakdown shows queue delay, AI processing, and delivery time separately"
  artifacts:
    - path: "apps/web-portal/lib/admin/response-time-analytics.ts"
      provides: "Query functions with React cache() for response time metrics"
      exports: ["getResponseTimeOverview", "getResponseTimeTrend", "getPerChannelMetrics", "getPerUserMetrics", "getSLACompliance", "getDetailedMetrics"]
    - path: "apps/web-portal/app/admin/response-times/page.tsx"
      provides: "Admin response times dashboard page"
      contains: "ResponseTimeOverview"
    - path: "apps/web-portal/components/admin/response-time-charts.tsx"
      provides: "Tremor chart components for response time visualization"
      exports: ["ResponseTimeTrendChart", "StageBreakdownChart", "SLAComplianceGauge"]
    - path: "apps/web-portal/app/api/admin/response-times/route.ts"
      provides: "CSV export endpoint"
      exports: ["GET"]
  key_links:
    - from: "apps/web-portal/app/admin/response-times/page.tsx"
      to: "apps/web-portal/lib/admin/response-time-analytics.ts"
      via: "server component data fetching"
      pattern: "getResponseTimeOverview|getResponseTimeTrend"
    - from: "apps/web-portal/app/api/admin/response-times/route.ts"
      to: "apps/web-portal/lib/admin/response-time-analytics.ts"
      via: "getDetailedMetrics query"
      pattern: "getDetailedMetrics"
    - from: "apps/web-portal/app/admin/response-times/page.tsx"
      to: "apps/web-portal/components/admin/response-time-charts.tsx"
      via: "component imports"
      pattern: "ResponseTimeTrendChart|StageBreakdownChart"
---

<objective>
Build the admin response times dashboard with analytics queries, Tremor charts, SLA compliance metric, time-saved estimate, and CSV export.

Purpose: This dashboard is the visible payoff of all the metrics collection — it proves AI ROI with concrete numbers and lets admins monitor pipeline performance.
Output: Admin page at /admin/response-times with overview cards, trend chart, stage breakdown, per-channel/user tables, SLA gauge, and CSV download.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@apps/web-portal/lib/admin/analytics.ts
@apps/web-portal/app/admin/analytics/page.tsx
@apps/web-portal/components/admin/analytics-charts.tsx
@apps/web-portal/app/api/admin/analytics/route.ts
@.planning/phases/16-response-time-analytics/16-RESEARCH.md
@.planning/phases/16-response-time-analytics/16-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create response-time-analytics query library</name>
  <files>apps/web-portal/lib/admin/response-time-analytics.ts</files>
  <action>
Create `apps/web-portal/lib/admin/response-time-analytics.ts` following the exact pattern of `analytics.ts`. Mark with `import 'server-only'` at top. Use `cache()` from React for all query functions. Call `await requireAdmin()` at the start of each function.

Import from `@/lib/db` (db, schema), from `drizzle-orm` (sql, eq, and, gte, count, desc).

Define these TypeScript interfaces:
```typescript
export interface ResponseTimeOverview {
  totalSuggestions: number;
  completedSuggestions: number; // have both eventReceivedAt and deliveredAt
  avgTotalMs: number;
  medianTotalMs: number;
  p95TotalMs: number;
  avgAiMs: number;
  avgQueueMs: number;
  avgDeliveryMs: number;
  timeSavedMinutes: number; // estimate vs manual (assume 5 min manual per message)
  errorCount: number;
}

export interface ResponseTimeTrendPoint {
  date: string;
  p50Ms: number;
  p95Ms: number;
  avgMs: number;
  count: number;
}

export interface ChannelMetric {
  channelId: string;
  count: number;
  avgMs: number;
  p95Ms: number;
}

export interface UserMetric {
  userId: string;
  count: number;
  avgMs: number;
  p95Ms: number;
  lastActive: string | null;
}

export interface SLACompliance {
  thresholdMs: number;
  totalDelivered: number;
  withinSLA: number;
  complianceRate: number; // percentage 0-100
}

export interface DetailedMetricRow {
  suggestionId: string;
  userId: string;
  channelId: string | null;
  triggerType: string | null;
  eventReceivedAt: string | null;
  deliveredAt: string | null;
  totalDurationMs: number | null;
  aiProcessingMs: number | null;
  queueDelayMs: number | null;
  userAction: string | null;
  errorType: string | null;
  createdAt: string;
}
```

**Query functions:**

1. **`getResponseTimeOverview(organizationId, workspaceId, days = 30)`**
   Uses raw SQL with `sql` template literal. Queries suggestion_metrics with:
   - COUNT(*) for totalSuggestions
   - COUNT(*) FILTER (WHERE delivered_at IS NOT NULL AND event_received_at IS NOT NULL) for completedSuggestions
   - AVG, percentile_cont(0.5), percentile_cont(0.95) on total_duration_ms (where not null)
   - AVG on ai_processing_ms, queue_delay_ms
   - COUNT(*) FILTER (WHERE error_type IS NOT NULL) for errorCount
   - Time saved: completedSuggestions * 5 minutes (assumes 5 min manual per message, AI provides instant draft)
   Filter by workspace_id and created_at >= startDate.

2. **`getResponseTimeTrend(organizationId, workspaceId, days = 30)`**
   Groups by DATE(created_at), calculates p50, p95, avg of total_duration_ms per day.
   Returns array of ResponseTimeTrendPoint sorted by date ascending.
   Use: `DATE(created_at) as date` for grouping.

3. **`getPerChannelMetrics(organizationId, workspaceId, days = 30)`**
   Groups by channel_id, calculates count, avg, p95 of total_duration_ms per channel.
   Limit to top 20 channels by count. Filter out null channels.

4. **`getPerUserMetrics(organizationId, workspaceId, days = 30)`**
   Groups by user_id, calculates count, avg, p95 of total_duration_ms per user.
   Include MAX(created_at) as lastActive. Limit to top 20 users by count.

5. **`getSLACompliance(organizationId, workspaceId, thresholdMs = 10000, days = 30)`**
   Count total delivered (where deliveredAt IS NOT NULL), count within SLA (where total_duration_ms <= thresholdMs).
   Compute complianceRate = (withinSLA / totalDelivered) * 100.

6. **`getDetailedMetrics(organizationId, workspaceId, days = 90)`**
   Select all columns for CSV export. Limit to 10000 rows. Order by created_at DESC.
   Return array of DetailedMetricRow.

**Important SQL notes:**
- Use `db.execute(sql\`...\`)` for raw SQL with percentile_cont
- Filter by `workspace_id = ${workspaceId}` (not organizationId) for workspace-level data
- Always add date range filter: `created_at >= ${startDate}`
- Handle empty results gracefully (return zeros, not NaN)
  </action>
  <verify>
```bash
cd apps/web-portal && npx tsc --noEmit
```
Verify exports:
```bash
grep "export.*function\|export.*const.*cache" apps/web-portal/lib/admin/response-time-analytics.ts
```
  </verify>
  <done>
6 query functions exist with React cache(), requireAdmin() auth, proper SQL with percentile_cont, date range filtering, and TypeScript interfaces for all return types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chart components, dashboard page, and CSV export</name>
  <files>
    apps/web-portal/components/admin/response-time-charts.tsx
    apps/web-portal/app/admin/response-times/page.tsx
    apps/web-portal/app/api/admin/response-times/route.ts
  </files>
  <action>
**Step 1: Create response-time-charts.tsx**

Create `apps/web-portal/components/admin/response-time-charts.tsx` as a `'use client'` component file. Follow the pattern from `analytics-charts.tsx`.

Components:

1. **`ResponseTimeTrendChart`** — Tremor LineChart showing p50, p95, avgMs over time
   ```typescript
   <LineChart
     className="mt-4 h-72"
     data={data}
     index="date"
     categories={['p50Ms', 'p95Ms', 'avgMs']}
     colors={['emerald', 'amber', 'blue']}
     showAnimation
     valueFormatter={(v) => `${Math.round(v)}ms`}
     yAxisWidth={60}
   />
   ```

2. **`StageBreakdownChart`** — Tremor BarList showing avg time per pipeline stage
   Props: `{ queueMs, aiMs, deliveryMs }` — renders a horizontal bar for each stage.
   ```typescript
   const data = [
     { name: 'Queue Delay', value: queueMs },
     { name: 'AI Processing', value: aiMs },
     { name: 'Delivery', value: deliveryMs - aiMs - queueMs || 0 }, // remainder
   ];
   <BarList data={data} valueFormatter={(v) => `${Math.round(v)}ms`} />
   ```

3. **`SLAComplianceGauge`** — Simple percentage display with color coding
   Props: `{ complianceRate, thresholdMs, totalDelivered, withinSLA }`
   Show a large percentage number, green if >= 95%, amber if >= 80%, red if < 80%.
   Show "X of Y within Zs threshold" below.

4. **`ChannelMetricsTable`** — Simple table of channel response times
   Use standard HTML table with Tailwind classes (not TanStack — keeps it simple).

5. **`UserMetricsTable`** — Simple table of per-user response times

**Step 2: Create admin response-times page**

Create `apps/web-portal/app/admin/response-times/page.tsx` as a server component.

Follow the exact pattern of `analytics/page.tsx`:
- `await requireAdmin()` at top
- Check `session.organizationId` exists
- Fetch all data with `Promise.all([getResponseTimeOverview, getResponseTimeTrend, getPerChannelMetrics, getPerUserMetrics, getSLACompliance])`
- Wrap in try/catch, show "No data available yet" on error

Layout:
1. **Header row:** "Response Time Analytics" title + CSV download button (links to `/api/admin/response-times?format=csv`)
2. **Overview cards (grid 2x3):**
   - Avg Response Time (avgTotalMs formatted as X.Xs)
   - Median Response Time (medianTotalMs)
   - P95 Response Time (p95TotalMs)
   - AI Processing Time (avgAiMs)
   - Time Saved (timeSavedMinutes formatted as Xh Xm)
   - Error Rate (errorCount / totalSuggestions %)
3. **SLA Compliance gauge** (full-width card)
4. **Trend chart** (full-width card)
5. **Stage breakdown** (half-width card)
6. **Per-channel metrics table** (half-width card)
7. **Per-user metrics table** (full-width card)

Use Card components from shadcn/ui and Tremor for charts.

Format milliseconds as:
- < 1000: `${ms}ms`
- >= 1000: `${(ms/1000).toFixed(1)}s`

**Step 3: Create CSV export API route**

Create `apps/web-portal/app/api/admin/response-times/route.ts` following the exact pattern of `api/admin/analytics/route.ts`.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import Papa from 'papaparse';
import { requireAdmin } from '@/lib/auth/admin';
import { getDetailedMetrics } from '@/lib/admin/response-time-analytics';

export async function GET(request: NextRequest) {
  try {
    const session = await requireAdmin();
    if (!session.organizationId) {
      return NextResponse.json({ error: 'Organization not found' }, { status: 404 });
    }

    const searchParams = request.nextUrl.searchParams;
    const format = searchParams.get('format');
    const days = parseInt(searchParams.get('days') || '90');

    const metrics = await getDetailedMetrics(session.organizationId, session.workspaceId, days);

    if (format === 'csv') {
      const csv = Papa.unparse(metrics, { header: true });
      return new NextResponse(csv, {
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="response-times-${new Date().toISOString().split('T')[0]}.csv"`,
        },
      });
    }

    return NextResponse.json(metrics);
  } catch (error) {
    console.error('Response times API error:', error);
    return NextResponse.json({ error: 'Failed to fetch response times' }, { status: 500 });
  }
}
```
  </action>
  <verify>
```bash
cd apps/web-portal && npx tsc --noEmit
```
Verify files exist:
```bash
ls -la apps/web-portal/app/admin/response-times/page.tsx
ls -la apps/web-portal/components/admin/response-time-charts.tsx
ls -la apps/web-portal/app/api/admin/response-times/route.ts
```
  </verify>
  <done>
Admin response times dashboard exists at /admin/response-times with overview cards, SLA compliance gauge, trend chart, stage breakdown, per-channel and per-user tables, and CSV export. All data fetched server-side with auth protection.
  </done>
</task>

</tasks>

<verification>
1. /admin/response-times page loads with all sections (overview, SLA, trend, breakdown, tables)
2. Overview cards show avg/median/p95 response times and time saved estimate
3. SLA compliance shows percentage within configurable threshold
4. Trend chart displays p50/p95/avg over time with Tremor LineChart
5. Stage breakdown shows queue/AI/delivery timing split
6. Per-channel and per-user tables display top 20 by volume
7. CSV export downloads at /api/admin/response-times?format=csv
8. All pages require admin authentication
9. Empty state handled gracefully when no metrics data exists
10. TypeScript compiles without errors
</verification>

<success_criteria>
- Admin can view response time analytics at /admin/response-times
- Avg/median/p95 metrics displayed with trend charts
- Per-channel and per-user breakdowns available
- SLA compliance metric shows % within threshold
- Time saved estimate displayed
- CSV export works for all response time data
- Page handles empty data gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/16-response-time-analytics/16-04-SUMMARY.md`
</output>
