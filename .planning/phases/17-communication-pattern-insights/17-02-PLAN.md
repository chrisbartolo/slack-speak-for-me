---
phase: 17-communication-pattern-insights
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - apps/slack-backend/src/services/topic-classifier.ts
  - apps/slack-backend/src/services/index.ts
  - apps/slack-backend/src/jobs/workers.ts
autonomous: true

must_haves:
  truths:
    - "classifyTopic function accepts conversation messages and target message, returns topic/confidence/reasoning"
    - "Topic classification uses Claude Sonnet 4 with 256 max_tokens and 2s timeout"
    - "Classification is fire-and-forget in the AI response worker — never blocks suggestion delivery"
    - "Classification result is inserted into topic_classifications table with organizationId, workspaceId, userId, channelId"
    - "After topic classification is stored, analyzeSentiment is called and sentiment JSONB column is updated on the same row"
    - "Any failure in classification or sentiment is logged with logger.warn and swallowed silently"
  artifacts:
    - path: "apps/slack-backend/src/services/topic-classifier.ts"
      provides: "classifyTopic function and Topic type"
      exports: ["classifyTopic", "Topic", "TopicClassification"]
    - path: "apps/slack-backend/src/services/index.ts"
      provides: "Re-exports topic classifier"
      contains: "topic-classifier"
  key_links:
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/topic-classifier.ts"
      via: "fire-and-forget .then().catch() after suggestion generation"
      pattern: "classifyTopic.*\\.then.*\\.catch"
    - from: "apps/slack-backend/src/jobs/workers.ts"
      to: "apps/slack-backend/src/services/sentiment-detector.ts"
      via: "chained fire-and-forget after topic classification insert, updates sentiment column"
      pattern: "analyzeSentiment.*\\.then.*\\.catch"
    - from: "apps/slack-backend/src/services/topic-classifier.ts"
      to: "packages/database/src/schema.ts"
      via: "db.insert(topicClassifications)"
      pattern: "topicClassifications"
---

<objective>
Create the topic classifier service and integrate it into the suggestion generation pipeline.

Purpose: Every suggestion gets classified by topic (scheduling, complaint, technical, etc.) to enable communication pattern analysis and hotspot detection.

Output: topic-classifier.ts service file with Claude prompting, integrated fire-and-forget in the AI response worker.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@apps/slack-backend/src/services/sentiment-detector.ts
@apps/slack-backend/src/services/suggestion-metrics.ts
@apps/slack-backend/src/jobs/workers.ts
@packages/database/src/schema.ts
@.planning/phases/17-communication-pattern-insights/17-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create topic classifier service</name>
  <files>apps/slack-backend/src/services/topic-classifier.ts, apps/slack-backend/src/services/index.ts</files>
  <action>
Create `apps/slack-backend/src/services/topic-classifier.ts` following the EXACT same pattern as `sentiment-detector.ts`:

1. Import Anthropic SDK, env, logger (same as sentiment-detector.ts)
2. Create shared Anthropic client instance

3. Define Topic type:
```typescript
export type Topic =
  | 'scheduling'
  | 'complaint'
  | 'technical'
  | 'status_update'
  | 'request'
  | 'escalation'
  | 'general';
```

4. Define TopicClassification interface:
```typescript
export interface TopicClassification {
  topic: Topic;
  confidence: number; // 0.0-1.0
  reasoning: string;
}
```

5. Create the TOPIC_PROMPT constant — a classification prompt with:
   - Clear instruction to classify the PRIMARY topic
   - Conversation context placeholder `{context}`
   - Target message placeholder `{targetMessage}`
   - Response format: JSON only (no markdown), with topic, confidence (0.0-1.0), reasoning
   - Explicit definitions with examples for each of the 7 topics:
     - scheduling: Meeting requests, calendar coordination, availability. Examples: "Can we meet Tuesday?", "What's your availability?"
     - complaint: Issues, problems, dissatisfaction. Examples: "This isn't working", "I'm frustrated with..."
     - technical: Tech support, how-to, troubleshooting. Examples: "How do I...?", "Error when I try to..."
     - status_update: Project progress, reports. Examples: "Here's where we stand", "Quick update on..."
     - request: Feature requests, asks. Examples: "Could you please...", "We need..."
     - escalation: Needs management attention, urgent. Examples: "I need to speak to your manager", "This is unacceptable"
     - general: Casual, unclear primary topic. Examples: "Thanks!", "Sounds good"

6. Export async function `classifyTopic`:
   - Parameters: `{ conversationMessages: Array<{ text: string; ts: string }>; targetMessage: string }`
   - Returns: `Promise<TopicClassification>`
   - Implementation follows sentiment-detector.ts pattern exactly:
     a. Define fallback: `{ topic: 'general', confidence: 0, reasoning: 'classification_failed' }`
     b. Format conversation messages as `[ts] text` joined by newlines
     c. Build prompt by replacing `{context}` and `{targetMessage}` placeholders
     d. Create AbortController with **2000ms timeout** (2 seconds — faster than sentiment's 3s since less complex)
     e. Call `anthropic.messages.create` with model `'claude-sonnet-4-20250514'`, max_tokens 256, signal
     f. Parse JSON response, validate topic is one of the 7 valid values, validate confidence 0-1
     g. Return validated TopicClassification
     h. On AbortError (timeout): logger.warn, return fallback
     i. On any error: logger.warn, return fallback
     j. Log success with topic, confidence, processingTimeMs

7. Add to `apps/slack-backend/src/services/index.ts`:
```typescript
// Topic classifier - conversation topic categorization
export {
  classifyTopic,
  type Topic,
  type TopicClassification,
} from './topic-classifier.js';
```
  </action>
  <verify>Run `npx tsc --noEmit` in apps/slack-backend to confirm no type errors. Verify the classifyTopic function is exported from index.ts.</verify>
  <done>topic-classifier.ts exists with classifyTopic function using Claude Sonnet 4, 2s timeout, 256 max_tokens, 7-topic taxonomy with fallback to 'general' on any failure. Exported from services index.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate topic classification into AI response worker</name>
  <files>apps/slack-backend/src/jobs/workers.ts</files>
  <action>
Add fire-and-forget topic classification to the AI response worker, following the same pattern as `recordAICompleted` and `recordDelivered` calls.

1. Add imports at top of workers.ts:
```typescript
import { classifyTopic } from '../services/topic-classifier.js';
import { analyzeSentiment } from '../services/sentiment-detector.js';
```
Note: `analyzeSentiment` already exists from Phase 12 — just import it.

2. Also import the database and topicClassifications table:
```typescript
import { db, workspaces, installations, decrypt, topicClassifications } from '@slack-speak/database';
```
Note: `db`, `workspaces`, `installations`, `decrypt` are already imported — just add `topicClassifications` to the existing import.

3. In the AI response worker processor function, AFTER `recordAICompleted` is called and BEFORE the delivery logic (the `try` block that fetches installation for delivery), add a fire-and-forget topic classification block:

```typescript
// Fire-and-forget: Classify topic + sentiment (NEVER blocks delivery)
classifyTopic({
  conversationMessages: contextMessages.map(m => ({ text: m.text, ts: m.ts })),
  targetMessage: triggerMessageText,
}).then(async (classification) => {
  try {
    // Resolve organizationId (reuse from suggestion-metrics pattern)
    const [ws] = await db
      .select({ organizationId: workspaces.organizationId })
      .from(workspaces)
      .where(eq(workspaces.id, workspaceId))
      .limit(1);

    const orgId = ws?.organizationId ?? '00000000-0000-0000-0000-000000000000';

    // Step 1: Insert topic classification row (sentiment initially null)
    const [inserted] = await db.insert(topicClassifications).values({
      organizationId: orgId,
      workspaceId,
      userId,
      channelId,
      suggestionId,
      topic: classification.topic,
      confidence: Math.round(classification.confidence * 100),
      reasoning: classification.reasoning,
    }).returning({ id: topicClassifications.id });

    logger.info({
      suggestionId,
      topic: classification.topic,
      confidence: classification.confidence,
    }, 'Topic classified and stored');

    // Step 2: Fire-and-forget sentiment analysis, then UPDATE the row
    // analyzeSentiment already exists from Phase 12 (sentiment-detector.ts)
    analyzeSentiment({
      conversationMessages: contextMessages.map(m => ({
        userId: m.userId,
        text: m.text,
        ts: m.ts,
      })),
      targetMessage: triggerMessageText,
    }).then(async (sentiment) => {
      try {
        await db.update(topicClassifications)
          .set({ sentiment })
          .where(eq(topicClassifications.id, inserted.id));

        logger.info({ suggestionId, tone: sentiment.tone }, 'Sentiment stored in topic classification');
      } catch (updateError) {
        logger.warn({ error: updateError, suggestionId }, 'Failed to store sentiment in topic classification');
      }
    }).catch((sentimentError) => {
      logger.warn({ error: sentimentError, suggestionId }, 'Sentiment analysis failed for topic classification');
    });
  } catch (insertError) {
    logger.warn({ error: insertError, suggestionId }, 'Failed to store topic classification');
  }
}).catch((error) => {
  logger.warn({ error, suggestionId }, 'Topic classification failed');
});
```

Key points:
- Uses `.then().catch()` pattern — NEVER awaited, NEVER blocks
- Maps contextMessages to strip userId (classifier doesn't need it)
- Stores confidence as integer 0-100 (multiply by 100)
- Resolves organizationId from workspace (same query pattern as suggestion-metrics.ts)
- Catches both classification errors AND database insert errors separately
- After inserting the topic classification row, fires a SECOND independent call to `analyzeSentiment` (already exists from Phase 12)
- On sentiment completion, UPDATEs the topic_classifications row with the sentiment JSONB
- Sentiment failure is isolated — topic classification is already stored even if sentiment fails
- Both classifyTopic and analyzeSentiment use Claude Sonnet 4, so they run as two parallel-ish short calls
  </action>
  <verify>Run `npx tsc --noEmit` in apps/slack-backend. Verify the fire-and-forget pattern is used (no await on classifyTopic). Grep for "classifyTopic" and "analyzeSentiment" in workers.ts to confirm both integrations.</verify>
  <done>Topic classification runs fire-and-forget after AI completion in the worker. Classification result stored in topic_classifications table. Sentiment analysis runs chained after topic insert and updates the sentiment JSONB column. No impact on suggestion delivery latency.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in apps/slack-backend
2. topic-classifier.ts exports classifyTopic, Topic, TopicClassification
3. workers.ts calls classifyTopic in fire-and-forget pattern after AI completion
4. Classification result is inserted into topicClassifications table
5. After insert, analyzeSentiment is called and sentiment column is updated on the same row
6. All errors (classification, insert, sentiment, sentiment update) are caught and logged (never thrown)
</verification>

<success_criteria>
Topic classifier service created following sentiment-detector.ts pattern. Integrated into AI response worker with fire-and-forget pattern. Every suggestion gets classified by topic and has sentiment analyzed, with sentiment stored in the topic_classifications.sentiment JSONB column. No impact on suggestion delivery latency.
</success_criteria>

<output>
After completion, create `.planning/phases/17-communication-pattern-insights/17-02-SUMMARY.md`
</output>
