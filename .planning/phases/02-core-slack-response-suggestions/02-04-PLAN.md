---
phase: 02-core-slack-response-suggestions
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - apps/slack-backend/src/handlers/events/app-mention.ts
  - apps/slack-backend/src/handlers/events/message-reply.ts
  - apps/slack-backend/src/handlers/events/index.ts
  - apps/slack-backend/src/handlers/index.ts
  - apps/slack-backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - "App responds when user is mentioned in monitored channel"
    - "App responds when someone replies to user's message in monitored conversation"
    - "Events trigger AI suggestion job in queue"
  artifacts:
    - path: "apps/slack-backend/src/handlers/events/app-mention.ts"
      provides: "app_mention event handler"
      contains: "app.event"
    - path: "apps/slack-backend/src/handlers/events/message-reply.ts"
      provides: "message reply detection"
      contains: "app.message"
  key_links:
    - from: "apps/slack-backend/src/handlers/events/app-mention.ts"
      to: "apps/slack-backend/src/jobs/queues.ts"
      via: "queueAIResponse"
      pattern: "queueAIResponse"
    - from: "apps/slack-backend/src/handlers/events/message-reply.ts"
      to: "apps/slack-backend/src/services/watch.ts"
      via: "isWatching check"
      pattern: "isWatching"
---

<objective>
Implement Slack event handlers for app mentions and message replies that trigger AI suggestion generation.

Purpose: These are the core automatic triggers - when a user is mentioned or when someone replies to their message in a watched conversation, the app should generate a suggestion.

Output: Event handlers registered with Bolt app that enqueue AI suggestion jobs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-slack-response-suggestions/02-RESEARCH.md

@apps/slack-backend/src/app.ts
@apps/slack-backend/src/jobs/queues.ts
@apps/slack-backend/src/jobs/types.ts
@.planning/phases/02-core-slack-response-suggestions/02-01-PLAN.md
@.planning/phases/02-core-slack-response-suggestions/02-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app_mention event handler</name>
  <files>
    apps/slack-backend/src/handlers/events/app-mention.ts
    apps/slack-backend/src/handlers/events/index.ts
  </files>
  <action>
Create apps/slack-backend/src/handlers/events/ directory and app-mention.ts:

```typescript
import type { App, AppMentionEvent } from '@slack/bolt';
import { queueAIResponse } from '../../jobs/queues.js';
import { getContextForMessage } from '../../services/context.js';
import { isWatching } from '../../services/watch.js';
import { logger } from '../../utils/logger.js';
import { installationStore } from '../../oauth/installation-store.js';

/**
 * Register app_mention event handler.
 * Triggered when the bot is @mentioned in a channel.
 *
 * IMPORTANT: Must ack() within 3 seconds, then process async via queue.
 */
export function registerAppMentionHandler(app: App): void {
  app.event('app_mention', async ({ event, client, context }) => {
    const mentionEvent = event as AppMentionEvent;

    logger.info({
      channel: mentionEvent.channel,
      user: mentionEvent.user,
      ts: mentionEvent.ts,
    }, 'App mentioned');

    // Get workspace info from context
    const teamId = context.teamId;
    if (!teamId) {
      logger.warn({ event }, 'No team ID in context');
      return;
    }

    // Look up workspace ID from installation
    const installation = await installationStore.fetchInstallation({
      teamId,
      isEnterpriseInstall: false,
    });

    if (!installation) {
      logger.warn({ teamId }, 'No installation found for team');
      return;
    }

    // The user who was mentioned is the bot, but we want to help
    // the user who sent the message. However, for mentions, we typically
    // want to generate a suggestion for the user who mentioned the bot.
    // Let's assume the pattern is: User mentions bot asking for help responding
    // to someone else. We'll use the channel context.

    // Fetch conversation context
    const contextMessages = await getContextForMessage(
      client,
      mentionEvent.channel,
      mentionEvent.ts,
      mentionEvent.thread_ts
    );

    // Extract mentioned user ID from text (the user asking for help)
    const mentionedUserId = mentionEvent.user;

    // Queue AI response job
    await queueAIResponse({
      workspaceId: teamId, // Using teamId as workspace identifier
      userId: mentionedUserId,
      channelId: mentionEvent.channel,
      messageTs: mentionEvent.ts,
      triggerMessageText: mentionEvent.text || '',
      contextMessages,
      triggeredBy: 'mention',
    }, {
      // Use message ts + channel as idempotency key
      // This is handled by BullMQ jobId option
    });

    logger.info({
      channel: mentionEvent.channel,
      user: mentionedUserId,
      jobQueued: true,
    }, 'AI response job queued for mention');
  });
}
```

Create apps/slack-backend/src/handlers/events/index.ts:

```typescript
export { registerAppMentionHandler } from './app-mention.js';
```

Implementation notes:
- Acknowledge happens automatically in Bolt (no explicit ack() needed for events)
- Use context.teamId for workspace identification
- Get context using getContextForMessage (handles thread detection)
- Queue job with idempotency (BullMQ handles duplicate prevention)
- Log all steps for debugging
  </action>
  <verify>
Run `npm run build --workspaces --if-present` - TypeScript compiles without errors.
Verify handler registered: `grep "app.event.*app_mention" apps/slack-backend/src/handlers/events/app-mention.ts`
  </verify>
  <done>
app-mention.ts created with event handler.
Handler fetches context and queues AI response job.
events/index.ts exports the registration function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message reply detection handler</name>
  <files>
    apps/slack-backend/src/handlers/events/message-reply.ts
    apps/slack-backend/src/handlers/events/index.ts
    apps/slack-backend/src/handlers/index.ts
    apps/slack-backend/src/app.ts
  </files>
  <action>
Create apps/slack-backend/src/handlers/events/message-reply.ts:

```typescript
import type { App, GenericMessageEvent } from '@slack/bolt';
import { queueAIResponse } from '../../jobs/queues.js';
import { getContextForMessage } from '../../services/context.js';
import { isWatching, isParticipatingInThread, recordThreadParticipation } from '../../services/watch.js';
import { logger } from '../../utils/logger.js';
import { installationStore } from '../../oauth/installation-store.js';

/**
 * Register message event handler for reply detection.
 * Triggered when:
 * 1. Someone replies to a user's message in a watched conversation
 * 2. New message in a thread where user is participating
 *
 * IMPORTANT: Must filter carefully to avoid spam. Only trigger when:
 * - Message is in a watched conversation
 * - User has participated in the thread recently (7 days)
 */
export function registerMessageReplyHandler(app: App): void {
  app.message(async ({ message, client, context }) => {
    // Type guard for regular messages (not subtypes like message_deleted)
    const msg = message as GenericMessageEvent;

    // Skip bot messages
    if ('bot_id' in msg && msg.bot_id) {
      return;
    }

    // Skip messages without text
    if (!msg.text) {
      return;
    }

    const teamId = context.teamId;
    if (!teamId) {
      return;
    }

    // Get installation
    const installation = await installationStore.fetchInstallation({
      teamId,
      isEnterpriseInstall: false,
    });

    if (!installation) {
      return;
    }

    // Get all users who are watching this channel
    // For each watching user, check if this message should trigger a suggestion

    // For now, we need to determine who should receive suggestions.
    // Pattern 1: Someone replied to a message - check if original author is watching
    // Pattern 2: New message in thread where user is participating

    const channelId = msg.channel;
    const threadTs = msg.thread_ts;
    const messageTs = msg.ts;
    const senderId = msg.user;

    // If this is a thread reply
    if (threadTs && threadTs !== messageTs) {
      // Check who is participating in this thread and watching this channel
      // This would require getting the original thread parent's author
      // and all thread participants

      // For MVP, we'll trigger for thread participants who are watching
      // We need to fetch thread context to find participants
      try {
        const threadMessages = await getContextForMessage(
          client,
          channelId,
          messageTs,
          threadTs
        );

        // Find unique users in thread (excluding the message sender)
        const threadParticipants = [...new Set(
          threadMessages
            .map(m => m.userId)
            .filter(userId => userId !== senderId && userId !== 'unknown')
        )];

        // For each participant, check if they're watching this channel
        for (const participantUserId of threadParticipants) {
          const watching = await isWatching(teamId, participantUserId, channelId);
          const participating = await isParticipatingInThread(teamId, participantUserId, channelId, threadTs);

          if (watching && participating) {
            // Queue suggestion for this user
            await queueAIResponse({
              workspaceId: teamId,
              userId: participantUserId,
              channelId,
              messageTs,
              triggerMessageText: msg.text,
              contextMessages: threadMessages,
              triggeredBy: 'thread',
            });

            logger.info({
              channel: channelId,
              threadTs,
              targetUser: participantUserId,
              sender: senderId,
            }, 'AI response queued for thread participant');
          }
        }
      } catch (error) {
        logger.error({ channelId, threadTs, error }, 'Error processing thread message');
      }
    }

    // Record thread participation for the sender (for future thread detection)
    if (threadTs && senderId) {
      try {
        await recordThreadParticipation(teamId, senderId, channelId, threadTs);
      } catch (error) {
        logger.debug({ error }, 'Failed to record thread participation (non-critical)');
      }
    }
  });
}
```

Update apps/slack-backend/src/handlers/events/index.ts:
```typescript
export { registerAppMentionHandler } from './app-mention.js';
export { registerMessageReplyHandler } from './message-reply.js';
```

Update apps/slack-backend/src/handlers/index.ts:
```typescript
export { healthRoutes, logHealthEndpointsRegistered } from './health.js';
export { registerAppMentionHandler, registerMessageReplyHandler } from './events/index.js';
```

Update apps/slack-backend/src/app.ts to register event handlers:
```typescript
import { App } from '@slack/bolt';
import { env } from './env.js';
import { installationStore } from './oauth/installation-store.js';
import { errorHandler } from './middleware/error-handler.js';
import { healthRoutes, logHealthEndpointsRegistered, registerAppMentionHandler, registerMessageReplyHandler } from './handlers/index.js';

// ... existing app configuration ...

// Register event handlers
registerAppMentionHandler(app);
registerMessageReplyHandler(app);

// ... rest of file ...
```

Implementation notes:
- Filter bot messages to avoid loops
- Check isWatching before triggering (user must have watched the channel)
- Check isParticipatingInThread for thread messages
- Record participation on every message for future detection
- Use thread context for thread messages, channel context for others
  </action>
  <verify>
Run `npm run build --workspaces --if-present` - TypeScript compiles without errors.
Verify message handler: `grep "app.message" apps/slack-backend/src/handlers/events/message-reply.ts`
Verify app registration: `grep "registerAppMentionHandler\|registerMessageReplyHandler" apps/slack-backend/src/app.ts`
  </verify>
  <done>
message-reply.ts handles thread messages and replies.
Checks isWatching and isParticipatingInThread before triggering.
Records thread participation for future detection.
Both handlers registered in app.ts.
TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build --workspaces --if-present` - all packages compile
2. Verify event handlers: `grep -r "app.event\|app.message" apps/slack-backend/src/handlers/events/`
3. Verify handler registration: `grep "registerAppMentionHandler\|registerMessageReplyHandler" apps/slack-backend/src/app.ts`
4. Verify queue integration: `grep "queueAIResponse" apps/slack-backend/src/handlers/events/*.ts`
</verification>

<success_criteria>
- app_mention handler triggers AI suggestion when bot is mentioned
- message handler detects replies in watched conversations
- Thread participation is tracked and checked
- Jobs queued with proper context and trigger type
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-slack-response-suggestions/02-04-SUMMARY.md`
</output>
