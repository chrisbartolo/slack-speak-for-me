---
phase: 02-core-slack-response-suggestions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/slack-backend/src/services/context.ts
  - apps/slack-backend/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - "System can retrieve recent conversation history from Slack"
    - "Context retrieval handles both channel messages and thread replies"
    - "Rate limiting is respected when fetching context"
  artifacts:
    - path: "apps/slack-backend/src/services/context.ts"
      provides: "Context retrieval service"
      exports: ["getConversationContext", "getThreadContext"]
  key_links:
    - from: "apps/slack-backend/src/services/context.ts"
      to: "@slack/web-api"
      via: "conversations.history and conversations.replies"
      pattern: "conversations\\.history|conversations\\.replies"
---

<objective>
Create a service for retrieving conversation context from Slack to provide AI with relevant message history.

Purpose: AI suggestions need context from the conversation to generate relevant, contextually-aware responses. This service fetches recent messages using Slack's conversations API.

Output: Context retrieval service with rate-limit aware fetching of channel and thread history.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-slack-response-suggestions/02-RESEARCH.md

@apps/slack-backend/src/app.ts
@apps/slack-backend/src/oauth/installation-store.ts
@apps/slack-backend/src/jobs/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context retrieval service for conversation and thread history</name>
  <files>
    apps/slack-backend/src/services/context.ts
    apps/slack-backend/src/services/index.ts
  </files>
  <action>
Create apps/slack-backend/src/services/context.ts:

```typescript
import { WebClient } from '@slack/web-api';
import { subMinutes } from 'date-fns';
import { logger } from '../utils/logger.js';

// Context message format for AI consumption
export interface ContextMessage {
  userId: string;
  text: string;
  ts: string;
}

// Configuration
const MAX_MESSAGES = 20;
const CONTEXT_WINDOW_MINUTES = 60;

/**
 * Get conversation context from a channel (parent messages only, no thread replies).
 * Use this for channel-level context when a user is mentioned or receives a direct message.
 */
export async function getConversationContext(
  client: WebClient,
  channelId: string,
  options?: {
    maxMessages?: number;
    contextWindowMinutes?: number;
  }
): Promise<ContextMessage[]> {
  const maxMessages = options?.maxMessages ?? MAX_MESSAGES;
  const windowMinutes = options?.contextWindowMinutes ?? CONTEXT_WINDOW_MINUTES;
  const oldest = (subMinutes(new Date(), windowMinutes).getTime() / 1000).toString();

  try {
    const result = await client.conversations.history({
      channel: channelId,
      limit: maxMessages,
      oldest,
    });

    if (!result.ok || !result.messages) {
      logger.warn({ channelId, error: result.error }, 'Failed to fetch conversation history');
      return [];
    }

    // Filter out bot messages and format for AI
    const contextMessages: ContextMessage[] = result.messages
      .filter(m => m.type === 'message' && !m.bot_id && m.text)
      .map(m => ({
        userId: m.user || 'unknown',
        text: m.text || '',
        ts: m.ts || '',
      }))
      .reverse(); // Chronological order (oldest first)

    logger.info({
      channelId,
      messagesRetrieved: contextMessages.length,
      windowMinutes,
    }, 'Conversation context retrieved');

    return contextMessages;
  } catch (error) {
    logger.error({ channelId, error }, 'Error fetching conversation context');
    throw error;
  }
}

/**
 * Get thread context (parent message + all replies).
 * Use this when the trigger is a thread reply or thread mention.
 */
export async function getThreadContext(
  client: WebClient,
  channelId: string,
  threadTs: string,
  options?: {
    maxMessages?: number;
    contextWindowMinutes?: number;
  }
): Promise<ContextMessage[]> {
  const maxMessages = options?.maxMessages ?? MAX_MESSAGES;
  const windowMinutes = options?.contextWindowMinutes ?? CONTEXT_WINDOW_MINUTES;
  const oldest = (subMinutes(new Date(), windowMinutes).getTime() / 1000).toString();

  try {
    const result = await client.conversations.replies({
      channel: channelId,
      ts: threadTs,
      limit: maxMessages,
      oldest,
    });

    if (!result.ok || !result.messages) {
      logger.warn({ channelId, threadTs, error: result.error }, 'Failed to fetch thread context');
      return [];
    }

    // Filter out bot messages and format for AI
    const contextMessages: ContextMessage[] = result.messages
      .filter(m => m.type === 'message' && !m.bot_id && m.text)
      .map(m => ({
        userId: m.user || 'unknown',
        text: m.text || '',
        ts: m.ts || '',
      }));

    // conversations.replies returns in chronological order already

    logger.info({
      channelId,
      threadTs,
      messagesRetrieved: contextMessages.length,
    }, 'Thread context retrieved');

    return contextMessages;
  } catch (error) {
    logger.error({ channelId, threadTs, error }, 'Error fetching thread context');
    throw error;
  }
}

/**
 * Get context for a specific message, determining whether to use channel or thread context.
 * If the message has a thread_ts different from its ts, it's a thread reply.
 */
export async function getContextForMessage(
  client: WebClient,
  channelId: string,
  messageTs: string,
  threadTs?: string
): Promise<ContextMessage[]> {
  // If there's a thread_ts and it's different from messageTs, get thread context
  if (threadTs && threadTs !== messageTs) {
    return getThreadContext(client, channelId, threadTs);
  }

  // Check if messageTs is itself a thread parent
  // by fetching replies and seeing if there are any
  try {
    const result = await client.conversations.replies({
      channel: channelId,
      ts: messageTs,
      limit: 2, // Just check if there are replies
    });

    // If there are multiple messages, this is a thread
    if (result.ok && result.messages && result.messages.length > 1) {
      return getThreadContext(client, channelId, messageTs);
    }
  } catch {
    // If this fails, fall back to channel context
    logger.debug({ channelId, messageTs }, 'Could not determine thread status, using channel context');
  }

  // Default to channel context
  return getConversationContext(client, channelId);
}
```

Update apps/slack-backend/src/services/index.ts to export context service:
```typescript
export {
  getConversationContext,
  getThreadContext,
  getContextForMessage,
  type ContextMessage,
} from './context.js';
```

Implementation notes:
- Use date-fns subMinutes (already installed in Phase 1)
- Filter out bot messages to avoid AI responding to itself
- conversations.history returns newest first, so reverse for AI
- conversations.replies returns chronological order
- getContextForMessage handles the thread detection logic
- Log message counts for monitoring context window effectiveness
  </action>
  <verify>
Run `npm run build --workspaces --if-present` - TypeScript compiles without errors.
Verify exports: `grep -E "export.*(getConversationContext|getThreadContext)" apps/slack-backend/src/services/context.ts`
  </verify>
  <done>
context.ts exports getConversationContext, getThreadContext, and getContextForMessage.
Functions handle both channel and thread context retrieval.
Bot messages filtered out, results formatted for AI consumption.
TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rate limiting wrapper for Slack API calls</name>
  <files>
    apps/slack-backend/src/services/context.ts
  </files>
  <action>
Add rate limiting to context.ts to handle Slack's API limits.

Note: As of March 2026, non-Marketplace apps have 1 req/min limit on conversations.* APIs.
However, the app will likely be submitted to Marketplace, so use a reasonable rate limit.

Add at the top of context.ts:

```typescript
import { RateLimiter } from 'limiter';

// Rate limiter for Slack conversations API
// Tier 3: 50 requests per minute (Marketplace apps)
// Non-Marketplace: 1 request per minute (very restrictive)
// We'll use a moderate limit that works for testing
const conversationsRateLimiter = new RateLimiter({
  tokensPerInterval: 20, // 20 requests per minute
  interval: 'minute',
});

// Wrapper to apply rate limiting before Slack API calls
async function rateLimitedCall<T>(fn: () => Promise<T>): Promise<T> {
  const remaining = await conversationsRateLimiter.removeTokens(1);
  if (remaining < 0) {
    logger.warn({ remaining }, 'Rate limit approaching for Slack API');
  }
  return fn();
}
```

Then wrap the API calls in getConversationContext and getThreadContext:

```typescript
// In getConversationContext:
const result = await rateLimitedCall(() =>
  client.conversations.history({
    channel: channelId,
    limit: maxMessages,
    oldest,
  })
);

// In getThreadContext:
const result = await rateLimitedCall(() =>
  client.conversations.replies({
    channel: channelId,
    ts: threadTs,
    limit: maxMessages,
    oldest,
  })
);
```

Also install the limiter package:
```bash
npm install limiter --workspace=apps/slack-backend
```

Add type definition (limiter has built-in types, but verify):
The limiter package provides TypeScript types natively.

Implementation notes:
- Start with 20 req/min which is moderate
- Can be adjusted based on Marketplace status
- Rate limiter logs warning when approaching limit
- This prevents cascading failures from hitting Slack rate limits
  </action>
  <verify>
Run `npm run build --workspaces --if-present` - TypeScript compiles without errors.
Verify limiter installed: `grep "limiter" apps/slack-backend/package.json`
Verify rate limiting in place: `grep "rateLimitedCall" apps/slack-backend/src/services/context.ts`
  </verify>
  <done>
limiter package installed.
Rate limiting wrapper applied to all Slack conversations API calls.
Moderate rate limit (20/min) configured with warning logs.
TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build --workspaces --if-present` - all packages compile
2. Verify context service exports: `grep "export" apps/slack-backend/src/services/index.ts`
3. Verify rate limiting: `grep "RateLimiter\|rateLimitedCall" apps/slack-backend/src/services/context.ts`
4. Verify limiter installed: `grep "limiter" apps/slack-backend/package.json`
</verification>

<success_criteria>
- Context service retrieves channel history via conversations.history
- Context service retrieves thread history via conversations.replies
- getContextForMessage determines correct context type automatically
- Rate limiting prevents Slack API abuse
- Bot messages filtered from context
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-slack-response-suggestions/02-03-SUMMARY.md`
</output>
